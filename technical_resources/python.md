---
title: "技术基础"
path: ""
---


### 一.Python基础

#### (一). Python简介

Python 是一个高层次的结合了解释性、编译性、互动性和面向对象的脚本语言。
Python 的设计具有很强的可读性，相比其他语言经常使用英文关键字，其他语言的一些标点符号，它具有比其他语言更有特色语法结构。

* Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节。类似于PHP和Perl语言。

* Python 是交互式语言： 这意味着，您可以在一个Python提示符，直接互动执行写你的程序.

* Python 是面向对象语言: 这意味着Python支持面向对象的风格或代码封装在对象的编 程技术。

* Python 是初学者的语言：Python 对初级程序员而言，是一种伟大的语言，它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。

#### (二). Python基础语法

##### 变量类型

变量存储在内存中的值。这就意味着在创建变量时会在内存中开辟一个空间。
基于变量的数据类型，解释器会分配指定内存，并决定什么数据可以被存储在内存中。
因此，变量可以指定不同的数据类型，这些变量可以存储整数，小数或字符。

###### 1. 变量赋值
Python 中的变量赋值不需要类型声明。
每个变量在内存中创建，都包括变量的标识，名称和数据这些信息。
每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。
等号（=）用来给变量赋值。
等号（=）运算符左边是一个变量名,等号（=）运算符右边是存储在变量中的值。例如：

<pre><code>
counter = 100 # 赋值整型变量<br>
miles = 1000.0 # 浮点型<br>
name = "John" # 字符串
print counter<br>
print miles<br>
print name
</code></pre>

以上实例中，100，1000.0和"John"分别赋值给counter，miles，name变量。
执行以上程序会输出如下结果：

<pre><code>
100<br>
1000.0<br>
John
</code></pre>

###### 2.标准数据类型
在内存中存储的数据可以有多种类型。<br>
例如，一个人的年龄可以用数字来存储，他的名字可以用字符来存储。<br>
Python 定义了一些标准类型，用于存储各种类型的数据。
Python有五个标准的数据类型：

* Numbers（数字）
* String（字符串）
* List（列表）
* Tuple（元组）
* Dictionary（字典）

###### (1) Numbers
Python支持四种不同的数字类型：

* int（有符号整型）
* long（长整型[也可以代表八进制和十六进制]）
* float（浮点型）
* complex（复数）

|      | int       |long        |float      |complex  |
| :--- | :-------: |:-------- -:|:---------:|:-------: |
| 实例  |10        |51924361L   | 0.0       |    3.14j |
| 实例  |100       |-0x19323L   | -21.9      |    9.322e-36j |
| 实例  |10        |535633629843L  | 15.20      |    3e+26J|
| 实例  |10        |-052318172735L |70.2E-12     |   4.53e-7j |

长整型也可以使用小写 l，但是还是建议您使用大写 L，避免与数字 1 混淆。Python使用 L 来显示长整型。

Python 还支持复数，复数由实数部分和虚数部分构成，可以用 a + bj,或者 complex(a,b) 表示， 复数的实部 a 和虚部 b 都是浮点型<br>

**注意**: long 类型只存在于 Python2.X 版本中，在 2.2 以后的版本中，int 类型数据溢出后会自动转为long类型。在 Python3.X 版本中 long 类型被移除，使用 int 替代。

###### (2)字符串 String
###### 定义
字符串或串(String)是由数字、字母、下划线组成的一串字符。<br>
一般记为 :<br>
s = "a1a2···an"(n>=0)<br>
它是编程语言中表示文本的数据类型。

###### 字符串截取与拼接
python的字串列表有2种取值顺序:
* 从左到右索引默认0开始的，最大范围是字符串长度少1

* 从右到左索引默认-1开始的，最大范围是字符串开头

如果你要实现从字符串中获取一段子字符串的话，可以使用 [头下标:尾下标] 来截取相应的字符串，其中下标是从 0 开始算起，可以是正数或负数，下标可以为空表示取到头或尾。

[头下标:尾下标] 获取的子字符串包含头下标的字符，但不包含尾下标的字符。<br>
例如：s[1,5]<br>
当使用以冒号分隔的字符串，python 返回一个新的对象，结果包含了以这对偏移标识的连续的内容，左边的开始是包含了下边界。
上面的结果包含了 s[1] 的值，而取到的最大范围不包括尾下标，就是 s[5] 的值。

加号（+）是字符串连接运算符，星号（\*）是重复操作。如下实例：

<per><code>
str = 'Hello World!'
print str           
print str[0]        <br>
print str[2:5]      <br>
print str[2:]       <br>
print str * 2       <br>
print str + "TEST"
</code></pre>

以上实例输出结果:
<code>
Hello World!<br>
H<br>
llo<br>
llo World!<br>
Hello World!Hello World!<br>
Hello World!TEST
</code></pre>

###### (3) 列表
List（列表） 是 Python 中使用最频繁的数据类型。
列表可以完成大多数集合类的数据结构实现。它支持字符，数字，字符串甚至可以包含列表（即嵌套）。<br>

列表用 [ ] 标识，是 python 最通用的复合数据类型。
列表中值的切割也可以用到变量 [头下标:尾下标] ，就可以截取相应的列表，从左到右索引默认 0 开始，从右到左索引默认 -1 开始，下标可以为空表示取到头或尾。

加号 + 是列表连接运算符，星号 * 是重复操作。如下实例：

<pre><code>
list = [ 'runoob', 786 , 2.23, 'john', 70.2 ]<br>
tinylist = [123, 'john']
print list               <br>
print list[0]            <br>
print list[1:3]          <br>
print list[2:]           <br>
print tinylist * 2       <br>
print list + tinylist    <br>
</code></pre>
以上实例输出结果：

<pre><code>
['runoob', 786, 2.23, 'john', 70.2]<br>
runoob<br>
[786, 2.23]<br>
[2.23, 'john', 70.2]<br>
[123, 'john', 123, 'john']<br>
['runoob', 786, 2.23, 'john', 70.2, 123, 'john']
</code></pre>
###### (4) 元组

元组是另一个数据类型，类似于List（列表）。
元组用"()"标识。内部元素用逗号隔开。但是元组不能二次赋值，相当于只读列表。

###### (5) 字典
字典(dictionary)是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象集合，字典是无序的对象集合。

两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。
字典用"{ }"标识。字典由索引(key)和它对应的值value组成。

<pre><code>
dict = {}<br>
dict['one'] = "This is one"<br>
dict[2] = "This is two"<br>
tinydict = {'name': 'john','code':6734, 'dept': 'sales'}
print dict['one']          <br>
print dict[2]              <br>
print tinydict             <br>
print tinydict.keys()      <br>
print tinydict.values()    <br>
</code></pre>

输出结果为：

<code>
This is one <br>
This is two<br>
{'dept': 'sales', 'code': 6734, 'name': 'john'}<br>
['dept', 'code', 'name']<br>
['sales', 6734, 'john']<br>
</code>

###### (6) 数据类型转换


|函数             | 描述            |
| :-------------: | :-------------: |
| int(x [,base])  | 将x转换为一个整数 |
|  long(x[,base]) | 将x转换为一个长整数|
| float(x)        | 将x转换到一个浮点数|
| str(x)          | 将对象 x 转换为字符串|
| tuple(s)        | 将序列 s 转换为一个元组|
| list(s)         | 将序列 s 转换为一个列表 |

##### Python运算符

* 算术运算符
* 比较（关系）运算符
* 赋值运算符
* 逻辑运算符
* 位运算符
* 成员运算符
* 身份运算符
* 运算符优先级

###### 1. 算术运算符

**假设变量 a = 10,b = 20**

| 运算符          |    描述        | 实例          |
| :------------- | :------------- |:------------- |
|        +       | 加 - 两个对象相加|a + b 输出结果 30|
|        -       | 减 - 得到负数或是一个数减去另一个数 |a - b 输出结果 -10|
|        *       |乘 - 两个数相乘或是返回一个被重复若干次的字符串|a * b 输出结果 200|
|        /       | 除 - x除以y     |b / a 输出结果 2  |
|        %       |取模 - 返回除法的余数|b % a 输出结果 0  |
|       **       |幂 - 返回x的y次幂 |a**b 为10的20次方 |
|       //       |取整除 - 返回商的整数部分（向下取整）|9//2 输出结果 4   |


###### 2. 比较运算符

| 运算符          | 描述           |实例           |
| :------------- | :------------- |:------------- |
| ==             | 等于 - 比较对象是否相等|(a == b) 返回 False      |
| !=             |不等于 - 比较两个对象是否不相等|(a != b) 返回 true|
| >              | 大于 - 返回x是否大于y|(a > b) 返回 False |
| <              | 小于 - 返回x是否小于y|(a < b) 返回 true  |
| >=             |大于等于 - 返回x是否大于等于y|(a >= b) 返回 False|
| <=             |小于等于 - 返回x是否小于等于y|(a <= b) 返回 true|
| <>             |不等于 - 比较两个对象是否不相等|(a <> b) 返回 true|


###### 3. 赋值运算符

| 运算符          | 描述           |实例           |
| :------------- | :------------- |:------------- |
| =              | 简单的赋值运算符|c = a + b 将 a + b 的运算结果赋值为 c|
| +=             | 加法赋值运算符  |c += a 等效于 c = c + a|
| -=             | 减法赋值运算符  |c -= a 等效于 c = c - a|
| *=             | 乘法赋值运算符  |c \*= a 等效于 c = c \* a|
| /=             | 除法赋值运算符  |c /= a 等效于 c = c / a|
| %=             | 取模赋值运算符  |c %= a 等效于 c = c % a|
| **=            | 幂赋值运算符    |c \**= a 等效于 c = c ** a|
| //=            | 取整除赋值运算符|c //= a 等效于 c = c // a|

###### 4. 位运算符

按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下:
下表中变量 a 为 60，b 为 13，二进制格式如下：

a = 0011 1100<br>
b = 0000 1101


|运算符| 描述           |实例          |
| :--| :------------- |:------------- |
| &  |按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0 |(a & b) 输出结果 12 ，二进制解释： 0000 1100|
| ^  |按位异或运算符：当两对应的二进位相异时，结果为1 |(a ^ b) 输出结果 49 ，二进制解释： 0011 0001|
| ~  |按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1 。~x 类似于 -x-1|(~a ) 输出结果 -61 ，二进制解释： 1100 0011，在一个有符号二进制数的补码形式|
| << |左移动运算符：运算数的各二进位全部左移若干位，由 << 右边的数字指定了移动的位数，高位丢弃，低位补0|a << 2 输出结果 240 ，二进制解释： 1111 0000|
| >> |右移动运算符：把">>"左边的运算数的各二进位全部右移若干位，>> 右边的数字指定了移动的位数|a >> 2 输出结果 15 ，二进制解释： 0000 1111|



###### 5. 逻辑运算符

假设变量： a = 10 ,b = 20

| 运算符          | 描述          |实例            |
| :------------- | :------------- |:------------- |
|    and         |布尔"与" - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值 |(a and b) 返回 20|
|    or          |布尔"或" - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值|(a or b) 返回 10|
|    not         |布尔"非" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True|not(a and b) 返回 False|

###### 6. 成员运算符

| 运算符  | 描述           | 实例          |
| :----- | :------------- |:------------- |
| in     | 如果在指定的序列中找到值返回 True，否则返回 False |x 在 y 序列中 , 如果 x 在 y 序列中返回 True|
| not in |如果在指定的序列中没有找到值返回 True，否则返回 False|x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True|


###### 7. 身份运算符

| 运算符         | 描述            | 实例          |
| :------------- | :------------- |:------------- |
| is             |is 是判断两个标识符是不是引用自一个对象|x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False|
| is not         |is not 是判断两个标识符是不是引用自不同对象|同对象
x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False|

##### 控制流程

###### 1. 条件语句

Python条件语句是通过一条或多条语句的执行结果（True或者False）来决定执行的代码块

Python程序语言指定任何非0和非空（null）值为true，0 或者 null为false

Python 编程中 if 语句用于控制程序的执行，基本形式为:


<code>if 判断条件:</code>

    执行语句……
<code>else:</code>

    执行语句……

其中"判断条件"成立时（非零），则执行后面的语句，而执行内容可以多行，以缩进来区分表示同一范围。<br>
else 为可选语句，当需要在条件不成立时执行内容则可以执行相关语句

当判断条件为多个值时，可以使用以下形式：
if 判断条件1:

    执行语句1……

``elif 判断条件2:``

    执行语句2……
``elif 判断条件3:``

    执行语句3……      
``else:``

    执行语句4……


###### 2. 循环语句

循环语句允许我们执行一个语句或语句组多次

###### (1). 循环类型
* for 循环

   for循环可以遍历任何序列的项目，如一个列表或者一个字符串,
   for循环的语法格式如下：

   <code> for iterating_var in sequence:</code>
          statements(s)


* while 循环

  while 语句用于循环执行程序，即在某条件下，循环执行某段程序，以处理需要重复处理的相同任务。其基本形式为：

  <code>while 判断条件：</code>
      执行语句……


###### (2). 循环控制语句

| 控制语句        | 描述           |
| :------------- | :------------- |
| break 语句     | 在语句块执行过程中终止循环，并且跳出整个循环             |
| continue 语句  | 在语句块执行过程中终止当前循环，跳出该次循环执行下一次循环|
| pass  语句     | pass是空语句，是为了保持程序结构的完整性                |

##### 函数
函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。

函数能提高应用的模块性，和代码的重复利用率。你已经知道Python提供了许多内建函数，比如print()。但你也可以自己创建函数，这被叫做用户自定义函数。

###### 1. 定义函数
你可以定义一个由自己想要功能的函数，以下是简单的规则：
* 函数代码块以 def 关键词开头，后接函数标识符名称和圆括号()

* 任何传入参数和自变量必须放在圆括号中间。圆括号之间可以用于定义参数

* 函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明

* 函数内容以冒号起始，并且缩进

* return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None

实例：

<pre><code>
def functionname( parameters ):
  <code>"函数_文档字符串"
  function_suite<br>
  return [expression]</code></pre>

<pre><code>
def printme( str ):
   "打印传入的字符串到标准显示设备上"
   print str
   return
</code></pre>

###### 2. 函数调用
定义一个函数只给了函数一个名称，指定了函数里包含的参数，和代码块结构。
这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从Python提示符执行

如下实例调用了printme（）函数：

<pre><code>
\# 定义函数
def printme( str ):
   "打印任何传入的字符串"
   print str;
   return;
\# 调用函数
printme("我要调用用户自定义函数!");
printme("再次调用同一函数")
</code></pre>

##### Python文件I/O

<em>这里只讲述所有基本的的I/O函数，更多函数请参考Python标准文档</em>

###### 1. 打开和关闭文件
Python 提供了必要的函数和方法进行默认情况下的文件基本操作。你可以用 file 对象做大部分的文件操作

###### (1). open函数

你必须先用Python内置的open()函数打开一个文件，创建一个file对象，相关的方法才可以调用它进行读写<br>
语法：
<code>
file object = open(file_name , access_mode, buffering)
</code>

各个参数的细节如下：
* file_name：file_name变量是一个包含了你要访问的文件名称的字符串值

* access_mode：access_mode决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)

* buffering:如果buffering的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认

**不同模式打开文件的完全列表:**

| 模式 | 描述            |
| :----| :------------- |
| t    | 文本模式 (默认) |
| x    | 写模式，新建一个文件，如果该文件已存在则会报错  |
| b    | 二进制模式       |
| +    | 打开一个文件进行更新(可读可写)       |
| U    | 通用换行模式（不推荐）      |
| r    | 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式   |
| rb   |以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等  |
| r+   | 打开一个文件用于读写。文件指针将会放在文件的开头  |
| rb+  | 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等    |
| w    | 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件 |
| wb   | 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等 |
| w+   | 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件  |
| wb+  | 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等|
| a    | 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入 |
| ab   | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入 |
| a+   | 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写  |
| ab+  | 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写  |

###### (2). file对象的属性

一个文件被打开后，你有一个file对象，你可以得到有关该文件的各种信息
以下是和file对象相关的所有属性的列表：

| 属性           | 描述            |
| :------------- | :------------- |
| file.closed    | 返回true如果文件已被关闭，否则返回false  |
| file.mode      | 返回被打开文件的访问模式  |
| file.name      | 返回文件的名称   |
| file.softspace | 如果用print输出后，必须跟一个空格符，则返回false。否则返回true  |

如下实例：

<pre><code>
\#!/usr/bin/python
\# -*- coding: UTF-8 -*-
\# 打开一个文件
fo = open("foo.txt", "w")
print("文件名: ", fo.name)
print ("是否已关闭 : ", fo.closed)
print ("访问模式 : ", fo.mode)
print ("末尾是否强制加空格 : ", fo.softspace)
</code></pre>

得到结果：
<pre><code>
文件名:  foo.txt
是否已关闭 :  False
访问模式 :  w
末尾是否强制加空格 :  0
</code></pre>

###### (3). close()方法

File 对象的 close（）方法刷新缓冲区里任何还没写入的信息，并关闭该文件，这之后便不能再进行写入。<br>
当一个文件对象的引用被重新指定给另一个文件时，Python 会关闭之前的文件。用 close（）方法关闭文件是一个很好的习惯。 <br>
语法：

``fileObject.close()``

例子:

<pre><code>
\#!/usr/bin/python
\# -*- coding: UTF-8 -*-
\# 打开一个文件
fo = open("foo.txt", "w")
print "文件名: ", fo.name
\# 关闭打开的文件
fo.close()
</code></pre>

结果如下：

<code>文件名:  foo.txt</code>

###### (4). write()方法

ite()方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。 <br>
write()方法不会在字符串的结尾添加换行符('\n')：

语法：

<code>fileObject.write(string)</code>

在这里，被传递的参数是要写入到已打开文件的内容

例子：
<pre><code>
\#!/usr/bin/python
\# -*- coding: UTF-8 -*-
\# 打开一个文件
fo = open("foo.txt", "w")
fo.write( "www.runoob.com!\nVery good site!\n")
\# 关闭打开的文件
fo.close()
</code></pre>

结果如下：

上述方法会创建foo.txt文件，并将收到的内容写入该文件，并最终关闭文件。如果你打开这个文件，将看到以下内容:
<pre><code>
$ cat foo.txt
www.runoob.com!
Very good site!
</code></pre>

###### (5). read()方法

read（）方法从一个打开的文件中读取一个字符串。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。

语法：

``fileObject.read([count])``

在这里，被传递的参数是要从已打开文件中读取的字节计数。该方法从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾。

例子：
这里我们用到以上创建的 foo.txt 文件

<pre><code>
\#!/usr/bin/python
\# -*- coding: UTF-8 -*-
\# 打开一个文件
fo = open("foo.txt", "r+")
str = fo.read(10)
print "读取的字符串是 : ", str
\# 关闭打开的文件
fo.close()
</code></pre>

结果如下：

``读取的字符串是 :  www.runoob``

**注**：

| 序号 |      方法及描述        |
| :-- | :----------------------|
| 1| file.close() 关闭文件,关闭后文件不能再进行读写操作   |
| 2| file.flush() 刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入 |
| 3| file.fileno() 返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上 |
| 4| file.isatty() 如果文件连接到一个终端设备返回 True，否则返回 Fals |
| 5|file.next() 返回文件下一行   |
| 6| file.read([size]) 从文件读取指定的字节数，如果未给定或为负则读取所有|
| 7| file.readline([size] 读取整行，包括 "\n" 字符  |
| 8|file.readlines([sizeint]) 读取所有行并返回列表，若给定sizeint>0，则是设置一次读多少字节，这是为了减轻读取压力    |
| 9| file.seek(offset[, whence])设置文件当前位置  |
| 10| file.tell() 返回文件当前位置  |
| 11| file.truncate([size]) 截取文件，截取的字节通过size指定，默认为当前文件位置   |
| 12| file.write(str) 将字符串写入文件，返回的是写入的字符长度   |
| 13| file.writelines(sequence) 向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符     |

##### Python面向对象

Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。本章节我们将详细介绍Python的面向对象编程。

如果你以前没有接触过面向对象的编程语言，那你可能需要先了解一些面向对象语言的一些基本特征，在头脑里头形成一个基本的面向对象的概念，这样有助于你更容易的学习Python的面向对象编程。

接下来我们先来简单的了解下面向对象的一些基本特征。

###### 1. 简介

* 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。

* 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。

* 数据成员：类变量或者实例变量, 用于处理类及其实例对象的相关的数据。

* 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。

* 实例变量：定义在方法中的变量，只作用于当前实例的类。

* 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟"是一个（is-a）"关系（例图，Dog是一个Animal）。

* 实例化：创建一个类的实例，类的具体对象。

* 方法：类中定义的函数。

* 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。

###### 2. 创建类

使用 class 语句来创建一个新类，class 之后为类的名称并以冒号结尾:

<pre><code>
class ClassName:
   '类的帮助信息'   #类文档字符串
   class_suite  #类体
</code></pre>

实例：

<pre><code>
#!/usr/bin/python
# -*- coding: UTF-8 -*-
class Employee:
   '所有员工的基类'
   empCount = 0

   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1

   def displayCount(self):
     print("Total Employee %d" % Employee.empCount)

   def displayEmployee(self):
      print ("Name : ", self.name,  ", Salary: ", self.salary)
</code></pre>

* empCount 变量是一个类变量，它的值将在这个类的所有实例之间共享。你可以在内部类或外部类使用 Employee.empCount 访问。

* 第一种方法\__init__()方法是一种特殊的方法，被称为类的构造函数或初始化方法，当创建了这个类的实例时就会调用该方法

* self 代表类的实例，self 在定义类的方法时是必须有的，虽然在调用时不必传入相应的参数。

<em>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。</em>

###### 2.创建实例对象

实例化类其他编程语言中一般用关键字 new，但是在 Python 中并没有这个关键字，类的实例化类似函数调用方式。

以下使用类的名称 Employee 来实例化，并通过 \__init__ 方法接收参数。

<pre><code>
"创建 Employee 类的第一个对象"
emp1 = Employee("Zara", 2000)
"创建 Employee 类的第二个对象"
emp2 = Employee("Manni", 5000)
</code></pre>

###### 3. 访问属性

您可以使用点号 . 来访问对象的属性。使用如下类的名称访问类变量:

<pre><code>
emp1.displayEmployee()
emp2.displayEmployee()
print "Total Employee %d" % Employee.empCount
</code></pre>

完整实例：

<pre><code>
#!/usr/bin/python
# -*- coding: UTF-8 -*-

class Employee:
   '所有员工的基类'
   empCount = 0

   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1

   def displayCount(self):
     print "Total Employee %d" % Employee.empCount

   def displayEmployee(self):
      print "Name : ", self.name,  ", Salary: ", self.salary

"创建 Employee 类的第一个对象"
emp1 = Employee("Zara", 2000)
"创建 Employee 类的第二个对象"
emp2 = Employee("Manni", 5000)
emp1.displayEmployee()
emp2.displayEmployee()
print "Total Employee %d" % Employee.empCount
</code></pre>

###### 4. 类的继承

面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。
通过继承创建的新类称为子类或派生类，被继承的类称为基类、父类或超类。

在python中继承中的一些特点：

1. 如果在子类中需要父类的构造方法就需要显示的调用父类的构造方法，或者不重写父类的构造方法。详细说明可查看：python 子类继承父类构造函数说明。

2. 在调用基类的方法时，需要加上基类的类名前缀，且需要带上 self 参数变量。区别在于类中调用普通函数时并不需要带上 self 参数

3. Python 总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。（先在本类中查找调用的方法，找不到才去基类中找）。

实例：

<pre><code>
#!/usr/bin/python
# -*- coding: UTF-8 -*-

class Parent:        # 定义父类
   parentAttr = 100
   def __init__(self):
      print "调用父类构造函数"

   def parentMethod(self):
      print '调用父类方法'

   def setAttr(self, attr):
      Parent.parentAttr = attr

   def getAttr(self):
      print "父类属性 :", Parent.parentAttr

class Child(Parent): # 定义子类
   def __init__(self):
      print "调用子类构造方法"

   def childMethod(self):
      print '调用子类方法'

c = Child()          # 实例化子类
c.childMethod()      # 调用子类的方法
c.parentMethod()     # 调用父类方法
c.setAttr(200)       # 再次调用父类的方法 - 设置属性值
c.getAttr()          # 再次调用父类的方法 - 获取属性值
</code></pre>

结果如下:

<pre><code>
调用子类构造方法
调用子类方法
调用父类方法
父类属性 : 200
</code></pre>
