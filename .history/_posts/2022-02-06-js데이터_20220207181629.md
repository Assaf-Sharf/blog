---
layout: single
title: "[JS] JS 데이터"
categories: JS
tag: [JS Levelup]
toc: true
author_profile: false
sidebar:
  nav: "docs"
search: true
---

# 문자(String)

## length

- 속성(property)
- 길이 측정할때 띄어쓰기도 포함!

```js
const str = "01 23";
str.length; // 5
```

## indexOf()

- 일치하는 부분의 **첫 인덱스**를 반환
- 없으면 -1 반환

```js
const str = "Hello World!";
str.indexOf("World"); // 6
```

## slice()

- index a부터 b **직전**까지 슬라이스

```js
const str = "Hello World!";
str.slice(0, 5); // Hello
```

## replace()

- 문자열 대체
- 원본 문자열은 그대로 보존됨!

```js
const str = "Hello World!";
const newStr = str.replace("World!", "");
console.log(str); // Hello World!
console.log(newStr); // Hello
```

## match()

- **정규표현식**과 사용됨
- 결과 배열 반환

```js
const email = "shinsj4653@gmail.com";
console.log(email.match(/.+(?=@)/)[0]);
// shinsj4653
// -> 배열 중에서 첫번째 요소
```

## trim()

- **양옆 공백** 없애기
- 역시 원본 문자열은 그대로 유지됨

```js
const pw = "    pass word   ";
console.log(pw.trim()); // 'pass word'
console.log(pw); //'     pass word   '
```

# 숫자와 수학

## Math: 수학적인 상수와 함수를 위한 속성과 메소드를 가진 **내장 객체(함수 객체 X)**

- toFixed()
- parseInt(), parseFloat()
- ceil(), floor(), round(), random()

```js
const pi = 3.1415926;

const piStr = pi.toFixed(2);
// 2번째 짜리까지 유지하고 나머지는 '버리기'
// toFixed() : string 리턴함

console.log(typeof piStr); // string

const integer = parseInt(piStr); // 전역함수 : string을 int로 바꿈
const float = parseFloat(piStr); // 전역함수 : string을 float로 바꿈

console.log(typeof integer, typeof float); // number number

console.log("ceil: ", Math.ceil(3.14)); // 소수점 첫째자리에서 무조건 올림처리
console.log("floor: ", Math.floor(3.14)); // 소수점 첫째자리에서 무조건 내림처리
console.log("round: ", Math.round(3.14)); // 보통 반올림
console.log("random: ", Math.random()); // 0 ~ 0.9xx 사이
```

- 1부터 10중 랜덤한 **정수** 얻고 싶을때

```js
Math.floor(Math.random() * 10) + 1;
```

<br>

# 배열

## .length

- 배열 길이 반환

```js
const numbers = [1, 2, 3, 4];
console.log(numbers.length); // 4
console.log([].length); // 0
```

## .concat()

- 배열 이어 붙이기
- 원본 배열이 수정되지 않음!

```js
const numbers = [1, 2, 3, 4];
const fruits = ["Apple", "Banana", "Cherry"];

console.log(numbers.concat(fruits));
// [1, 2, 3, 4, 'Apple', 'Banana', 'Cherry']
// numbers 원본배열이 수정되지않음!
```

## .forEach()

- **[원소의 개수]**만큼 callback함수를 반복적으로 실행시킴
- 따로 값을 return하지 않음

```js
fruits.forEach(function (elements, index, array) {
  console.log(elements, index, array);
  // elements : 배열의 각 요소들
  // index : 요소의 인덱스
  // array : 원본 fruits 배열
});

const returnForEach = fruits.forEach(function (fruit, i) {
  // fruit, i처럼 elements, index를 다른 이름으로 지정가능
  console.log(fruit, i);
});

console.log(returnForEach);
// undefined -> forEach는 따로 값을 return안함
```

## .map()

- 원본 배열 수정 x

- .forEach()할때 나오는 결과들을 하나하나씩 담은 새로운 배열을 return함

- .forEach()의 결과들이 객체데이터일때 : **소괄호 ( )** 활용!

```js
// 화살표 함수 활용
const mapEx = fruits.map((fruits, index) => `${fruit}-${index}`);

console.log(mapEx);
// Array(3)
// 0: 'Apple-0'
// 1: 'Banana-1'
// 2: 'Cherry-2'
```

```js
const mapEx2 = fruits.map((fruit, index) => ({
  id: index,
  name: fruit,
})); // 객체데이터 return -> 소괄호 필요!
console.log(mapEx2);
// Array(3)
// 0: {id: 0, name: 'Apple'}
// 1: {id: 1, name: 'Banana'}
// 2: {id: 2, name: 'Cherry'}
```

## .filter()

- 원본 배열 수정 x

- 조건에 true인 요소들만 모아진 새로운 배열을 return함

```js
const numbers = [1, 2, 3, 4];

const map = numbers.map((number) => number < 3);
console.log(map); // [true, true, false, false]

const fil = numbers.filter((number) => number < 3);
// true에 해당하는 요소만 들어감
console.log(fil); // [1, 2]
```

## .find(), .findIndex()

- find() : 그 요소를 찾게되는 순간 그 요소를 return
- findIndex() : 그 요소를 찾게되는 순간 그 요소의 **인덱스**를 return
