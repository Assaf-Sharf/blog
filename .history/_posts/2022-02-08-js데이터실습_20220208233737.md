---
layout: single
title: "[JS] JS 데이터실습"
categories: JS
tag: [JS Levelup]
toc: true
author_profile: false
sidebar:
  nav: "docs"
search: true
---

# 가져오기, 내보내기 (import, export)

## js 파일들: 통로 2개 존재

1. 함수 이름 지정안해도 되는 **"default export"**
1. 함수 이름 지정해야하는 **"named export"**

## default export

- 함수 이름 지정 안해도 됨
- 다른 js에서 import 할때 **"원하는 이름"**으로 불러오기 가능!

```js
getType.js;

export default function (data) {
  return Object.prototype.toString.call(data).slice(8, -1);
}
```

```js
import _ from "lodash";
// node_modules 폴더에서 가지고옴

import checkType from "./getType";
// getType.js -> 상대경로 활용
// 기본통로 : default export
// default export는 한파일당 한번만 사용가능
// './getType.js'에서 js 생략 가능
```

## named export

- 함수 이름 지정 해야됨
- { } 안에 명시해야됨
- 한 파일에 여러번 사용 가능

```js
getRandom.js;

export function random() {
  return Math.floor(Math.random() * 10); // 0 ~ 9.xx
}

export const user = {
  name: "Heropy",
  age: 85,
};

export default 123;
// 그냥 export(named export)와 export default 한파일에 둘다 사용가능
// 단, default export는 딱 하나만 가능
```

```js
import { random, user as heropy } from "./getRandom";
// 꺼내올때는 이름 그대로, 사용할 때는 user as heropy처럼 다르게 사용가능
```

- ' \* ' : wildcard character
- 한꺼번에 다 가져오기도 가능

```js
import * as R from "./getRandom";
console.log(R);
// { default: 123, user: {…}, __esModule: true, random: ƒ }
```

<br>

# lodash 사용법 (MDN 읽기 권장)

- import \_ from 'lodash' -> { } 중괄호 사용 x === default export
- \_ 언더바는 통상적인 이름, 바꿔서 사용가능함

## _.uniqBy(), _.unionBy()

```js
const usersA = [
  { userId: "1", name: "HEROPY" },
  { userId: "2", name: "Neo" },
];
const usersB = [
  { userId: "1", name: "HEROPY" },
  { userId: "3", name: "Amy" },
];

const usersC = usersA.concat(usersB); // 병합
console.log("concat", usersC);
// 0: {userId: '1', name: 'HEROPY'}
// 1: {userId: '2', name: 'Neo'}
// 2: {userId: '1', name: 'HEROPY'}
// 3: {userId: '3', name: 'Amy'}

console.log("uniqBy", _.uniqBy(usersC, "userId"));
// 'userId' 속성의 값 중, 중복된게 들어가 있으면 그 중복된 데이터를 포함하고 있는 요소를 하나 없애줌

// uniqBy(판별받을 데이터 '하나', 속성값)
// 0: {userId: '1', name: 'HEROPY'}
// 1: {userId: '2', name: 'Neo'}
// 2: {userId: '3', name: 'Amy'}

const usersD = _.unionBy(usersA, usersB, "userId");
// unionBy(합칠 데이터들..., 속성값)
console.log("unionBy", usersD);
// 0: {userId: '1', name: 'HEROPY'}
// 1: {userId: '2', name: 'Neo'}
// 2: {userId: '3', name: 'Amy'}
```

데이터 하나일땐 uniqBy, 여러개일땐 unionBy 사용
{: .notice--danger}

<br>

## _.find(), _.findIndex(), \_.remove()

```js
const users = [
  { userId: "1", name: "HEROPY" },
  { userId: "2", name: "Neo" },
  { userId: "3", name: "Amy" },
  { userId: "4", name: "Evan" },
  { userId: "5", name: "Lewis" },
];

const foundUser = _.find(users, { name: "Amy" });
const foundUserIndex = _.findIndex(users, { name: "Amy" });
console.log(foundUser); // {userId: '3', name: 'Amy'}
console.log(foundUserIndex); // 2

_.remove(users, { name: "HEROPY" }); // 이 데이터를 가지고 있는 요소 삭제
console.log(users);
// 0: {userId: '2', name: 'Neo'}
// 1: {userId: '3', name: 'Amy'}
// 2: {userId: '4', name: 'Evan'}
// 3: {userId: '5', name: 'Lewis'}
```

<br>

# JSON(JavaScript Object Notation)

## 자바스크립트 객체 표기법

```json
myData.json

{
  "string": "HEROPY",
  "number": 123,
  "boolean": true,
  "null": null,
  "object": {},
  "array": []
}
```

```js
import myData from "./myData.json";
// .js만 생략 가능! 나머지는 붙여야함
// 즉, .json은 붙여야함

console.log(myData);
// 객체처럼 보여지게 출력되지만,
// 실제로는 하나의 문자데이터임!!
```

## JSON.stringify(), JSON.parse()

```js
const jsonUser = {
  name: "HEROPY",
  age: 85,
  emails: ["thesecon@gmail.com", "neo@zillinks.com"],
};

const jsonStr = JSON.stringify(jsonUser);
// JSON: 전역객체 -> stringify() 로 경량화시킴
console.log("str", jsonStr);
// str {"name":"HEROPY","age":85,"emails":["thesecon@gmail.com","neo@zillinks.com"]}
console.log(typeof jsonStr);
// string

const obj = JSON.parse(jsonStr);
// 다시 자바스크립트의 실제 데이터로 변환
console.log("obj", obj);
// obj {name: 'HEROPY', age: 85, emails: Array(2)}
```

<br>

# Storage

- 브라우저 F12 -> Application -> Storage
- Lowdb : Small JSON database for Node -> 기본적으로 Lodash를 기반으로 작동함
- localStorage는 브라우저 닫아도 만료 안됨
- sessionStorage의 데이터는 브라우저 닫으면 만료됨

```js
const jsonUser = {
  name: "HEROPY",
  age: 85,
  emails: ["thesecon@gmail.com", "neo@zillinks.com"],
};

localStorage.setItem("user", JSON.stringify(jsonUser));
// setItem -> 반드시 JSON.stringify()로 문자 데이터로 변환시켜야함!
console.log(JSON.parse(localStorage.getItem("user")));
// {name: 'HEROPY', age: 85, emails: Array(2)}
```

- localStorage의 데이터의 **"수정"**이 필요할때

```js
const strStorage = localStorage.getItem("user");
const objStorage = JSON.parse(strStorage);
//JSON.parse()한 후에, 데이터 수정
objStorage.age = 22;
console.log(objStorage);
//{name: 'HEROPY', age: 22, emails: Array(2)}
localStorage.setItem("user", JSON.stringify(objStorage));
// 다시 setItem() 할때는 JSON.stringify() 필수!
```

<br>

# OMDb API

## Query String

- 주소?속성=값&속성=값&속성=값  
  => 주소 다음에 '?' 뒤의 속성=값, 그리고 & 로 구분되어 이루어진 문자열

## axios

- omdb api에서 얻은 정보 해석가능하게 해줌
- 또한, http 요청을 처리할 수 있게 해줌

```js
import axios from "axios";

function fecthMovies() {
  axios // 데이터 요청하고 처리하는 걸 가능하게 해주는 패키지 -> axios
    .get("https://www.omdbapi.com/?apikey=7035c60c&s=frozen") // 데이터 요청
    .then((res) => {
      // res: 통상 result, response
      console.log(res);
      const h1El = document.querySelector("h1");
      const imgEl = document.querySelector("img");
      h1El.textContent = res.data.Search[0].Title;
      // search배열에 영화 데이터들 존재!
      imgEl.src = res.data.Search[0].Poster;
    });
}
fecthMovies();
```
