---
layout: single
title: "[JS] JS 데이터"
categories: JS
tag: [JS Levelup]
toc: true
author_profile: false
sidebar:
  nav: "docs"
search: true
---

# 문자(String)

## length

- 속성(property)
- 길이 측정할때 띄어쓰기도 포함!

```js
const str = "01 23";
str.length; // 5
```

## indexOf()

- 일치하는 부분의 **첫 인덱스**를 반환
- 없으면 -1 반환

```js
const str = "Hello World!";
str.indexOf("World"); // 6
```

## slice()

- index a부터 b **직전**까지 슬라이스

```js
const str = "Hello World!";
str.slice(0, 5); // Hello
```

## replace()

- 문자열 대체
- 원본 문자열은 그대로 보존됨!

```js
const str = "Hello World!";
const newStr = str.replace("World!", "");
console.log(str); // Hello World!
console.log(newStr); // Hello
```

## match()

- **정규표현식**과 사용됨
- 결과 배열 반환

```js
const email = "shinsj4653@gmail.com";
console.log(email.match(/.+(?=@)/)[0]);
// shinsj4653
// -> 배열 중에서 첫번째 요소
```

## trim()

- **양옆 공백** 없애기
- 역시 원본 문자열은 그대로 유지됨

```js
const pw = "    pass word   ";
console.log(pw.trim()); // 'pass word'
console.log(pw); //'     pass word   '
```

# 숫자와 수학

## Math: 수학적인 상수와 함수를 위한 속성과 메소드를 가진 **내장 객체(함수 객체 X)**

- toFixed()
- parseInt(), parseFloat()
- ceil(), floor(), round(), random()

```js
const pi = 3.1415926;

const piStr = pi.toFixed(2);
// 2번째 짜리까지 유지하고 나머지는 '버리기'
// toFixed() : string 리턴함

console.log(typeof piStr); // string

const integer = parseInt(piStr); // 전역함수 : string을 int로 바꿈
const float = parseFloat(piStr); // 전역함수 : string을 float로 바꿈

console.log(typeof integer, typeof float); // number number

console.log("ceil: ", Math.ceil(3.14)); // 소수점 첫째자리에서 무조건 올림처리
console.log("floor: ", Math.floor(3.14)); // 소수점 첫째자리에서 무조건 내림처리
console.log("round: ", Math.round(3.14)); // 보통 반올림
console.log("random: ", Math.random()); // 0 ~ 0.9xx 사이
```

- 1부터 10중 랜덤한 **정수** 얻고 싶을때

```js
Math.floor(Math.random() * 10) + 1;
```

<br>

# 배열

## .length

- 배열 길이 반환

```js
const numbers = [1, 2, 3, 4];
console.log(numbers.length); // 4
console.log([].length); // 0
```

## .concat()

- 배열 이어 붙이기
- 원본 배열이 수정되지 않음!

```js
const numbers = [1, 2, 3, 4];
const fruits = ["Apple", "Banana", "Cherry"];

console.log(numbers.concat(fruits));
// [1, 2, 3, 4, 'Apple', 'Banana', 'Cherry']
// numbers 원본배열이 수정되지않음!
```

## .forEach()

- **[원소의 개수]**만큼 callback함수를 반복적으로 실행시킴
- 따로 값을 return하지 않음

```js
fruits.forEach(function (elements, index, array) {
  console.log(elements, index, array);
  // elements : 배열의 각 요소들
  // index : 요소의 인덱스
  // array : 원본 fruits 배열
});

const returnForEach = fruits.forEach(function (fruit, i) {
  // fruit, i처럼 elements, index를 다른 이름으로 지정가능
  console.log(fruit, i);
});

console.log(returnForEach);
// undefined -> forEach는 따로 값을 return안함
```

## .map()

- 원본 배열 수정 x
- .forEach()할때 나오는 결과들을 하나하나씩 담은 새로운 배열을 return
- .forEach()의 결과들이 객체데이터일때 : **소괄호 ( )** 활용!

```js
// 화살표 함수 활용
const mapEx = fruits.map((fruits, index) => `${fruit}-${index}`);

console.log(mapEx);
// Array(3)
// 0: 'Apple-0'
// 1: 'Banana-1'
// 2: 'Cherry-2'
```

```js
const mapEx2 = fruits.map((fruit, index) => ({
  id: index,
  name: fruit,
})); // 객체데이터 return -> 소괄호 필요!
console.log(mapEx2);
// Array(3)
// 0: {id: 0, name: 'Apple'}
// 1: {id: 1, name: 'Banana'}
// 2: {id: 2, name: 'Cherry'}
```

## .filter()

- 원본 배열 수정 x
- 조건에 true인 요소들만 모아진 새로운 배열을 return

```js
const numbers = [1, 2, 3, 4];

const map = numbers.map((number) => number < 3);
console.log(map); // [true, true, false, false]

const fil = numbers.filter((number) => number < 3);
// true에 해당하는 요소만 들어감
console.log(fil); // [1, 2]
```

## .find(), .findIndex()

- find() : 그 요소를 찾게되는 순간 그 요소를 return
- findIndex() : 그 요소를 찾게되는 순간 그 요소의 **인덱스**를 return

```js
const fruits = ["Apple", "Banana", "Cherry"];

const findEx = fruits.find((fruit) => /^C/.test(fruit));
// 정규표현식 -> 'C'로 시작하는 요소 찾으면 find가 stop됨
//.test() -> 주어진 문자열이 정규 표현식을 만족하는지 판별 -> true 또는 false return
console.log(findEx); // Cherry

const findIndexEx = fruits.findIndex((fruit) => /^C/.test(fruit));
console.log(findIndexEx); // 2
```

## .includes()

- 요소가 포함되어 있는지 없는지의 여부(true, false)를 return함

```js
console.log(numbers.includes(2)); // true
```

## .push(), .unshift(), .reverse(),. splice()

원본 배열이 수정됨!
{: .notice--info}

```js
numbers.push(5);
console.log(numbers); // 1,2,3,4,5

numbers.unshift(0);
console.log(numbers); // 0,1,2,3,4,5

numbers.reverse();
console.log(numbers); // 5,4,3,2,1,0
```

```js
const numbers = [0, 1, 2, 3, 4, 5];

numbers.splice(2, 1); // 인덱스 2번 부터 총 1개를 삭제
console.log(numbers); // 0,1,3,4,5

numbers.splice(0, 1, 99); // 인덱스 0번 부터 1개를 삭제하고 99를 추가
console.log(numbers); // 99,1,3,4,5

fruits.splice(2, 0, "Orange"); // 인덱스 2번부터 아무것도 삭제 안할거면 0적으면 됨!
// 아무것도 삭제안하고 삽입만 하게됨!
// 원래 Apple, Orange, Cherry -> Cherry는 다음 인덱스인 3으로 밀려나감
console.log(fruits); // Apple, Banana, Orange, Cherry
```

<br>
# Object(객체)

## .assign()

- Object라는 전역객체에만 사용가능한 정적(static)메소드

```js
const userAge = {
  // key: value
  name: "Heropy",
  age: 85,
};
const userEmail = {
  name: "Heropy",
  email: "shinsj4653@gmail.com",
};

const target = Object.assign(userAge, userEmail); // target, userAge -> 같은 메모리 주소값 가짐
// userAge는 변하게됨
console.log(target);
// Object
// age: 85
// email: 'shinsj4653@gmail.com'
// name: 'Heropy'
console.log(userAge);
// Object
// age: 85
// email: 'shinsj4653@gmail.com'
// name: 'Heropy'
console.log(target === userAge); // true -> 같은 내용과 주소값을 공유하기 때문
```

- 객체 데이터는 같은 내용이여도, **주소값**이 다르면 서로 다르다고 취급함

```js
const a1 = { k: 123 };
const b1 = { k: 123 };
console.log(a1 === b1); // false -> a1 과 b1은 같은 값이여도, 다른 메모리 주소를 가짐
```

```js
const target = Object.assign({}, userAge, userEmail); // {} 가 target이 됨! userAge와 userEmail 2개를 가져와서 {} 에 assing함
console.log(target);
// 이렇게 되면 userAge는 가만히 유지됨

const target3 = Object.assign({}, userAge);
console.log(target3 === userAge); // false -> target3는 userAge와는 다른 주소값 가짐
```

## .keys()

- 객체 데이터의 key값들을 모아둔 배열 return
- key값들을 모아둔 배열에 **key값을 활용한 인덱싱** & **map함수**를 활용하면 **value값들을 모아둔 배열** 새로 생성가능

```js
const userShin = {
  name: "shin",
  age: 85,
  email: "shinsj4653@naver.com",
};

const keys = Object.keys(userShin);
console.log(keys); // ['name', 'age', 'email']

// 객체데이터의 인덱싱
console.log(userShin["name"]); // 'shin'

const values = keys.map((key) => userShin[key]);
console.log(values); // ['shin', 85, 'shinsj4653@naver.com']
```

# 구조 분해 할당 (Destructing assignment)

<div class="notice--success">
  <ul>
    <li>비구조화 할당</li>
    <li>속성들이 많을 때 사용하면 편리 -> 필요한 것만 뽑아서 사용가능</li>
  </ul>
</div>

- Object

```js
const user = {
  name: "user",
  age: 50,
  email: "ddd@gmail.com",
  country: "USA",
};

const { name: userName, age, email, address, country = "Korea" } = user;
// E.g user.address
// : -> key값 이름바꾸기, = : 키에 값 할당
// name의 값을 userName이라는 변수에 새로 할당 -> name은 이제 존재 X

console.log(`사용자의 이름은 ${userName}입니다.`); // 그냥 name이라 하면 오류남!
console.log(`${userName}의 나이는 ${age}세입니다.`);
console.log(`${userName}의 이메일 주소는 ${email}입니다.`);
console.log(address); // undefined -> 비구조화 안에서 기본값 할당하면 그 값이 나옴
console.log(country); // USA -> 이미 값이 있는 상태면 비구조화 안에서기본값 할당된 상태(Korea)여도 무시됨
```

**[주의!] 이미 값이 할당된 상태이면 비구조화 안에서 새로 값을 할당해도 그 값은 무시됨**
{: .notice--danger}

- Array

```js
const [a, b, c, d, e] = fruits; // { } 랑  [ ] 잘 구분하기!
console.log(a, b, c, d, e); // 객체 데이터는 key로 가져옴 -> 배열은 순서대로 가져와야함
// e -> undefined

const [, y] = fruits; // ','를 통해 특정 순서의 요소만 뽑아오기 가능!!
// , 하나쓸때 마다 하나씩 넘어감
console.log(y); // Banana 만 추출
```

<br>

# 전개 연산자(Spread)

```js
console.log(fruits); // [Apple, Banana, Orange, Cherry]
console.log(...fruits); // Apple, Banana, Orange, Cherry -> 배열에서 전개된 요소들이 출력됨
```

```js
const toObject = (a, b, ...c) => ({ a, b, c });
// a, b는 각각 첫번째, 두번째 요소를 가짐
// 나머지는 모두 c로 들어감(c === rest parameter)
// c에는 ...c 가 배열형태로 들어감
```

객체 데이터의 **key(속성) 의 변수명과 value의 변수명(인수)**이 같으면 위처럼 축약가능!!
{: .notice--info}
