---
categories: "learning"
---

# 1. 일대다 관계 (User > UserHistory)

- user / userHistory 는 다대일 관계로, user 하나에 여러 히스토리가 있을 수 있음

### User (class)

- JPA 를 활용하여 userHistory 를 조회하려면 user 의 필드로 userHistory 를 만들어줘야 함

- 하지만 다대일 관계이므로 userHistory 가 여러 개라서 리스트 형식으로 만들어줘야 함

- 이 때 @JoinColumn, @OneToMany 가 필요

  - @JoinColumn 은 이상한 column 이 생겼을 때 활용하는 것으로, default column name 은 userHistories_id 가 됨

  - 그렇게 안되려면 정의해줘야 함

  - @OneToMany 는 릴레이션을 위한 annotation

  - ```java
    	@JoinColumn(name = "user_id", insertable = false, updatable = false)
        @OneToMany(fetch=FetchType.EAGER)
        //nullPointException 방지용으로 기본 리스트 생성자를 넣어주는게 좋음
        private List<UserHistory> userHistories = new ArrayList<>();
    ```

### UserHistory

- user class 에서 userHistories 의 기본 이름을 user_id 로 지정하였으므로 마찬가지로 여기서도 userId 이름을 user_id 로 지정

- 그렇지 않으면 userId 와 user_id 가 헷갈

- ```java
  //userId 와 user_id 가 헷갈리므로 명시적으로 지정
  @Column(name = "user_id")
  private Long userId;
  ```

### UserHistoryRepository

- 쿼리 메소드로 `List<UserHistory> findByUserId(Long userId);` 사용

### Test

- 3번 수정 후 확인

- ```java
   @Test
      void userRelationTest(){
          User user = new User();
          user.setName("David");
          user.setEmail("David@fastcampus.com");
          user.setGender(Gender.MALE);
    
          userRepository.save(user);
    
          user.setName("daniel");
    
          userRepository.save(user);
    
          user.setEmail("daniel@fastcampus.com");
    
          userRepository.save(user);
    
          //userId 를 통해 히스토리를 조회하는 로직
          //이거는 JPA 사용 x
          /*List<UserHistory> result = userHistoryRepository.findByUserId(
                  userRepository.findByEmail("daniel@fastcampus.com").getId()
          );
          result.forEach(System.out::println);*/
    
          /*JPA 를 사용하여 더 간단하게 만듬*/
          List<UserHistory> result = userRepository.findByEmail("daniel@fastcampus.com").getUserHistories();
          
          result.forEach(System.out::println);
      }
  ```

  - getUserHistories() 의 반환값은 List<UserHistory> 임
  - userRepository 에서 daniel@fastcampus.com 을 사용하는 user 를 찾은 후,
  - getUserHIstories() 로 해당 user 의 history 를 모두 result 로 list 형식으로 받음...

# 2. 다대일 관계 (UserHistory > User)

- OneToMany 에서 참조하는 값은 one 에 해당하는 pk 값을 many 에서 fk 로 가지게 됨
- 하지만 ManyToOne 이면 해당 entity 가 필요로 하는 fk 값을 entity 가 함께 가지고 있기 때문에 더 깔끔함

### UserHistory

- ```java
  //fk 값을 따로 안만들어도 되기 때문에 없앰
  /*
  @Column(name = "user_id", insertable = false, updatable = false)
  private Long userId;*/
  
  @ManyToOne
  private User user;
  ```

  

### User

- ```java
  @JoinColumn(name = "user_id", insertable = false, updatable = false)
  @OneToMany(fetch=FetchType.EAGER)
  //순환참조를 방지하기 위해 @ToString.Exclude
  @ToString.Exclude
  private List<UserHistory> userHistories = new ArrayList<>();
  ```

### UserEntityListener

- 

  ```java
  package com.fastcampus.jpa.bookmanger.domain.listener;
  
  import ...;
  
  public class UserEntityListener {
  
      @PostPersist
      @PostUpdate
      public void prePersistAndPreUpdate(Object o){
      UserHistoryRepository userHistoryRepository = BeanUtils.getBean(UserHistoryRepository.class);
  
          User user = (User) o;
  
          UserHistory userHistory = new UserHistory();
          //setUserId 를 삭제하고 setUser 를 넣는다.
          userHistory.setName(user.getName());
          userHistory.setEmail(user.getEmail());
          userHistory.setUser(user);
  
          userHistoryRepository.save(userHistory);
      }
  }
  ```

  

# 3. Book / Publisher / Review 만들기

### Book

- review 와 일대다, publisher 와 다대일 관계

- ```java
  package com.fastcampus.jpa.bookmanger.domain;
  
  import ...;
  
  @Entity
  @NoArgsConstructor
  @Data
  @ToString(callSuper = true)
  @EqualsAndHashCode(callSuper = true)
  public class Book extends BaseEntity {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
  
      private String name;
  
      private String category;
  
      private Long authorId;
  
      @OneToOne(mappedBy = "book")
      private BookReviewInfo bookReviewInfo;
  
      //review 및 publisher 와 연결
      @OneToMany
      @JoinColumn(name = "book_id")
      @ToString.Exclude
      private List<Review> reviews = new ArrayList<>();
  
      @ManyToOne
      @ToString.Exclude
      private Publisher publisher;
  }
  
  ```

### Publisher

- 일대다 관계로 book 과 연결됨

- ```java
  package com.fastcampus.jpa.bookmanger.domain;
  
  import ...;
  
  @Entity
  @NoArgsConstructor
  @Data
  @ToString(callSuper = true)
  @EqualsAndHashCode(callSuper = true)
  public class Publisher extends BaseEntity{
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
  
      private String name;
  
      @OneToMany
      @JoinColumn(name = "publisher_id")
      private List<Book> books = new ArrayList<>();
  }
  ```

 	### Reivew

- User 와 다대일, Book 과 다대일 관계

- @ManyToOne 사용 시 user_id, book_id 값을 자동으로 가

- ```java
  package com.fastcampus.jpa.bookmanger.domain;
  
  import ...;
  
  @Entity
  @NoArgsConstructor
  @Data
  @ToString(callSuper = true)
  @EqualsAndHashCode(callSuper = true)
  public class Review extends BaseEntity {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
  
      private String title;
  
      private String content;
  
      private float score;
  
      //many 에서 book_id, user_id 를 자동으로 가짐
      @ManyToOne
      private User user;
  
      @ManyToOne
      private Book book;
  }
  ```

### User

- review 와 일대다로 연결

- ```java
  package com.fastcampus.jpa.bookmanger.domain;
  
  import ...;
  
  @NoArgsConstructor
  @AllArgsConstructor
  @RequiredArgsConstructor
  @Data
  @ToString(callSuper = true)
  @EqualsAndHashCode(callSuper = true)
  @Entity
  @EntityListeners(value = {UserEntityListener.class})
  @Table(name="TEST")
  public class User extends BaseEntity {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
  
      @NonNull
      private String name;
  
      @NonNull
      private String email;
  
      @Enumerated(value = EnumType.STRING)
      private Gender gender;
  
      @JoinColumn(name = "user_id", insertable = false, updatable = false)
      @OneToMany(fetch=FetchType.EAGER)
      @ToString.Exclude
      private List<UserHistory> userHistories = new ArrayList<>();
  
      @JoinColumn(name = "user_id")
      //fetch 는 1개밖에 사용하지 못해서 test 에 @Transactional 을 붙여줘야 함
      @OneToMany
      @ToString.Exclude
      private List<Review> reviews = new ArrayList<>();
  }
  ```


### Test

- ```java
  @Test
  @Transactional
  void bookRelationTest(){ 
      //book, review, user, publisher 생성 클래스
      givenBookAndReview();
  
      User user = userRepository.findByEmail("Martin@fastcampus.com");
      System.out.println("Review : " + user.getReviews());
  
      reviewRepository.findAll().forEach(System.out::println);
      System.out.println("Book : " + user.getReviews().get(0).getBook());
      System.out.println("Publisher : " + user.getReviews().get(0).getBook().getPublisher());
  }
  ```

  - 하지만 user.getReviews() 시 빈 리스트로 뜬다.. 왜인지 모르겠음
  - @Transactional 제거 후 User 클래스의 review 에다가 @OneToMany(fetch=FetchType.EAGER) 를 붙이면 되긴 함.. ㅠ (알아봐야할 듯)