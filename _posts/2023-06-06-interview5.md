---
layout: single
title:  "[Interview] 면접 관련 정리5"
categories: Business
tag: [web, server, DB, JPA, spring boot]
toc: true
toc_sticky: true
author_profile: false
sidebar:
    nav: "docs"
---

<br>

# Enum

Enum은 열거형(enumerated type)이라고 부르며, 서로 연관된 상수들의 집합.<br>
기존에는 final로 문자열이나 숫자들을 나타내는 기본 자료형의 값을 상수로 정의할 수 있었는데, enum을 이용하면 같은 효과를 낼 수 있다.

## 장점

1. 코드가 단순해지며, 가독성이 좋다.
2. 인스턴스 생성과 상속을 방지하여 상수값의 타입 안정성이 보장된다.
3. enum 키워드를 사용하기 때문에 구현의 의도가 열거임을 분명하게 할 수 있다.
4. 정의한 타입 이외의 타입을 가진 데이터값을 컴파일 시 체크한다.

<br>

# HashCode

HashCode란 `객체를 식별하는 하나의 고유 정수값`을 말한다.<br>
hashCode()는 객체의 메모리 번지를 이용해서 hashcode를 만들어 리턴하기 때문에 `객체마다 고유의 다른 값을 가져야 한다.`
<br>

객체 비교 시에는 `equals()`와 `hashcode()` 모두를 재정의 해야 한다.<br>

- 동등성 : 객체가 주소값이 다르더라도, 내용(필드값)이 같다면 같다.(`equals()`)
- 동일성 : 객체가 주소값이 다르면 아무리 같은 내용이라도 같지 않다.(`==`)

원래 Object 클래스의 `equals()`는 동일성 비교를 하는 것이기 때문에 재정의해줘야 한다.(equals 함수를 재정의 한 대표적인 예가 String class이다.)

> 자주쓰는 equals() 메서드는 String Class에서 재정의된 것<br>
String class는 equals() 메소드를 재정의해서 주소값 비교가 아닌 문자열 '값'만을 비교한다.

<br>

# Hash

데이터 삽입 시, 고유한 숫자를 생성해 인덱스로 사용하는 방법

## HashTable

해시 함수를 사용하여 key를 hash 값으로 매핑하고, 이 hash값을 인덱스 또는 주소삼아 key와 함께 저장하는 자료구조

- key
    - hash function의 input
    - key 값을 그대로 색인으로 사용할 경우, key의 길이 만큼의 정보를 저장할 공간도 따로 마련해줘야 하기 때문에, 고정된 길이의 hash로 변경.
- hash function
    - key를 고정된 길이의 hash로 변경해주는 역할
    - 서로 다른 key가 hashing후 같은 hash가 나오는 경우를 hash collision(해시 충돌)이라 함.

## 장점

HashTable은 key-value가 1:1로 매핑되어 있기 때문에, 삽입/삭제/검색 과정에서 모두 평균적으로 O(1)의 시간 복잡도를 가지고 있다.

## 단점

- Hash Collision
- 순서/관계가 있는 배열에는 어울리지 않는다.
- 공간 효율성이 떨어진다.
    - 데이터가 저장되기 전에 저장 공간을 미리 만들어 놓아야 한다.
    - 공간을 만들었지만, 공간이 채워지지 않는 경우가 발생.

> Key의 전체 개수와 동일한 크기의 버킷을 가진 HashTable을 `Direct-Address-Table`이라 한다.<br>
Key의 개수와 테이블의 크기가 같기 때문에 해시 충돌 문제가 발생하지 않지만, 실제 사용하지 않는 key가 존재할 경우, 전체 키의 개수만큼 테이블 크기를 유지하는 것은 메모리 낭비다.<br>
따라서, 실제 Key의 개수보다 적은 HashTable을 운용한다.

## Hash Collision 해결

### Chaining

저장소에 충돌이 일어나면 기존 값과 새로운 값을 연결 리스트로 연결하는 방법

- 장점
    - 미리 충돌을 대비해서 공간을 많이 잡을 필요가 없다.(충돌 나면 그때 공간을 만들어서 연결)
- 단점
    - 같은 hash에 자료들이 많이 연결되면 효율이 떨어진다.

### Open Addressing

충돌이 일어나면 비어있는 Hash에 데이터를 저장하는 방법<br>
Ex) hash가 동일해 충돌이 발생하면 비어있던 다음 hash에 값 저장

#### 비어있는 hash를 찾아가는 방법

- 선형 탐색
    - hash값에서 고정폭으로 건너 뛰면서 비어있는 hash가 나오면 저장.
    - 52번에서 충돌이 나고, 57번이 비어있다면 고정폭(1)씩 건너뛰면 5번 연산
    - 특정 hash값 주변 버킷이 모두 채워져 있는 문제에 취약

- 제곱 탐색
    - 고정폭이 아닌 1-4-9-16씩 건너 뛰면서 빈칸을 찾는다.
    - hash값이 같은 hash들이 들어오면 공간을 많이 확보해 놓아야 한다.

## HashMap vs HashTable

- HashMap은 보조 해시 함수를 사용하기 때문에 HashTable에 비하여 collision이 덜 발생할 수 있다는 성능상 이점이 있다.
- HashMap의 경우 동기화를 지원하지 않기 때문에, 멀티 스레드 환경이 아니라면 HashTable보다 성능이 좋다.
- 편의성 덕분에 멀티 스레드 환경에서도 HashMap을 동기화 코드로 다시 감싸서 사용하는 형태가 더 선호된다.

<br>

# Spring Bean

Bean은 스프링 컨테이너에 의해 관리되는 재사용 가능한 SW 컴포넌트이다.<br>
즉, 스프링 컨테이너가 관리하는 자바 객체를 뜻한다.
<br>

Bean은 인스턴스화된 객체를 의미하며, 스프링 컨테이너에 등록된 객체를 스프링 빈이라 한다.

<br>

# Java Reflection

리플렉션은 구체적인 클래스 타입을 알지 못하더라도, 그 클래스의 메서드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API를 말한다.<br>
컴파일 시간이 아닌 런타임 시 동적으로 특정 클래스의 정보를 추출할 수 있는 프로그래밍 기법.

## 사용

- 동적으로 클래스를 사용해야 할 때.
    - 작성 시점에는 어떤 클래스를 사용해야 할지 모르지만, 런타임 시점에 가져와 실행해야 하는 경우 필요.
- 사용 예시
    - IntelliJ 자동 완성
    - 스프링 어노테이션

## 가져올 수 있는 정보

- Class
- Constructor
- Method
- Field

<br>

# JAVA

자바는 C언어에 객체 지향적 기능을 추가하여 만든 C++과 달리, 처음부터 객체 지향 언어로 개발된 프로그래밍 언어이다.<br>
자바는 JVM을 사용하여 OS와 독립적으로 동작할 수 있다.

## 장점

- **객체 지향** 프로그램 언어로서, 개발자는 기존 코드를 재사용하고, 모듈식 프로그램을 개발할 수 있다.
- JVM의 기능
    - 자바 프로그램이 어느 OS나 실행될 수 있도록 한다.
    - 프로그램 메모리를 관리, 최적화 하는 GC.
- **고수준**의 프로그래밍 언어
    - 자연어처럼 고급 언어이기 때문에, 영어 문법과 비슷해서 기억하기 쉽다.
- **대량의 커뮤니티**지원
    - 오랫동안 사용된 만큼 큰 개발자 커뮤니티들이 존재.

## 단점

- 수행 속도가 느리다.
    - 실행을 위해 JVM을 거쳐야 하므로, 다른 언어에 비해 실행 속도가 느리다.
- 백업
    - 자바는 주로 데이터 저장에 중점을 두고, 데이터를 백업하는 기능이 없다.
- 많이 필요한 **메모리 공간**
    - C, C++와 같은 언어와 달리 더 많은 메모리를 차지한다.

<br>

# 세션과 쿠키

## 쿠키(Cookie)

클라이언트(로컬)에 저장되는 키와 값이 들어있는 작은 데이터 파일.<br>
필요시 정보를 참조하거나 재사용할 수 있다.

## 세션(Session)

일정 기간 동안 같은 클라이언트로 부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 일정하게 유지시키는 기술.<br>
세션은 쿠키를 기반으로 하지만, 쿠키와 다르게 서버 측에서 저장하고 관리한다.

## 차이

- 쿠키는 클라이언트에 저장되지만, 세션은 서버에 저장된다.
    - 따라서, 쿠키는 서버의 자원을 사용하지 않는다는 이점이 있다.
    - 서버에 요청을 보내는 사용자가 많을 경우 세션은 부하가 심할 수 있다.
- 세션은 쿠키에 세션 ID만 저장하고, 서버에서 세션을 처리하기 때문에 비교적 보안이 좋다.
- 쿠키는 만료시간 동안 파일로 저장되므로 브라우저를 종료해도 정보가 남아있지만, 세션은 브라우저가 종료되면 만료시간에 상관없이 삭제된다.