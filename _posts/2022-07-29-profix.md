---
layout: single
title:  "후위 표기식"
categories: BOJ, Class4
tag: [자료 구조, 스택]
toc: true
author_profile: false
sidebar: 
    nav: "docs"
---

# 1918, 후위 표기식

## 최초 접근법

처음에 바로 스택을  사용할 것이라고 예상하고 접근하였다. 여기까진 좋았다. 

하지만, 괄호와 각 연산자마다 우선순위를 적용하기가 쉽지 않았다. 여기서 많이 헤메다가 결국 정답을 조금 참고하여 풀었다. 

## 코드

```python
question = input()
calculation = {"/": 2, "*": 2, "+": 1, "-": 1, "(": 0}
stack = []

for s in question: # 하나씩 입력받는다.
    if s.isalpha(): # 문자가 나온다면 바로 그냥 출력해준다.
        print(s, end='')
    elif s == "(": # 여는 괄호가 나오면 스택에 넣어준다.
        stack.append(s)
    elif s == ')': # 닫는 괄호가 나온다면 스택에서 여는괄호가 나올때까지 연산자들을 pop해준다.
        while True:
            cur_oper = stack.pop()
            if cur_oper == "(":
                break
            print(cur_oper, end='')
    else:
        # 연산자가 나온다면 더 우선순위가 높은 연산자가 나올때까지 연잔자를 pop해준다.
        while stack and calculation[stack[-1]] >= calculation[s]:
            print(stack.pop(), end='')
        stack.append(s)

while stack:
    print(stack.pop(), end="")
```

## 설명

- 연산자마다 우선순위를 정한다. 우선순위를 정하는 방법으로는 dictionary를 이용하여 연산자를 key, 우선순위를 value로 지정하였다. value의 숫자가 클수록 우선순위가 높은 것이다. 

사칙연산은 곱하기와 나누기의 우선순위가 더 높게 설정하였다. 

괄호의 경우에는  value를 0으로 설정하였다. 왜냐하면 여는 괄호 이후의 모든 연산이 다른 것 보다 우선시 되기 때문에 이후의 연산자가 바로 들어올 수 있도록 하기 위해서이다. 

1. 입력 문자열을 하나씩 입력받는다. 

2. 문자가 나온다면 바로 출력해준다. 

3. 여는 괄호가 나오면 스택에 넣어준다. 

4. 닫는 괄호가 나온다면 스택에서 여는 괄호가 나올때까지 연산자들을 pop하여 출력해준다. 

5. 그 외에 연산자들이 나온다면 

- 스택이 비어있지 않고, 더 우선순위가 큰 연산자가 나올때까지 stack에서 pop하여 출력해준다. 

- while문이 끝나거나 조건에 해당되지 않으면 스택에 넣어준다.

6. 스택에 쌓여있는 연산자들을 위에서부터 하나씩 pop하여 출력해준다. 

![KakaoTalk_20220729_180704153](../../images/2022-07-29-profix/KakaoTalk_20220729_180704153.jpg)

이렇게 접근할 수 있는 이유는 다음과 같다. 

- 괄호 안의 연산이 가장 우선시 된다. 

- 우선시되는 연산자들 먼저 연산한다. 

- 문자열 뒤에 연산자를 붙인다.

- 우선순위가 높은 순서대로 스택에 쌓아준다면 나중에 pop할때 자연스럽게 우선순위대로 빠져나오게 된다. 

- 다만 우선순위가 낮은 것이 먼저 나온다면 높은 연산자를 그때 바로 pop하여 출력해주면 우선적으로 연산이 된다. 

## 요점 및 배운점

- 스택 자료구조를 활용하는 기본적인 문제라고 생각한다. 아직 스택에 대한 이해가 부족한 것 같다. 문자열을 처리하는 문제들을 많이 다뤄보고 더 익숙해져야할 것 같다. 

- 우선순위를 dictionary로 저장하여 key로 연산자를 지정하니 우선순위 비교하기가 편했다. 원래 처음에는 조건문으로 우선순위를 비교하도록 접근하였다. 가독성도 떨어지고 비효율적인 접근이었다. 
