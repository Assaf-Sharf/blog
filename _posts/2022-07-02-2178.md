---
layout: single
title:  "[백준]2178번: 미로 탐색"
categories: baekjoon
tag: [python, class_2, algolithm, silver, brute force]
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

# 미로 탐색

solved_ac[Class2] [미로 탐색](https://www.acmicpc.net/problem/2178)

## 문제

N×M크기의 배열로 표현되는 미로가 있다.

![image](https://user-images.githubusercontent.com/95459089/177005791-a20708af-de21-4e16-b644-4ef6976906c6.png)

미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.

위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.

## 입력

첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 **붙어서** 입력으로 주어진다.


## 출력

첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.

## 예제 입력 1 

```
4 6
101111
101010
101011
111011
```

## 예제 출력 1 

```
15
```

## 예제 입력 2 

```
4 6
110110
110110
111111
111101
```

## 예제 출력 2 

```
9
```

## 예제 입력 3

```
2 25
1011101110111011101110111
1110111011101110111011101
```

## 예제 출력 3

```
38
```

## 예제 입력 4

```
7 7
1011111
1110001
1000001
1000001
1000001
1000001
1111111
```

## 예제 출력 4

```
13
```


# 문제 해석

범위가 256층까지이기 때문에 브루트 포스로 풀면 된다. 0층부터 훑으면서 올라가기 때문에 같은 시간이 걸리는 경우가 생겨도 가장 높은 층을 고를 수 있게 된다. 최소 시간 값을 계산 할 때 부등호를 작거나 같다 라고 설정을 해주면 같은 시간이 걸려도 높은 층으로 업데이트가 된다.


# 풀이

- 256번의 루프를 돈다.
    - 깎을 때에는 2초가 들고, 붙일때에는 1초가 들기 때문에 각자 다른 변수를 설정해준다.
    - N x M 행렬을 다 검사를 한다.
        - 만약 검사 층이 현재 층보다 낮다면?
            - 검사 층과 현재 층의 차이만큼 깎아야 하기 때문에 두 수의 차 만큼 max_tg 값에 더해준다.
        - 검사 층이 현재 층보다 높다면?
            - 붙여야 하기 때문에 min_tg 값을 업데이트 시켜준다.
    - 깎는 것(max_tg)을 하면 블록이 생겨서 인벤토리(B)에 더해주고, 붙이는 것(min_tg)를 하면 블록을 더해줘야해서 인벤토리(B)에서 한개를 빼준다. 그래서 만약 현재 인벤토리(B)에 가지고 있는 블록에 깎아서(max_tg) 생긴 블록들을 더해준 것이, 붙여서(min_tg) 없어진 블록들보다 많다면?
        - 깎는 것(max_tg)은 2초가 걸리고 붙이는 것(min_tg)는 1초가 걸리기 떄문에 연산을 해주고 시간(time_cnt)에 더해준다.
        - 만약 최소값(ans)으로 저장되어 있는 값보다 시간(time_cnt)이 작다면?
            - 최소값(ans)을 걸린 시간(time_cnt)로 업데이트 해주고, 해당 높이(height)는 현재 층수(i)로 업데이트 시켜준다.

- 인벤토리에 깎아진 것을 더해준 블록을 더해준 것이 붙여서 없어진 블록의 갯수보다 적다면 해당 층수에서는 고르게 땅을 만들 수 없다는 것이기 때문에 skip한다. 

```python
import sys

N, M, B = map(int, sys.stdin.readline().split())

graph = []

for i in range(N):
    graph.append(list(map(int, sys.stdin.readline().split())))

time_cnt = 0

ans = sys.maxsize
height = 0

for i in range(257):
    max_tg = 0
    min_tg = 0
    for j in range(N):
        for k in range(M):
            # 깎기
            if graph[j][k] >= i:
                max_tg += graph[j][k] - i
                
            # 붙이기   
            else:
                min_tg += i - graph[j][k]            
        
    if B + max_tg >= min_tg:
        time_cnt = max_tg * 2 + min_tg
        if ans >= time_cnt:
            ans = time_cnt
            height = i
             
print(ans, height)

```

# 반성

범위가 256밖에 안되서 브루트 포스로 풀 것이라는 것은 알고 있었다. 그런데 코드를 짜면서 많은 실수를 저질렀는데 그 중 하나가 문제에서 주어진 시간이 같다면 가장 높은 층 수를 출력하라 라는 말을 간과했다. 맨 마지막 줄쯤에서 최소값을 업데이트 해주는 코드의 부등호를 

```python
if B + max_tg >= min_tg:
    time_cnt = max_tg * 2 + min_tg
    if ans > time_cnt:
        ans = time_cnt
        height = i
```

이 코드로 내어서 계속 틀렸습니다가 떴다. 이렇게 실행을 하게 되면 같은 값이 나왔을 때 가장 높은 층 수를 출력하지 못하고 가장 먼저 나온 시간이 답이 된다. 그러니깐 같은 값 중에 가장 낮은 층 수가 답이 된다는 것이다. 이것이 첫번째 원인이였고, 입력받은 B값을 건들지 말고 max_tg와 min_tg라는 변수를 따로 선언해서 풀어나가야 하는데 나는 B값을 계속해서 건들면서 연산을 해서 시간초과와 틀렸습니다가 계속 떳다. 앞으로 문제 풀 때 문제를 자세히 읽어보고 조건들을 깊게 생각하면서 적당한 변수를 사용하는 식으로 코딩을 해야겠다 라고 깨닳았다.
