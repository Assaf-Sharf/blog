---
published: true
layout: single
title: "[C++] decltype, std::declval"
category: cppreference
tags:
comments: true
sidebar:
  nav: "mainMenu"
--- 
* * *
#### decltype
* * *
- decltype 에 전달된 식이 괄호로 둘러쌓이지 않은 식별자 표현식(id-expression) 이라면 해당 식의 타입을 얻을 수 있음.
(식별자 표현식은 쉽게 생각하면 어떠한 연산을 하지 않고 단순히 객체 하나만을 가리키는 식)
- decltype 에 식별자 표현식이 아닌 식을 전달하면 아래와 같이 동작함  
  - 만일 식의 값 종류가 xvalue 라면 decltype 는 T&&  
  - 만일 식의 값 종류가 lvalue 라면 decltype 는 T&  
  - 만일 식의 값 종류가 prvalue 라면 decltype 는 T  

아래와 같은 상황에서 result에 대한 type을 명시할 수 없습니다. result의 type은 T와 U에 의해 정해지니까요.

```c++
template <typename T, typename U>
void add(T t, U u, /* 무슨 타입이 와야 할까요? */ result) {
  *result = t + u;
}
```

이 경우 decltype을 사용할 수 있습니다.
```
template <typename T, typename U>
void add(T t, U u, decltype(t + u)* result) {
  *result = t + u;
}
```

#### tailing return & decltype
* * * 
아래와 같은 코드가 있다고 할 때, T와 U의 타입을 decltype 호출 시 유추할 수 없습니다.

template <typename T, typename U>
decltype(t + u) add(T t, U u) {
  return t + u;
}

그래서 아래와 같이 tailing return을 사용하는 문법이 추가 되었습니다.
```c++
template <typename T, typename U>
auto add(T t, U u) -> decltype(t + u) {
  return t + u;
}
```

#### std::declval
* * *

#### Reference 
***  
- ***<https://modoocode.com/294>***