---
layout: single
title:  "[DATABASE] SQL문 기초"
categories: SQL,DATABASE
tag: SQL,DATABASE
author_profile: false
---


sql 기초 select,insert,update,delete,join,index

## 전체 데이터베이스 구성도
![image description](/assets/images/Database.png)<br>

<br>
<br>

## GROUP BY
GROUP BY 절은 말 말그대로 그룹으로 묶어주는 역활은 한다. 

* GROUP BY 사용이유

* <span style="background-color:#fff5b1"> GROUP 사용 전 </span><br>

```sql
SELECT mem_id, amount FROM buy ORDER BY mem_id;
```
회원 아이디와 구매 개수를 출력하는 쿼리문<br>


![image description](/assets/images/data.png)<br>

APN(에이핑크) 회원의 경우에는 1+2+1+1=5개의 물건을 구매했다. 그러나 합계를 이렇게 암산이나 계산기로 계산해야 한다면 MySQL을 사용할 이유가 없다.

* <span style="background-color:#fff5b1"> GROUP 사용 후  </span><br>

```sql
SELECT mem_id "회원 아이디", SUM(amount) "총구매 개수"
FROM buy
GROUP by mem_id;
```
각회원(mem_id)별로 구매한 개수(amount)를 합쳐서 출력하기 위해서는 집게 함수인 SUM()과 GROUP BY 절을 사용함.GROUP BY로 회원별로 묶어준 후에 SUM() 함수로 구매한 개수를 합치면 된다. 집게 함수는 주로 GROUP BY 절과 함께 쓰이며 데이터를 그룹화 해주는 기능을 제공한다.

![image description](/assets/images/data1.png)<br>

다음과 같이 총 구매개수가 5개 인것을 확인할수있다.


## 데이터 조회:SELECT
```sql
-- 데이터 조회 
SELECT 열이름 
FROM 테이블명
[WHERE]조건식
[GROUP BY 속성 HAVING 조건] --GROUP BY 이에 조건문을 쓸떄는 HAVING 을써야함 WHERE 불가능
[ORDER BY 속성 [ASC}DESC]]; --ASC: 오름차순,DESC:내림차순
PREDICATE: ALL, DISTINCT(중복제거), DISTINCTROW(튜플 전체 대상으로 중복 제거)
연산자: = <> < LIKE(문자열비교)(%문자열, _문자, #숫자), NOT, AND


-- 집게 함수(GROUP BY와 함꼐 주로 사용되는 집게 함수)
- SUM(),AVG(),MIN(),MAX(),COUNT()
ex)집게함수를 사용하여 회원이 구매한 총합
SELECT mem_id "회원 아이디", SUM(price*amount) "총구매 금액"
FROM buy
group by mem_id;

```
<br>
<br>



## 데이터 입력:INSERT

```sql
-- 데이터 입력
insert into 테이블 
    [(열1,열2)] values (값1,값2)


* 예제코드
create table honggong1(
    toy_id INT, 
    toy_name varchar(4),
    age int
)

INSERT INTO hongong1 VALUES(1,'우디',25);  //데이터 3개 값이 똑같이 들어갈떄는 열 생략가능

INSERT INTO hongng1(toy_id,toy_name) VALUES(2,'버즈'); // 데이터 2개값만 넣는다 하면 직접 열 이름 써야한다.


CREATE TABLE hongong2(
toy_id INT AUTO_INCREMENT PRIMARY KEY, /* AUTO_INTCREMENT 는 기본키(PRIMARY KEY) 로 지정해줘야한다.*/
toy_name CHAR(4),
age INT);

INSERT INTO hongong2 VALUES (NULL, '보핍',25);
INSERT INTO hongong2 VALUES (NULL, '슬링키',22);
INSERT INTO hongong2 VALUES (NULL, '렉스',21);

ALTER TABLE hongong2 AUTO_INCREMENT= 100; //alter로 오토인크리먼트 100부터 시작하게 설정함.

CREATE TABLE hongong3(
toy_id INT auto_increment primary key,
toy_name char(4),
age int);
alter table hongong3 auto_increment = 1000; 
set @@auto_increment_increment=3;  /*1003 1006 건너뛰는 숫자 3씩 증가*/

```

## 데이터 수정:UPDATE 

```sql
-- 데이터 수정
UPDATE 테이블 이름
    SET 열1 = 값1, 열2 = 값2    --set 하고 바꾸는 열 = 새로 바뀌는 값
    WHERE 조건;                --where 어떤 컬럼하고 바꿀지 명시


* 예제코드 
create table city_popul(
city_name char(35) ,
population int);

insert into city_popul
	select name, population from world.city;
    
update city_popul
    set city_name = '서울'       -- 영어떄기 도시네임 컬럼 seoul을 - >  한글 서울로 바꿔라.
    where city_name = 'seoul' ;


update city_popul
	set city_name = '뉴욕' , population = 0 
    where city_name = 'New York' ;

```

## 데이터 삭제:DELETE

```sql
DELETE FROM 테이블이름 WHERE 조건;
    
    *예제코드
delete from city_popul
     where city_name like = 'New%'   --city_popul 테이블에 city_name 컬럼에 값이 앞에 new로 시작하는것을 삭제해라. 
```

## MySQL데이터 타입

```sql
create table hongong4(
	tinyint_col tinyint,
    smallint_col smallint,
    int_col int,
    bigint_col bigint);
    
insert into hongong4 values(127,32767,2147483647,90000000000000000);

insert into hongong4 values(127,32768,2147483648,90000000000000000);  /* 최대값 넘음*/

/* tinyint unsigned   = > unsigned 키워드를 붙이면 음수는 생략되고 기존 -127 ~ -127 => 0~255 로 데이터를 효율적으로 
사용가능함.*/

-- 대용량 데이터 타입 
create database neflix_db;
use neflix_db;
create table movie(
moive_id int,
movie_title varchar(30),
movie_director varchar(20),
moive_star varchar(20),
movie_script longtext,  -- 자막같은경우 longtxt 데이터 타입
movie_film longblob		-- 파일 
);

```

* CHAR VS VARCHAR 데이터 타입 차이 


![image description](/assets/images/datatype.png)<br>

![image description](/assets/images/datatype2.png)<br>

 
1. 데이터타입 **char(10)으로잡고** '가나다' 3글자를 저장해도 나머지 7에 **공간 낭비가 발생한다**. 하지만 char타입은 mySQL 내부 적으로 **빠른 속도** 면에서는  CHAR 타입으로 설정하는 것이 좋음

2. **varchar(10)** 으로 잡고 '가나다' 3글자를 저장할 경우 **3자리 공간만 사용함**. varchar의 경우 약간에 속도가 떨어짐 
 **글자 크기가 고정**이 된것은 **char** 로 잡으면되고 , **가변적인** 경우 **varchar**로 잡으면된다.

3. ex) addr (경기,서울ㅡ경남 식으로 2글자만 입력받을경우) => 고정적인 char(2) 타입으로 설정한다.

4. ex) mem_name(가수 그룹의 이름인 '잇지' 처럼 2글자도 있지만 '방탄소년단'과 같이 긴글자도 있다, 이러한 가변적인 데이터는 varchar로 잡는게 좋다.
 
5. ex)phone 같은 전화벋호 데이터 타입은 int 타입보다 **char** 타입으로 받는것이 좋다, int 타입으로 받을경우 ex) 010,0794,2301, ->정수형으로 받을경우 **0**이사라진다., 또한 더하기/뺴기 등의 연산에 의미가 업거나 크거나/작다 또는 순서에 의미가 없다면 문자형으로 지정하는것이 좋다.

## JOIN문 (내부조인 ,외부조인)

### 내부 조인 
<span style="background-color:#fff5b1"> 내부조인은 두 개의 테이블을 조인할떄, 두 테이블에 모두 지정한 열의 데이터가 있어야만 함. </span><br>

일대다 관계의 이해 

1. 두 테이블의 조인을 위해서서는 테이블이 일대다(ONE TO MANY) 관계로 연결대야한다. 
2. 데이터베이스의 테이블은 하나로 구성되는 것보다는 여러 정보를 주제에 따라  분리해서 저장되는것이 효율적임.
3. 일대다 관계란 한쪽 테이블에는 하나의 값만 존재해야 하지만, 연결된 다른 테이블에는 여러개의 값이 존재할 수 있는 관계를 말한다.

아래 예제를 보고 조인 이해하기

![image description](/assets/images/join.png)<br>

1. 회원 테이블에서 블랭핑크의 아아디는 'BLK' 1명(one)밖에없다. 그래서 회원 테이블의 아이디를 기본키(PRIMARY KEY)로 지정함.
2. 구매 테이블의 아디이 에서는 3개의 BLK를 찾을수있다, 즉 회원은 1명이지만 이회원을 구매를 여러번 한다(다,many)할수 있는것
3. 그래서 구매 테이블의 아이디는 기본 키가 아닌 외래foregin key 설정.
4. 일대다 곤계는 주로 기본키와 외래키 관계로 맺어있다.
ex ) 회사 테이블 , 급여 테이블 => 한명의 사원이 여러번의 급여를 받으므로 일대 다 관계.
ex ) 학생 테이블 , 학점 테이블 => 한명의 학생이 여러 과목의 학점을 받아야 하므로 일대 다 관계.


```sql
SELECT<열목록>
FROM<첫 번쨰 테이블>
    INNER JOIN <두 번쨰 테이블>
    ON<조인될 조건>
[WHERE 검색 조건]

* 예제코드 
-- 조인(내부조인)
select *
	from buy	
	 inner join member
     on buy.mem_id = member.mem_id
     where buy.mem_id = 'GRL';
     
 select *
	from buy	
	 inner join member
     on buy.mem_id = member.mem_id;

select buy.mem_id, member.mem_name, buy.prod_name , addr, concat(phone1,phone2) as '연락처'
	from buy
    inner join member
    on buy.mem_id = member.mem_id;

-- 위에 코드를 더 간단하게 리팩토링 해보자 (별명주기)
select B.mem_id, M.mem_name, B.prod_name, M.addr, concat(M.phone1, M.phone2) AS '연락처'
		from buy B
        inner join member M 
        on B.mem_id = M.mem_id;
    
```

![image description](/assets/images/join1.png)<br>

![image description](/assets/images/join2.png)<br>
* 구매 테이블에는 물건을 구매한 회원의 아이디와 물건등의 정보만 있다. 이물건을 배송하기 위해서는 구매한 회원의 주소 및 연락처를 알아야함.
그래서 회원테이블과 + 구매 테이블을 결합한 내부조인.
1. 구매 테이블의 mem_id(buy.mem.id)인 'GRL'을 추출한다
2. 'GRL'과 동일한 값의 회원 테이블의 mem_id(member.mem_id) 열에서 검색한다.
3. 'GRL'이라는 아이디를 찾으면 구매 테이블과 회원 테이블의 두행을 결합(join) 한다.

### 외부 조인
* 외부 조인은 두 테이블을 조인할떄, 1개의 테이블에만 데이터가 있어도 결과가 나옵니다.

```sql

--외부 조인
SELECT<열목록>
FROM<첫 번쨰 테이블(LEFT 테이블)>
    <LEFT | RIGHT | FULL> OUTER JOIN <두 번쨰 테이블(RIGHT 테이블)>
    ON<조인될 조건>
    [WHERE 검색 조건]

* 예제 코드
-- 외부조인
select m.mem_id , m.mem_name, b.prod_name , m.addr 
	from member m    --왼쪽에 있는 회원 테이블 기준으로 외부조인 한다.
		left outer join buy b 
        on m.mem_id = b.mem_id
        order by m.mem_id;
```

* LEFT OUTER JOIN 문의 의미를 왼쪽 테이블 MEMBER 의 내용은 모두 출력되어야 한다는 의미.
즉 내부 조인으로 전체 회원의 구매기록(구매 기록이 없는 회원의 정보도 함꼐)출력을 외부 조인으로 만들어 보자.


![image description](/assets/images/join3.png)<br>

* 구매를 하지않은 고객은 null값이 들어가있는 것을 확인할수있다.
