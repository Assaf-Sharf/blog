---
title: "[Database] SQL 기본문법"
excerpt: "SQL 기본문법을 알아보자"

categories:
  - Database
tags:
  - [tag1, tag2]

permalink: /database/sql1/

toc: true
toc_sticky: true

date: 2024-01-12
last_modified_at: 2022-07-24
---



sql 기초 select,insert,update,delete,join,index

## 전체 데이터베이스 구성도
![image description](/assets/images/Database.png)<br>

<br>
<br>

## GROUP BY
GROUP BY 절은 말 말그대로 그룹으로 묶어주는 역활은 한다. 

* GROUP BY 사용이유

* <span style="background-color:#fff5b1"> GROUP 사용 전 </span><br>

```sql
SELECT mem_id, amount FROM buy ORDER BY mem_id;
```
회원 아이디와 구매 개수를 출력하는 쿼리문<br>


![image description](/assets/images/data.png)<br>

APN(에이핑크) 회원의 경우에는 1+2+1+1=5개의 물건을 구매했다. 그러나 합계를 이렇게 암산이나 계산기로 계산해야 한다면 MySQL을 사용할 이유가 없다.

* <span style="background-color:#fff5b1"> GROUP 사용 후  </span><br>

```sql
SELECT mem_id "회원 아이디", SUM(amount) "총구매 개수"
FROM buy
GROUP by mem_id;
```
각회원(mem_id)별로 구매한 개수(amount)를 합쳐서 출력하기 위해서는 집게 함수인 SUM()과 GROUP BY 절을 사용함.GROUP BY로 회원별로 묶어준 후에 SUM() 함수로 구매한 개수를 합치면 된다. 집게 함수는 주로 GROUP BY 절과 함께 쓰이며 데이터를 그룹화 해주는 기능을 제공한다.

![image description](/assets/images/data1.png)<br>

다음과 같이 총 구매개수가 5개 인것을 확인할수있다.


## 데이터 조회:SELECT
```sql
-- 데이터 조회 
SELECT 열이름 
FROM 테이블명
[WHERE]조건식
[GROUP BY 속성 HAVING 조건] --GROUP BY 이에 조건문을 쓸떄는 HAVING 을써야함 WHERE 불가능
[ORDER BY 속성 [ASC}DESC]]; --ASC: 오름차순,DESC:내림차순
PREDICATE: ALL, DISTINCT(중복제거), DISTINCTROW(튜플 전체 대상으로 중복 제거)
연산자: = <> < LIKE(문자열비교)(%문자열, _문자, #숫자), NOT, AND


-- 집게 함수(GROUP BY와 함꼐 주로 사용되는 집게 함수)
- SUM(),AVG(),MIN(),MAX(),COUNT()
ex)집게함수를 사용하여 회원이 구매한 총합
SELECT mem_id "회원 아이디", SUM(price*amount) "총구매 금액"
FROM buy
group by mem_id;

```
<br>
<br>



## 데이터 입력:INSERT

```sql
-- 데이터 입력
insert into 테이블 
    [(열1,열2)] values (값1,값2)


* 예제코드
create table honggong1(
    toy_id INT, 
    toy_name varchar(4),
    age int
)

INSERT INTO hongong1 VALUES(1,'우디',25);  //데이터 3개 값이 똑같이 들어갈떄는 열 생략가능

INSERT INTO hongng1(toy_id,toy_name) VALUES(2,'버즈'); // 데이터 2개값만 넣는다 하면 직접 열 이름 써야한다.


CREATE TABLE hongong2(
toy_id INT AUTO_INCREMENT PRIMARY KEY, /* AUTO_INTCREMENT 는 기본키(PRIMARY KEY) 로 지정해줘야한다.*/
toy_name CHAR(4),
age INT);

INSERT INTO hongong2 VALUES (NULL, '보핍',25);
INSERT INTO hongong2 VALUES (NULL, '슬링키',22);
INSERT INTO hongong2 VALUES (NULL, '렉스',21);

ALTER TABLE hongong2 AUTO_INCREMENT= 100; //alter로 오토인크리먼트 100부터 시작하게 설정함.

CREATE TABLE hongong3(
toy_id INT auto_increment primary key,
toy_name char(4),
age int);
alter table hongong3 auto_increment = 1000; 
set @@auto_increment_increment=3;  /*1003 1006 건너뛰는 숫자 3씩 증가*/

```

## 데이터 수정:UPDATE 

```sql
-- 데이터 수정
UPDATE 테이블 이름
    SET 열1 = 값1, 열2 = 값2    --set 하고 바꾸는 열 = 새로 바뀌는 값
    WHERE 조건;                --where 어떤 컬럼하고 바꿀지 명시


* 예제코드 
create table city_popul(
city_name char(35) ,
population int);

insert into city_popul
	select name, population from world.city;
    
update city_popul
    set city_name = '서울'       -- 영어떄기 도시네임 컬럼 seoul을 - >  한글 서울로 바꿔라.
    where city_name = 'seoul' ;


update city_popul
	set city_name = '뉴욕' , population = 0 
    where city_name = 'New York' ;

```

## 데이터 삭제:DELETE

```sql
DELETE FROM 테이블이름 WHERE 조건;
    
    *예제코드
delete from city_popul
     where city_name like = 'New%'   --city_popul 테이블에 city_name 컬럼에 값이 앞에 new로 시작하는것을 삭제해라. 
```

## MySQL데이터 타입

```sql
create table hongong4(
	tinyint_col tinyint,
    smallint_col smallint,
    int_col int,
    bigint_col bigint);
    
insert into hongong4 values(127,32767,2147483647,90000000000000000);

insert into hongong4 values(127,32768,2147483648,90000000000000000);  /* 최대값 넘음*/

/* tinyint unsigned   = > unsigned 키워드를 붙이면 음수는 생략되고 기존 -127 ~ -127 => 0~255 로 데이터를 효율적으로 
사용가능함.*/

-- 대용량 데이터 타입 
create database neflix_db;
use neflix_db;
create table movie(
moive_id int,
movie_title varchar(30),
movie_director varchar(20),
moive_star varchar(20),
movie_script longtext,  -- 자막같은경우 longtxt 데이터 타입
movie_film longblob		-- 파일 
);

```

* CHAR VS VARCHAR 데이터 타입 차이 


![image description](/assets/images/datatype.png)<br>

![image description](/assets/images/datatype2.png)<br>

 
1. 데이터타입 **char(10)으로잡고** '가나다' 3글자를 저장해도 나머지 7에 **공간 낭비가 발생한다**. 하지만 char타입은 mySQL 내부 적으로 **빠른 속도** 면에서는  CHAR 타입으로 설정하는 것이 좋음

2. **varchar(10)** 으로 잡고 '가나다' 3글자를 저장할 경우 **3자리 공간만 사용함**. varchar의 경우 약간에 속도가 떨어짐 
 **글자 크기가 고정**이 된것은 **char** 로 잡으면되고 , **가변적인** 경우 **varchar**로 잡으면된다.

3. ex) addr (경기,서울ㅡ경남 식으로 2글자만 입력받을경우) => 고정적인 char(2) 타입으로 설정한다.

4. ex) mem_name(가수 그룹의 이름인 '잇지' 처럼 2글자도 있지만 '방탄소년단'과 같이 긴글자도 있다, 이러한 가변적인 데이터는 varchar로 잡는게 좋다.
 
5. ex)phone 같은 전화벋호 데이터 타입은 int 타입보다 **char** 타입으로 받는것이 좋다, int 타입으로 받을경우 ex) 010,0794,2301, ->정수형으로 받을경우 **0**이사라진다., 또한 더하기/뺴기 등의 연산에 의미가 업거나 크거나/작다 또는 순서에 의미가 없다면 문자형으로 지정하는것이 좋다.

6. tinyint unsigned  = > unsigned 키워드를 붙이면 음수는 생략되고 기존 -127 ~ -127 => 0~255 로 데이터를 효율적으로 사용가능하다.


## JOIN문 (내부조인 ,외부조인)

### 내부 조인 
<span style="background-color:#fff5b1"> 내부조인은 두 개의 테이블을 조인할떄, 두 테이블에 모두 지정한 열의 데이터가 있어야만 함. </span><br>

일대다 관계의 이해 

1. 두 테이블의 조인을 위해서서는 테이블이 일대다(ONE TO MANY) 관계로 연결대야한다. 
2. 데이터베이스의 테이블은 하나로 구성되는 것보다는 여러 정보를 주제에 따라  분리해서 저장되는것이 효율적임.
3. 일대다 관계란 한쪽 테이블에는 하나의 값만 존재해야 하지만, 연결된 다른 테이블에는 여러개의 값이 존재할 수 있는 관계를 말한다.

아래 예제를 보고 조인 이해하기

![image description](/assets/images/join.png)<br>

1. 회원 테이블에서 블랭핑크의 아아디는 'BLK' 1명(one)밖에없다. 그래서 회원 테이블의 아이디를 기본키(PRIMARY KEY)로 지정함.
2. 구매 테이블의 아디이 에서는 3개의 BLK를 찾을수있다, 즉 회원은 1명이지만 이회원을 구매를 여러번 한다(다,many)할수 있는것
3. 그래서 구매 테이블의 아이디는 기본 키가 아닌 외래foregin key 설정.
4. 일대다 곤계는 주로 기본키와 외래키 관계로 맺어있다.
ex ) 회사 테이블 , 급여 테이블 => 한명의 사원이 여러번의 급여를 받으므로 일대 다 관계.
ex ) 학생 테이블 , 학점 테이블 => 한명의 학생이 여러 과목의 학점을 받아야 하므로 일대 다 관계.


```sql
SELECT<열목록>
FROM<첫 번쨰 테이블>
    INNER JOIN <두 번쨰 테이블>
    ON<조인될 조건>
[WHERE 검색 조건]

* 예제코드 
-- 조인(내부조인)
select *
	from buy	
	 inner join member
     on buy.mem_id = member.mem_id
     where buy.mem_id = 'GRL';
     
 select *
	from buy	
	 inner join member
     on buy.mem_id = member.mem_id;

select buy.mem_id, member.mem_name, buy.prod_name , addr, concat(phone1,phone2) as '연락처'
	from buy
    inner join member
    on buy.mem_id = member.mem_id;

-- 위에 코드를 더 간단하게 리팩토링 해보자 (별명주기)
select B.mem_id, M.mem_name, B.prod_name, M.addr, concat(M.phone1, M.phone2) AS '연락처'
		from buy B
        inner join member M 
        on B.mem_id = M.mem_id;
    
```

![image description](/assets/images/join1.png)<br>

![image description](/assets/images/join2.png)<br>
* 구매 테이블에는 물건을 구매한 회원의 아이디와 물건등의 정보만 있다. 이물건을 배송하기 위해서는 구매한 회원의 주소 및 연락처를 알아야함.
그래서 회원테이블과 + 구매 테이블을 결합한 내부조인.
1. 구매 테이블의 mem_id(buy.mem.id)인 'GRL'을 추출한다
2. 'GRL'과 동일한 값의 회원 테이블의 mem_id(member.mem_id) 열에서 검색한다.
3. 'GRL'이라는 아이디를 찾으면 구매 테이블과 회원 테이블의 두행을 결합(join) 한다.

### 외부 조인
* 외부 조인은 두 테이블을 조인할떄, 1개의 테이블에만 데이터가 있어도 결과가 나옵니다.

```sql

--외부 조인
SELECT<열목록>
FROM<첫 번쨰 테이블(LEFT 테이블)>
    <LEFT | RIGHT | FULL> OUTER JOIN <두 번쨰 테이블(RIGHT 테이블)>
    ON<조인될 조건>
    [WHERE 검색 조건]

* 예제 코드
-- 외부조인
select m.mem_id , m.mem_name, b.prod_name , m.addr 
	from member m    --왼쪽에 있는 회원 테이블 기준으로 외부조인 한다.
		left outer join buy b 
        on m.mem_id = b.mem_id
        order by m.mem_id;
```

* LEFT OUTER JOIN 문의 의미를 왼쪽 테이블 MEMBER 의 내용은 모두 출력되어야 한다는 의미.
즉 내부 조인으로 전체 회원의 구매기록(구매 기록이 없는 회원의 정보도 함꼐)출력을 외부 조인으로 만들어 보자.


![image description](/assets/images/join3.png)<br>

* 구매를 하지않은 고객은 null값이 들어가있는 것을 확인할수있다.


## 제약 조건 CONSTRAINT
* 제약조건(Constraint)은 데이터의 무결성을 지키기 위해 제한하는 조건이다. 데이터 무결성 = > 데이터에 결함이없음을뜻함.
아아디,이메일등등 제약조건을 줘서 중복되는 결함을 없애는 것을 바로 데이터의 무결성이라고 한다.

### 기본키 PRIMARY KEY 제약조건 

```sql
create table member(
mem_id char(8) primary key, 
mem_name varchar(10) not null,
height tinyint unsigned null
);

```

1. 값이 중복될수없음 
2. NULL 값이 입력될수 없음
3. 기본 키로 지정한 것은 자동으로 클러스터형 인덱스가 생선된다.
4. 한 테이블은 기본 키를 1개만 갖는다. 

### 외래키 FOREIGN KEY 제약조건


```sql
create table member(
mem_id char(8) primary key, 
mem_name varchar(10) not null,
height tinyint unsigned null
);

create table buy(
num int auto_increment not null primary key,
mem_id char(8) not null,
prod_name char(6) not null
foreign key(mem_id) references member (mem_id)


alter table buy              --- ALTER TALBE 에서 설정하는 외래키(이렇게도 추가가능)
    add constraint 
    foreign key(mem_id)
    references member(mem_id)

);
```

* 외래키 제약조건은 두테이블 사이의 관계를 연결해주고 , 그결과 데이터의 무결성을 보장해주는 역활을한다. 왜래 키가 설정된 열은 꼭 다른 테이블의  **기본 키와** 연결된다. (**기본키가 있는 테이블을 => 기준 테이블** , **외래 키가 있는 테이블을 참조 테이블 이라고 부른다**)

* 참조 테이블이 참조하는 기준 테이블의 열은 반드시 기본키나 고유키 Unique 키로 설정되어있어야함.

### ON UPDATE CASCADE 

* 회원 테이블의 BLK가 물품을 2건 구매한 상태에서 회원 아이디를 PINK로 변경할 경우 어떻게 될까?

![image description](/assets/images/alter.png)<br>


```sql
update member set mem_id ='pink' where mem_id = 'BLK';  ---오류 발생
```

오류메세지:Cannot add or update a parent row: a foreign key constraint fails 

기본키 - 외래키로 맺어진 후에는 기준 테이블의 열 이름이 변경되지 않는다. 열 이름이 변경되면 참조 테이블의 문제가 발생하기떄문이다.

```sql
delete from member where mem_id = 'BLK';
```

삭제도 같은 오류로 삭제되지않는다.



![image description](/assets/images/alter2.png)<br>

* 사진과 같이 기존 테이블의 열 이름이 변경될 떄 참조 테이블의 열 이름이 자동으로 변경되게 해보자

```sql
create table buy(
num int auto_increment not null primary key,
mem_id char(8) not null,
prod_name char(6) not null
);

alter table buy 
	add constraint 
    foreign key(mem_id) references member(mem_id)
    on update cascade
    on delete cascade;
```
 **on update cascade , on delete cascade 제약조건에 추가해주면** 기준 테이블 데이터가 수정되거나 삭제되면 그 참조되는 테이블도 똑같이 수정되거나 삭제된다. 

 ### 고유키 UNIQUE 제약조건

* 고유키 제약조건은 중복되지 않는 유일한 값을 입력해야한다. 기본키랑 비슷하지만 차이점은  고유키는 NULL을 허용함 대신 중복은 허용불가.
* 고유키는 여러 개를 설정해두 된다.

``` sql
--고유키 
create table member(
mem_id char(8) not null primary key,
mem_name varchar(10) not null,
height tinyint unsigned null,
email char(30) null unique  -- 고유키 null은허용하나 중복은 안됌.
);

insert into member values('BLK','블랙핑크', 168,'ping@gmail.com');
insert into member values('TWC','트와이스',163,null);
insert into member values('APN','에이핑크', 164,'ping@gmail.com'); -- 에러발생 닉네임 BLK랑  이메일 중복발생
```

### 체크 CHECK 제약조건
* 체크 제약 조건은 입력되는 데이터를 점검하는 기능을한다. 

```sql
-- check(조건) 체크 제약조건
drop table member;

create table member(
mem_id char(8) not null primary key,
mem_name varchar(10) not null,
height tinyint unsigned null check (height >= 100),
phone1 char(3) null
);

insert into member values('BLK','블랙핑크',163,NULL);
insert into member values('BLK','블랙핑크',99,NULL); -- height 체크 제약조건 100이상을 걸었기떄문에 오류

alter table member
	add constraint
    check (phone1 in ('02','031','032','054','005','061')); 
    
insert into member values('TWC','트와이스',163,'02');
insert into member values('OMY','오마이걸',167,'010'); -- 에러: 체크 조건 위반

```

1. height 체크 제약조건을 걸음 -> 평균 키는 반드시 100 이상의 값만 입력되도록 설정해놈. 99 값이 들어오면 에러발생 .

### 기본값 default 

```sql
-- 기본값 정의 (default)
drop table member;
create table member(
mem_id char(8) not null primary key,
mem_name varchar(10) not null,
height tinyint unsigned null default 160,   --default 설정 160
phone1 char(3) null
);

alter table member
	alter column phone1 set default '02';
    
insert into member values('RED','레드벨벳',161,'054');
insert into member values('SPC','우주소녀',default,default);
select * from member; 
```

1. height 에 기본값을 160 으로 정의했다. 사용자가 아무 값을 입력하지  않으면 기본값으로 160 이 설정되는 제약조건이다.

<br>
<br>
<br>

## 뷰 VIEW

* <span style="background-color:#fff5b1"> view는 데이터베이스의 select 문을 저장한 오브젝트 라고 할수 있고, query문에서 테이블처럼 쓰인다.
</span><br>
### 뷰를 사용하는 이유

1. <span style="background-color:#fff5b1"> **보안에 도움이 된다.**</span> ex) 한 회사에서 쇼핑몰 프로젝로 임직원 할인 혜택을 주는 프로모션을 만들기 위해서는 임직원에 대한 정보 테이블이 필요하다. 하지만
임직원 테이블안에는 많은 보안사항 주민등록번호,핸드폰번호,등등 이러한 데이터 유출을 막기 위해서  요청하는 개발자에게 필요한 정보만을 담은 가상의 view테이블을 생성해서 협업을 한다.
2. <span style="background-color:#fff5b1"> **복잡한 sql을 단순하게 만들수있다.**</span><br>( 내용이 길고 복잡한 쿼리를 자주 사용해 한다면 뷰로 생성해놓고 뷰에만 접근만 하면 sql문이 훨신 간결해진다.) 


```sql

* 뷰 생성 SQL
CREATE VIEW 뷰_이름
AS
    SELECT 문;

* 뷰 예제코드
create view v_member
as 
	select mem_id , mem_name , addr  from member;

select * from v_member;

drop view v_viewtest1; -- 뷰삭제 

```
<br>
<br>
<br>

## 인덱스  Index 
* <span style="background-color:#fff5b1"> 인덱스는 데이터를 빠르게 찾을 수 있도록 도와주는 도구다. </span><br>
* 인덱스에는 클러스터형 인덱스와 보조 인덱스가 있다.

### 인덱스를 사용하는 이유
1. select 문으로 검색하는 속도가 매우 빠름.
2. 그 결과 컴퓨터의 부담이 줄어들면서 결국 전체 시스템의 성능이 향상됨.


### 클러스터형 인덱스 (Clustered Index)
* <span style="background-color:#fff5b1"> 기본키로 지정하면 자동 생성되며 테이블에 1개만 만들수있다. 기본 키로 지정한 열을 기준으로 자동으로 정렬된다 => 영어사전과 비슷한 개념임. A~Z </span><br>

```sql
create table test1 (
    col1 int primary key, -- 기본키로 지정
    col2 int,
    col3 int
);

show index from test1 -- 인덱스 정보 확인
```

![image description](/assets/images/index.png)<br>

1. Key_name 부분을 보면 PRIMARY 라고 써져있는데 이것이 기본 키로 설정해서 자동으로 생성된 인덱스라는 의미. 이것이 바로 클러스텨형 인덱스이다.
2. Non_unique는 인덱스의 값이 중복되어도 된다는뜻. 중복이 허용이 되냐는 뜻. 0은 false , true 1. 결론 -> 이 인덱스는 중복을 허용하지 않는다.

<br>


* <span style="background-color:#FFE6E6"> 기본키를 지정하지 않는 클러스트형 인덱스 예제 </span><br>

```sql
create table member(
    mem_id char(8),
    mem_name varchar(10),
    mem_number int,
    addr char(2)
)

insert into member values('TWC', '트와이스',9,'서울');
insert into member values('BLK', '블랙핑크',4,'경남');
insert into member values('WMN', '여자친구',6,'경기');
insert into member values('OMY', '오마이걸',7,'서울');

```

![image description](/assets/images/index2.png)<br>

1. 결과는 데이터를 입력한 순서 그대로 나옴.

<br>

* <span style="background-color:#FFE6E6"> 기본키를 지정한 클러스트형 인덱스 예제 </span><br>

```sql
alter table member
	add constraint
		primary key(mem_id);
        
select * from member;

```

![image description](/assets/images/index3.png)<br>

1. mem_id 열에 클러스터형 인덱스가 생성되어 mem_id 열을 기준으로 정렬되어있다. 알파벳 순으로 정렬이된다.



<br>
<br>
<br>

### 보조 인덱스 (Secondary Index)
* <span style="background-color:#fff5b1"> 보조 인덱스는 고유 키로 지정하면 자동 생성되며 여러 개를 만들수 있지만 자동 정렬되지는 않는다. => 일반 책의 제일 뒷부분 수록느낌.</span><br>

```sql
create table test2(
    col1 int primary key,
    col2 int unique,  -- 고유키로 지정
    col3 int unique   -- 고유키로 지정
);

show index from test2
```

![image description](/assets/images/index1.png)<br>

1. key_name에 col2,col3이라고 열 이름이 써져있다. key_name에 열 이름이 써 있는 것은 보조 인덱스이다.
2. 고유키를 여러개 지정하듯이 , 보조 인덱스도 여러개 만들수 있다.


