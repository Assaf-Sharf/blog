---
layout: single
title:  "[백준]15686번: 치킨 배달"
categories: baekjoon
tag: [python, class_4, algolithm, gold, floyd-warshall, dp]
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

# 치킨 배달

solved_ac[Class4] [치킨 배달](https://www.acmicpc.net/problem/15686)

## 문제

크기가 N×N인 도시가 있다. 도시는 1×1크기의 칸으로 나누어져 있다. 도시의 각 칸은 빈 칸, 치킨집, 집 중 하나이다. 도시의 칸은 (r, c)와 같은 형태로 나타내고, r행 c열 또는 위에서부터 r번째 칸, 왼쪽에서부터 c번째 칸을 의미한다. r과 c는 1부터 시작한다.

이 도시에 사는 사람들은 치킨을 매우 좋아한다. 따라서, 사람들은 "**치킨 거리**"라는 말을 주로 사용한다. **치킨 거리**는 집과 가장 가까운 치킨집 사이의 거리이다. 즉, 치킨 거리는 집을 기준으로 정해지며, 각각의 집은 **치킨 거리**를 가지고 있다. **도시의 치킨 거리**는 모든 집의 **치킨 거리**의 합이다.

임의의 두 칸 (r1, c1)과 (r2, c2) 사이의 거리는 |r1-r2| + |c1-c2|로 구한다.

예를 들어, 아래와 같은 지도를 갖는 도시를 살펴보자.

0은 빈 칸, 1은 집, 2는 치킨집이다.

(2, 1)에 있는 집과 (1, 2)에 있는 치킨집과의 거리는 |2-1| + |1-2| = 2, (5, 5)에 있는 치킨집과의 거리는 |2-5| + |1-5| = 7이다. 따라서, (2, 1)에 있는 집의 치킨 거리는 2이다.

(5, 4)에 있는 집과 (1, 2)에 있는 치킨집과의 거리는 |5-1| + |4-2| = 6, (5, 5)에 있는 치킨집과의 거리는 |5-5| + |4-5| = 1이다. 따라서, (5, 4)에 있는 집의 치킨 거리는 1이다.

이 도시에 있는 치킨집은 모두 같은 프랜차이즈이다. 프렌차이즈 본사에서는 수익을 증가시키기 위해 일부 치킨집을 폐업시키려고 한다. 오랜 연구 끝에 이 도시에서 가장 수익을 많이 낼 수 있는  치킨집의 개수는 최대 M개라는 사실을 알아내었다.

도시에 있는 치킨집 중에서 최대 M개를 고르고, 나머지 치킨집은 모두 폐업시켜야 한다. 어떻게 고르면, **도시의 치킨 거리**가 가장 작게 될지 구하는 프로그램을 작성하시오.
```
0 2 0 1 0
1 0 1 0 0
0 0 0 0 0
0 0 0 1 1
0 0 0 1 2
```

## 입력

첫째 줄에 N(2 ≤ N ≤ 50)과 M(1 ≤ M ≤ 13)이 주어진다.

둘째 줄부터 N개의 줄에는 도시의 정보가 주어진다.

도시의 정보는 0, 1, 2로 이루어져 있고, 0은 빈 칸, 1은 집, 2는 치킨집을 의미한다. 집의 개수는 2N개를 넘지 않으며, 적어도 1개는 존재한다. 치킨집의 개수는 M보다 크거나 같고, 13보다 작거나 같다.

## 출력

첫째 줄에 폐업시키지 않을 치킨집을 최대 M개를 골랐을 때, 도시의 치킨 거리의 최솟값을 출력한다.

## 예제 입력 1 

```
5 3
0 0 1 0 0
0 0 2 0 1
0 1 2 0 0
0 0 1 0 0
0 0 0 0 2
```

## 예제 출력 1 

```
5
```

## 예제 입력 2

```
5 2
0 2 0 1 0
1 0 1 0 0
0 0 0 0 0
2 0 0 1 1
2 2 0 1 2
```

## 예제 출력 2

```
10
```

## 예제 입력 3 

```
5 1
1 2 0 0 0
1 2 0 0 0
1 2 0 0 0
1 2 0 0 0
1 2 0 0 0
```

## 예제 출력 3 

```
11
```

## 예제 입력 4

```
5 1
1 2 0 2 1
1 2 0 2 1
1 2 0 2 1
1 2 0 2 1
1 2 0 2 1
```

## 예제 출력 4

```
32
```


# 문제 해석

본 문제는 바로 전 풀었던 그래프에 가중치가 있으면서 한 노드가 갈 수 있는 최단 경로가 아닌 여러 노드가 갈 수 있는 최단 경로들을 2차원 배열로 풀어낸 플로이드 워셜 알고리즘을 이용하는 문제이다. [[백준]11404번: 플로이드](https://donghyeok1.github.io/baekjoon/11404/)해당 알고리즘에 대해 자세히 기술해 놨으니 확인해보도록 하자.


# 풀이

- 플로이드 워셜 알고리즘의 기본 코드를 알고 있다면 쉽게 풀 수 있지만 여기서 추가해야할 코드들이 있다.
1. 양방향 통행이 가능하다.
2. 최단 거리를 구해서 끝이 아닌 각 최단거리를 이용해 입력 받은 수색 가능한 거리와 비교하여 수색 가능하다면 해당 노드에 있는 아이템의 개수를 더해주어 max 값을 출력해 내는 형식이다.

- 양방향 통행은 입력을 받을 때 a, b, c로 입력을 받고 graph[a][b] = c와 graph[b][a] = c를 같이 넣어준다면 양방향으로 가능하게 만들어주는 것이다.
- 아이템의 갯수를 따로 item_list라는 리스트에 입력을 받아 놓고 index로 접근을 한다.
- 만약 수색 가능 범위가 4라면 루프를 돌면서 1번 노드가 갈 수 있는 최단 경로 중 4를 넘지 않는 범위들만 골라서 그 곳의 아이템을 더해준다.
- 각 노드마다 가져갈 수 있는 아이템들을 비교하여 max 값을 출력해준다.

```python
import sys

n, m, r = map(int, sys.stdin.readline().split())

INF = float('inf')

item_list = list(map(int, sys.stdin.readline().split()))


graph = [[INF] * (n + 1) for _ in range(n + 1)]

for k in range(r):
    a, b, c = map(int, sys.stdin.readline().split()) 
    graph[a][b] = c
    graph[b][a] = c

for i in range(1, n + 1):
    for j in range(1, n + 1):
        if i == j:
            graph[i][j] = 0
            
for k in range(1, n + 1):
    for i in range(1, n + 1):
        for j in range(1, n + 1):
            graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])
max_sum = 0           
for i in range(1, n + 1):
    sum = 0
    for j in range(1, n + 1):
        if graph[i][j] == float('inf'):
            continue
        if graph[i][j] <= m:
            sum += item_list[j - 1]
    max_sum = max(max_sum, sum)

print(max_sum)
```

# 고찰

바로 전 문제에서 플로이드 워셜 문제를 완벽하게 공부를 해놓았기 때문에 문제를 푸는데 전혀 어려움이 없었다. 그리고 전 포스팅에서 INF 값을 숫자가 아닌 float('inf')로 주는 것을 활용해 봤는데 간편하고 오류가 뜨지 않아서 좋았다.