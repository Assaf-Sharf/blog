---
layout: single
title: "230125_Manger"
categories : concept
tag: ExecutionContext
---

ㅇㅇ



어떤 함수가 실행이 되면 

실행컨텍스트가 열림

그 내부에 있는 정보들을 먼저 수집을 한다.
수집하는 범위는 정의부 or 선언부 까지만 수집을 함 ==> 함수나 변수냐에 따라 수집 정보가 달라짐

정의 : 

## 과정

```js
funjct
```



```
GC(garbage Collector) = 실컨 종료되면 참조되지 않은 변수들 저장
힙 q == 


Tip.
원시형 타입은 이미 주소가 정해져있다고 생각하면 됨

 
```



1. 컨텍스트 내부에 있는 식별 정보들을 수집한다.
2. ㅍ   





### 실행컨텍스트 

 



### 호이스팅

<변수 호이스팅>

let a 또는 const 사용하면
실컨에 저장할 때 초기화를 하고
변수를 참조하면 선언이 되지 않았기 때문에
변수 식별자 까지만 불러오고

var 사용 안되는 이유

1. 실컨에 저장할 때 초기화를 하는데

선언문보다 이전에 참조를 했을 떄 에러가 안남
ㅁㄴㅇㄹ



2. 에러가 안나 찾기 힘듦

<함수 호이스팅>

선언식 함수 == 함수전체가 수집이 된다(var랑 똑같이 먼저 수집)



this 바인딩

function foo(){} // 선언식 => 함수전체수집(var변수와 비슷)

const foo2 = function() {}: //표현식 --> 선언단계까지만

const foo1 = () =>  {} ; // 애로우 => 선언단계까지만



this / callback은보면되는데
closer 부분 이랑 실컨이랑 비슷
JS의 함수는 거의 closer지만
참조되지 않으면 GC대상이 되는데

deep하게 드가면 closer 영원히 참조되는 변수들
도 있는데 그부분도 찾아보면 될 것





## 면접 질문 : 호이스팅은 반환 되나요?

호이스팅은 모든 선언문이 대상이다 키워드에 상관없이

var과 let const 차이 설명

함수 선언문 표현식의 차이 설명

실컨의 함수 내 불변값은 메모리에 할당되고 
함수실행순서 끝나면 스코프에서 벗어난다.
스코프에서 벗어나면 불변값을 제외하고 
모두 사라진다.

