---
Layout: single
title: 이벤트 버블링 제어
---

> ### 버블링이란?
>
> 한 요소에 이벤트가 발생하면, 해당 요소 → 부모 요소 → ... → 최상단의 조상 요소에까지 각각에 할당되었던 핸들러가 동작하는 현상.
>
> 버블링되지 않는 이벤트들이 있긴 하지만, 대부분의 이벤트에서는 버블링 현상이 일어난다.

(✲ 본 포스팅은 이벤트 버블링을 제어한 각각의 케이스를 모아두기 위하여 작성했습니다. 현재는 문제를 이렇게 해결했지만, 나중에 알고 보니 더 좋은 해결책이 있었던 경우를 포함하여 본 포스팅을 계속 수정해나갈 예정입니다.)

## Case 01.

홈페이지상에서 여러가지 필터를 넣고 필터링에 맞게 검색 결과를 출력해주는 기능이 있는데, 필터가 워낙 다양해서 사용자 편의상 한 가지의 필터에서 검색 조건을 선택한 뒤 다른 곳을 클릭하면 자동으로 필터 창이 닫히는 기능을 넣어줘야 했다.

처음에는 단순하게 '해당 필터 박스를 선택해준 뒤 박스를 제외한 다른 곳에서 클릭이 일어나면 필터 박스를 닫으면 되겠거니' 생각했는데 실제로 코드를 짜려고 생각해보니 필터 박스를 먼저 선택해주는게 아니라, 홈페이지에서 일어난 click 이벤트를 일단 listen하고 있다가 필터 박스들의 display가 none이 아닐 때 일어난 클릭에만 반응하도록 처리하는 게 좋을 것 같아서 기본 코드 틀은 그렇게 가기로 했다.

그런데 문제는...필터 박스를 클릭했는데 그 박스를 감싸고 있는 모든 요소에서 event가 일어난 것으로 집계가 되던 것. 버블링이 일어난 것이다.

event.stopPropagation()이나 event.stopImmediatePropagetion()을 사용해야 할까 고민해봤는데, 현재는 나타난 팝업을 사라지게 하기 위해 이벤트가 발생한 맨 안쪽의 요소만 특정하면 되는 상황이었기 때문에 굳이 버블링을 막을 필요는 없지 않나 하는 생각이 들었다. 이에 이벤트 리스너에서 다음과 같은 조건을 추가해주었다.

```javascript
...
	if(event.target === event.currentTarget) {
    ...
  }
```

- 해당 조건은 이벤트가 발생한 가장 안쪽의 요소(event.target)와 현재 실행중인 요소(event.currentTarget, 'this'를 이용하기도 한다)가 같을 때만 이하의 코드가 동작하도록 범위를 좁혀주는 역할을 한다.



