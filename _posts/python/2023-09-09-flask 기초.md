---
title:  "Flask 기초"
excerpt: " Flask 기초공부"

categories:
  - Python
tags:
  - [Python, flask]

toc: true
toc_sticky: true

breadcrumbs: true
 
date: 2023-09-09
last_modified_at: 2023-09-09
---



# 만들기능
메모추가, 수정,삭제,편집,복구
메모이미지 삽입기능
메모 라벨링 기능
메모 페이지네이션
메모검색
각 기능 API작성
API문서자동화
데이터베이스 마이그레이션
동적인페이지만들기


# 학습가능한 flask 기술스택
- flask
    - Application factories
    - Application context
    - Authentication
    - Blueprint
    - Configs
    - Debugging
    - Router
    - Request Hooking
    - Request context
    - Staging 환경별로 staging 하는법
    - Session
    - Serving static files
    - Template engine & rendering
    - Test Clinet
- flask-WTF
    - CSRF 해킹방어
- Flask-restx
    - RESTful API 만들기 위해 restx사용
- Flask-SQLAlchemy
    - ORM 플라스크에서는 orm이 지원안되서 사용함
    : ORM이란 데이터베이스를 쉽게 사용하게 해주는 기능
- Flask-Migrate
    - Database Migration : db관리위해서
- Flask deployment 배포위해서!
    - WSGI
    - nginx
    - docker
    - docker-compose : 도커관리툴
- Flask unittest & TDD
    - pytest

# 구글메모장만들기
- google font
- material desing lite
- material icon
- jquery 3.5.1
- CSSVars
- Masonry

# 배포인프라
- AWS EC2 이용
- AWS RDS 라는 데이터베이스 이용

# 윈도우에서는 WSL2 환경사용.

[WSL2](https://ko.wikipedia.org/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4%EC%9A%A9_%EC%9C%88%EB%8F%84%EC%9A%B0_%ED%95%98%EC%9C%84_%EC%8B%9C%EC%8A%A4%ED%85%9C)

################################################


# pyenv 설치(windows)
 : cmd 창에서 pyenv-win 설치

 ```
 pip install pyenv-win --target %USERPROFILE%\.pyenv
 ```

 - 윈도우 시스템변수 설정
    - 변수이름: pyenv
    변수값 : C:\Users\사용자id\.pyenv\pyenv-win\bin

    - 변수이름 : PYENV_HOME
    변수값 : C:\Users\사용자id\.pyenv\pyenv-win\

## flask 개발 환경구축

- 가상환경 만들기 + python version 
- pyenv 이용하여 파이썬 버전컨트롤하기!
    - [virtualenv](https://virtualenv.pypa.io/en/latest/installation.html)

    - 가상환경 관리 커맨드 툴
        - [virtualenvwrapper](https://hidekuma.github.io/python/virtualenv/virtualenvwrapper/python-virtualenv-wrapper/)

pip install virtualenv

```
$ python -m venv my-env
$ virtualenv my-env --python=C:\Users\hello\.pyenv\pyenv-win\versions\3.8.6\python.exe
```

1. 가상환경만들어준 후 ctrl+shift+p 이용하여 select interpreter를 해당 가상환경으로 지정해줘라.
2. pip install flask==1.1.2
3. pip freeze > requirements.txt

### conda 환경에서 구축하기

```
$ conda create -n flask_googlekeep python=3.8
$ conda install flask==1.1.2
$ conda list --export > packagelist.txt

```

## flask 공식문서참조 레퍼런스
[flask](https://flask.palletsprojects.com/en/1.1.x/quickstart/)

## flask 실행 및 디버그모드

- gitignore 세팅
    - [gitignore](https://www.toptal.com/developers/gitignore)
- 가상환경설치
    - vscode 인터프리터 설정 (커맨드 쉬프트 P)
- flask 설치 (1.1.2)
- 의존성 기록 (requirements.txt 작성)
    - requirements.txt 기반 삭제, 생성 시뮬
- app.py 작성
- flask run
    - FLASK_APP=gogglekaap/app.py:app flask run
    - 앱실행 (OS 별 문서확인)
    - FLASK_APP, FLASK_ENV 이해
    - 디버깅 모드 / 프로덕션 모드 차이 이해
        - 에러발생화면
        - 오토리로드
- __name__
    - port, host, debug 인자


### 오토리로드 (auto reload mode 설정)

: 환경변수로 아래처럼 설정하면 된다.

```
$ export(set) FLASK_ENV=development
$ flask run
```

- 예시

```
(app.py)
from flask import Flask

app = Flask(__name__)

print('__name__', __name__)
print('DEBUG', app.config['DEBUG'])


@app.route('/')     # 어떤 url에 route시킬것인가를 지정
def index():
    return "hello world!!!"

if __name__ == '__main__':
    print('run')
    app.run(debug=True, port=5051, host='localhost')
```

- $ python app.py

    1. __name__ 이 __main__을 가르키고 있다
    2. __main__ 안의 debug 모드와 port, host 주소를 실행시킨다.

- $ flask run
    1. __name__ 은 app을 가르킨다.

    2. 그냥 flask run 하면 auto reload가 안된다.개발할때마다 flask run 쳐줘야하는 불편함. 그래서 debug mode 설정해줘야 한다.


## 플라스크 어플리케이션 팩토리

- refference

[appfactories](https://flask.palletsprojects.com/en/1.1.x/patterns/appfactories/)

- create_app 작성 및 이해
    - create_app 함수 작성 및 return app
    - create_app 기동 로그 찍기
    - FLASK_APP=googlekaap flask run

```
def create_app(config_filename):
    app = Flask(__name__)
    app.config.from_pyfile(config_filename)

    from yourapplication.model import db
    db.init_app(app)

    from yourapplication.views.admin import admin
    from yourapplication.views.frontend import frontend
    app.register_blueprint(admin)
    app.register_blueprint(frontend)

    return app
```

- $ flask run
    - flask run할떄 create_app이란게 있으면 무조건실행시켜준다. 그때 return 받은 app을 flask run에서 이용한다.

- $ __init__.py
    - 해당 디렉토리안에 있다면, 해당 디렉토리는 모듈화가 된다. 그러면 flask run할때 __init__.py안에 있는게 실행된다.

```
(__init__.py)
from flask import Flask

def create_app():
    print('run: create_app()')
    app = Flask(__name__)

    @app.route('/')     # 어떤 url에 route시킬것인가를 지정
    def index():
        return "hello world!!!"

    return app
```

원래 환경변수 설정을 set FLASK_APP=googlekaap/app.py:app 이렇게 안줘도 된다. create_app을 자동으로 flask가 실행시켜 줄것이며, 
우리 모듈명은 __init__.py을 통해서 googlekaap디렉토리가 모듈화가 되었기 때문에 파이썬파일로 인식하게 된다.
그래서 set FLASK_APP=googlekaap 만 줘도 된다. 


- 순환참조 장애(circular import error)
: python 파일을 서로 import 했을때 나타나는 장애

 
- 순환참조 장애 해결법:  해당 import를 함수안에 넣어서 runtime될때 import가 되게끔 하면 된다. 이러한 순환참조장애를 미연에 방지 하기위해서 어플리케이션 팩토리를 이용한다.(위구조모양!!)

```
(testA.py)
import b

def print_a():
    print('a')
    b.print_b()
print_a()

(testB_py)
import a

def print_b():
    print('b')

def print_c():
    print('c')
    a.print_a()
```

## 플라스크 기본라우터

- [참고문서](https://flask.palletsprojects.com/en/2.3.x/quickstart/#routing)
- 공식문서의 라우팅을 실습해보자.

- 라우터란?
- 각종 리퀘스트 control
- 라우터 데이터타입
- flask routes 

```
from flask import Flask

def create_app():
    print('run: create_app()')
    app = Flask(__name__)

    @app.route('/')     # 어떤 url에 route시킬것인가를 지정
    def index():
        return "hello world!!!"

    ''' Routing Practice'''
    from flask import jsonify, redirect, url_for
    from markupsafe import escape

    @app.route('/text/name/<name>')
    def name(name):     #<>꺽새로 넣어주면 해당 parameter에 인자넣어줄것
        return f'Name is {name} {escape(type(name))}'

    @app.route('/text/id/<int:id>')
    def id(id):
        return 'ID: %d' %id
    
    @app.route('/text/path/<path:subpath>')
    def path(subpath):
        return subpath
    
    @app.route('/text/json')
    def json():
        return jsonify({'hello' : 'world'})
    
    @app.route('/text/redirect/<path:subpath>')
    def redirect_url(subpath):
        return redirect(subpath)

    
    @app.route('/text/urlfor/<path:subpath>')
    def urlfor(subpath):
        return redirect(url_for('path',subpath=subpath)) ## url_for의 인자로는 정의된 router의 함수명이 들어가면된다.
            # 받아온 subpath를 url_for의 subpath로 넣어주고, def path는 subpath가 인자로 필요하잖아. 그걸 그대로 url_for의 인자로 subpath로 넣어줫다고 생각해라.
            # 결과로 path함수정의된걸 url에 찍어준다.
            # url 정의할때 굉장히 많이사용한다.
    return app
```


- http://127.0.0.1:5000/text/name/hello 여기로 접속해서 하나씩 확인해보자.
- 기본적으로 <>안에서 들어오는건 str임을 확인할수 있다.

- 우리가 정의한 routes를 보여준다.

```
$ flask routes
```

## 플라스크 리퀘스트 후크와 어플리케이션 컨텍스트

- v1.0.0 참조

###  리퀘스트 후크란?
: 이벤트 트리거 전,후에등에 이벤트를 트리거링 하여 컨트롤 할수 있다.

- 이렇게 순서를 정의할수 있다면, 어플리케이션 제작시 공통적으로 제작시 의도한대로 만들수있다.

![image](https://github.com/OC-JSPark/flask_test/assets/46878973/983b849b-f16c-4296-86ca-cb87748adbef)

- 레퍼런스

[리퀘스트 후크](https://flask.palletsprojects.com/en/1.1.x/api/#flask.Flask.before_request)
    
### 애플리케이션 컨텍스트
: 자주 사용되는 앱 컨텍스트로는 *g* 와 *current_app*이 있다. 요청이 생성되고, 완료될 때 동일하게 생성 및 제거된다.

- g(=global)
    - 자원 관리용도로 사용한다.
    - 각각의 request 내에서만 값이 유효한 스레드 로컬변수.

```
from flask import g
g.data='data'
```

- current_app
    - 활성화된 어플리케이션을 위한 인스턴스
    - current_app을 통해서 활성화된 인스턴스를 조회할수 있다.
    - app = Flask(__name__) 에 접근하고 싶다면 어떻게 하나? 이럴때 사용. 
    - 즉, app 인스턴스를 import 하지 않고도, app의 config 정보를 조회가능
    - 이를통해 순환참조 에러를 사전예방가능.
    

```
from flask import current_app
current_app.config['DEBUG']
```

- 레퍼런스

[appcontext](https://flask-docs-kr.readthedocs.io/ko/latest/appcontext.html)




## 플라스크 메서드 처리와 리퀘스트 컨텍스트

- [HTTP](https://developer.mozilla.org/ko/docs/Web/HTTP)
    - [HTTP method](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods)
        - [HTTP 설명 보조](https://github.com/hidekuma/gogglekaap/wiki/G.1.-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B8%B0%EB%8A%A5-%EA%B5%AC%ED%98%84:-%EC%84%B8%EC%85%98%EC%9D%B4%EB%9E%80%3F)
        - [method 설명 보조](https://github.com/hidekuma/gogglekaap/wiki/J.1.--Restful-API:-RESTful%EC%9D%98-%EB%8C%80%ED%91%9C%EC%A0%81%EC%9D%B8-%ED%8A%B9%EC%A7%95-%ED%9B%91%EC%96%B4%EB%B3%B4%EA%B8%B0)

- POST, form 데이터 조회
- GET, 쿼리파라미터 조회
- JSON 데이터 조회
- postman 사용

### 리퀘스트 컨텍스트
: 같은 endpoint의 http 리퀘스트라도 method가 다르거나, 같이 넘어온 페이로드에 따라 서버 응답값이 바뀌어야한다.즉, 서버사이드에서 리퀘스트에 대한 데이터를 접근하고 구분 할수 있어야 한다.

- flask의 request 컨텍스트를 이용해서 http요청에 대한 자원(get,post,delete,put) 정보를 조회해보기
    - 참고자료 v1.0.1

```
from flask import request, session
```

- requset.path == '/hello'    ## 인입되는 url을 알수있다.
- request.mehod == 'POST'     ## 어떤 method가 인입되었는지, 호출되었는지 알수 있다.

- ?test=true
: 이런 쿼리스타일은 request.args에서 받는구나.

- postman에서 body에 실어서 넣었더니 request form 으로 가는구나.

- 레퍼런스
    - [Accessing Request Data](https://flask.palletsprojects.com/en/1.1.x/quickstart/#accessing-request-data)
    - [Flask.Request](https://flask.palletsprojects.com/en/1.1.x/api/#flask.Request)


[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}
 

