---
title:  "Flask"
excerpt: " python을 활용한 multi threading 구현"

categories:
  - Python
tags:
  - [Python, thread, multi, threading, list, dictionary, sort, queue]

toc: true
toc_sticky: true

breadcrumbs: true
 
date: 2023-09-09
last_modified_at: 2023-09-09
---



# 만들기능
메모추가, 수정,삭제,편집,복구
메모이미지 삽입기능
메모 라벨링 기능
메모 페이지네이션
메모검색
각 기능 API작성
API문서자동화
데이터베이스 마이그레이션
동적인페이지만들기


# 학습가능한 flask 기술스택
- flask
    - Application factories
    - Application context
    - Authentication
    - Blueprint
    - Configs
    - Debugging
    - Router
    - Request Hooking
    - Request context
    - Staging 환경별로 staging 하는법
    - Session
    - Serving static files
    - Template engine & rendering
    - Test Clinet
- flask-WTF
    - CSRF 해킹방어
- Flask-restx
    - RESTful API 만들기 위해 restx사용
- Flask-SQLAlchemy
    - ORM 플라스크에서는 orm이 지원안되서 사용함
    : ORM이란 데이터베이스를 쉽게 사용하게 해주는 기능
- Flask-Migrate
    - Database Migration : db관리위해서
- Flask deployment 배포위해서!
    - WSGI
    - nginx
    - docker
    - docker-compose : 도커관리툴
- Flask unittest & TDD
    - pytest

# 구글메모장만들기
- google font
- material desing lite
- material icon
- jquery 3.5.1
- CSSVars
- Masonry

# 배포인프라
- AWS EC2 이용
- AWS RDS 라는 데이터베이스 이용

# 윈도우에서는 WSL2 환경사용.

[WSL2](https://ko.wikipedia.org/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4%EC%9A%A9_%EC%9C%88%EB%8F%84%EC%9A%B0_%ED%95%98%EC%9C%84_%EC%8B%9C%EC%8A%A4%ED%85%9C)
################################################


# pyenv 설치(windows)
 : cmd 창에서 pyenv-win 설치

 ```
 pip install pyenv-win --target %USERPROFILE%\.pyenv
 ```

 - 윈도우 시스템변수 설정
    - 변수이름: pyenv
    변수값 : C:\Users\사용자id\.pyenv\pyenv-win\bin

    - 변수이름 : PYENV_HOME
    변수값 : C:\Users\사용자id\.pyenv\pyenv-win\

## flask 개발 환경구축

- 가상환경 만들기 + python version 
- pyenv 이용하여 파이썬 버전컨트롤하기!

pip install virtualenv

```
$ python -m venv my-env
$ virtualenv my-env --python=C:\Users\hello\.pyenv\pyenv-win\versions\3.8.6\python.exe
```

1. 가상환경만들어준 후 ctrl+shift+p 이용하여 select interpreter를 해당 가상환경으로 지정해줘라.
2. pip install flask==1.1.2
3. pip freeze > requirements.txt

### conda 환경에서 구축하기

```
$ conda create -n flask_googlekeep python=3.8
$ conda install flask==1.1.2
$ conda list --export > packagelist.txt

```

## flask 공식문서참조
https://flask.palletsprojects.com/en/1.1.x/quickstart/

## flask 실행

- 환경변수설정해주기
set FLASK_APP=googlekaap/app.py:app





## auto reload mode 설정

```
(app.py)
from flask import Flask

app = Flask(__name__)

print('__name__', __name__)
print('DEBUG', app.config['DEBUG'])


@app.route('/')     # 어떤 url에 route시킬것인가를 지정
def index():
    return "hello world!!!"

if __name__ == '__main__':
    print('run')
    app.run(debug=True, port=5051, host='localhost')
```
    - python app.py
        - __name__ 이 __main__을 가르키고 있다
        - __main__ 안의 debug 모드와 port, host 주소를 실행시킨다.

    - flask run
        - __name__ 은 app을 가르킨다.

        - 그냥 flask run 하면 auto reload가 안된다.
            개발할때마다 flask run 쳐줘야하는 불편함.
            그래서 debug mode 설정해줘야 한다.

```
$ export(set) FLASK_ENV=development
$ flask run
```

- 플라스크 어플리케이션 팩토리

https://flask.palletsprojects.com/en/1.1.x/patterns/appfactories/

```
def create_app(config_filename):
    app = Flask(__name__)
    app.config.from_pyfile(config_filename)

    from yourapplication.model import db
    db.init_app(app)

    from yourapplication.views.admin import admin
    from yourapplication.views.frontend import frontend
    app.register_blueprint(admin)
    app.register_blueprint(frontend)

    return app
```
    - flask run할떄 create_app이란게 있으면 무조건실행시켜준다. 그때 return 받은 app을 flask run에서 이용한다.

    - __init__.py
        해당 디렉토리안에 있다면, 해당 디렉토리는 모듈화가 된다. 그러면 flask run할때 __init__.py안에 있는게 실행된다.

```
(__init__.py)
from flask import Flask

def create_app():
    print('run: create_app()')
    app = Flask(__name__)

    @app.route('/')     # 어떤 url에 route시킬것인가를 지정
    def index():
        return "hello world!!!"

    return app
```

원래 환경변수 설정을 set FLASK_APP=googlekaap/app.py:app 이렇게 안줘도 된다. create_app을 자동으로 flask가 실행시켜 줄것이며, 
우리 모듈명은 __init__.py을 통해서 googlekaap디렉토리가 모듈화가 되었기 때문에 파이썬파일로 인식하게 된다.
그래서 
set FLASK_APP=googlekaap 만 줘도 된다. 


- 순환참조 장애(circular import error)
 python 파일을 서로 import 했을때 나타나는 장애
 해당 import를 함수안에 넣어서 runtime될때 import가 되게끔 하면 된다.


이러한 순환참조장애를 하기위해서 이러한 팩토리를 이용한다. 위구조모양!!

# 플라스크 기본라우터

- [참고문서](https://flask.palletsprojects.com/en/2.3.x/quickstart/#routing)
- 공식문서의 라우팅을 실습해보자.
- 

```
from flask import Flask

def create_app():
    print('run: create_app()')
    app = Flask(__name__)

    @app.route('/')     # 어떤 url에 route시킬것인가를 지정
    def index():
        return "hello world!!!"

    ''' Routing Practice'''
    from flask import jsonify, redirect, url_for
    from markupsafe import escape

    @app.route('/text/name/<name>')
    def name(name):     #<>꺽새로 넣어주면 해당 parameter에 인자넣어줄것
        return f'Name is {name} {escape(type(name))}'

    @app.route('/text/id/<int:id>')
    def id(id):
        return 'ID: %d' %id
    
    @app.route('/text/path/<path:subpath>')
    def path(subpath):
        return subpath
    
    @app.route('/text/json')
    def json():
        return jsonify({'hello' : 'world'})
    
    @app.route('/text/redirect/<path:subpath>')
    def redirect_url(subpath):
        return redirect(subpath)

    
    @app.route('/text/urlfor/<path:subpath>')
    def urlfor(subpath):
        return redirect(url_for('path',subpath=subpath)) ## url_for의 인자로는 정의된 router의 함수명이 들어가면된다.
            # 받아온 subpath를 url_for의 subpath로 넣어주고, def path는 subpath가 인자로 필요하잖아. 그걸 그대로 url_for의 인자로 subpath로 넣어줫다고 생각해라.
            # 결과로 path함수정의된걸 url에 찍어준다.
            # url 정의할때 굉장히 많이사용한다.
    return app
```


    - http://127.0.0.1:5000/text/name/hello 여기로 접속해서 하나씩 확인해보자.
    - 기본적으로 <>안에서 들어오는건 str임을 확인할수 있다.

- 우리가 정의한 routes를 보여준다.

```
$ flask routes
```

# 플라스크 리퀘스트 후크와 어플리케이션 컨텍스트

- 리퀘스트 후크란?
: 이벤트 트리거 전,후에등에 이벤트를 트리거링 하여 컨트롤 할수 있다.


current_app

app = Flask(__name__) 에 접근하고 싶다면 어떻게 하나? 
그럴때 사용. 즉, app 인스턴스를 import 하지 않고도, app의 config 정보를 조회가능
이를통해 순환참조 에러를 사전예방가능.


current_app을 통해서 활성화된 인스턴스를 조회할수 있다.

이렇게 순서를 정의할수 있다면, 어플리케이션 제작시 공통적으로 제작시 의도한대로 만들수있다.

![image](https://github.com/OC-JSPark/flask_test/assets/46878973/983b849b-f16c-4296-86ca-cb87748adbef)


# 플라스크 메서드 처리와 리퀘스트 컨텍스트

requset.path == '/hello'    ## 인입되는 url을 알수있다.
request.mehod == 'POST'     ## 어떤 method가 인입되었는지, 호출되었는지 알수 있다.

?test=true
이런 쿼리스타일은 request.args에서 받는구나.

postman에서 body에 실어서 넣었더니 request form 으로 가는구나.

flask의 request 컨텍스트를 이용해서 http요청에 대한 자원(get,post,delete,put) 정보를 조회해보았다.

# 템플릿 렌더링

css나 js같은경우 page마다 공통적으로 사용하는 경우가 많다. layout.html을 만들어서 중앙관리를 하고 다른 index.html이나 다른 html은 layout.html을 상속받는 형식으로 만든다.

layout.html은 jinja의 Template Designer Documentation만 보고 사용해보자.

이게 template engine 문법이다.
{% block head %}


{% endhead %}

페이지마다 title명을 바꾸고 싶을때를 위해 지정해놓자.

이제 index.html에서 상속받게 해보자.

head가 안들어오는 이유는? 상속받는 layout.html의 해당부분을 그대로 이용한다는 내용을 적어줘야한다. python에서 부모상속받듣이 그대로 쓰면 된다.
{% block head %}
    {{ super( )}}
{% endblock %}
이러면 index.html이지만 layout.html에 있는 css나 js들을 동일하게 load할수 있따.

indent를 맞춰주기 위해 -를 붙여줄수 있따.
-는 빈공백을 제거하겠다는 의미이다.

404 error : not founded page 떳을때 html이 중앙관리를 한다.
그걸동일하게 layout.html에서 받아서 작성해보자.

그러기 위해 404.html을 만들고
라우터를 조정해줘야한다.

__init__.py에 들어가서 errorhandler를 추가해주면 된다.


## 정적파일 추가 및 디버그 환경 캐시제거
[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}
 

