---
layout: single
title: "[JPA] 일대일[1:1] 연관관계 매핑"
date: "2022-02-05 06:20:53"
categories: JPA
tag: [JPA, hibernate]
toc: true
author_profile: true
# sidebar:
#   nav: "docs"
---

## 📌 일대일 [1:1]

## ✔ 목차

- 연관관계 매핑시 고려사항 3가지
- 다대일 [N:1]
- 일대다 [1:N]
- **일대일** [1:1] 🚀
- 다대다 [N:M]
- 실전 예제 - 3. 다양한 연관관계 매핑

## ✔ 일대일 [1:1]

## 📌 일대일 관계

- 일대일 관계의 반대 역시 일대일
- 주 테이블이나 대상 테이블 중에 외래키 선택 가능
  - 주 테이블에 외래키
  - 대상 테이블에 외래키
- <u class="custom-border-bottom">외래키에 데이터베이스 유니크(UNI) 제약조건 추가</u>

### ✅ 일대일: 주 테이블에 외래키 단방향 설정

<img src="https://user-images.githubusercontent.com/53969142/152642618-bf40b8e6-1506-4c42-a8ca-2b1f27573c6c.PNG" width="90%" height="100%">

- 회원과 사물함 간의 관계를 설정한다.
- 한명의 회원은 딱 한개의 사물함만 가질 수 있다.
- 현재는 회원 객체를 주 테이블로 설정한다.
- 회원에 외래키를 넣어도 되고, 라커에 외래키를 넣어도 상관이 없다.
  - 1:1 연관관계이기에 가능한 상황이다.

### ✅ 일대일: 주 테이블에 외래키 양방향 설정

<img src="https://user-images.githubusercontent.com/53969142/152642651-41428fd6-c8e5-423c-989c-284ba412a392.PNG" width="90%" height="100%">

- 일대일 관계에서 양방향 연관관계 매핑 역시 가능하다.
- Locker 테이블에 Member member 객체를 추가해주면된다.

### 💡 일대일: 주 테이블에 외래키 양방향 정리

- <u class="custom-border-bottom">다대일 양방향 매핑처럼 외래키가 있는곳이 연관관계의 주인</u>
- 반대편은 <u class="custom-border">mappedBy</u> 적용을 해야한다.

## 📌 일대일 관계: 대상 테이블

위에서는 일대일 관계 **주 테이블**에 대해 알아보았고 다음은 **대상테이블**에 대해 알아보자.

### ✅ 일대일 관계: 대상 테이블에 외래키 단방향 설정

<img src="https://user-images.githubusercontent.com/53969142/152642767-c8a5f2c2-c4e1-43b2-82d2-081c8689da46.PNG" width="100%" height="100%">

Member 엔티티에 있는 Locker locker 객체를 연관관계의 주인으로 설정하고 싶은데
테이블 구조에서는 **MEMBER 테이블**이 아닌, **LOCKER 테이블**에 **외래키가 있는 경우**인 상황이다.
하지만 <u class="custom-border-bottom">Member 엔티티에 있는 Locker locker 객체로 테이블 Locker의 외래키를 관리 할 수 없다. (지원도 안되고 방법도 존재하지 않는다)</u>

- 마치 [일대다 1:N](https://ym1085.github.io/jpa/JPA-%EC%9D%BC%EB%8C%80%EB%8B%A4/) 단방향에서의 상황과 동일하다.

### ✅ 일대일 관계: 대상 테이블에 외래키 양방향 설정

<img src="https://user-images.githubusercontent.com/53969142/152643543-05e67881-5d00-4164-a461-68901d8ae879.PNG" width="100%" height="100%">

이전 사진(단방향 관계)에서는 불가능하였지만, 양방향 설정에서는 연관관계의 주인 매핑이 가능하다.
<u class="custom-border-bottom">즉, 1:1 관계를 간략히 정리를 하자면 내가 내것만 관리할 수 있는것이다.이 말을 조금 풀어서 말하면 내 엔티티에 있는 외래키는 내가(엔티티 지칭) 관리해야한다.</u>

### ⚡ 논란의 여지가 있을 수 있는 부분

<img src="https://user-images.githubusercontent.com/53969142/152644031-00c4c6e1-04c2-404d-8248-9e3e4fbdd0a3.PNG" width="100%" height="100%">

위 사진에서 DB만 생각을 했을 때 LOCKER 테이블이 MEMBER_ID를 가지는게 좋을지, 아니면 MEMBER 테이블이 LOCKER_ID를 가지는게 좋을지 생각해야 하는 상황이 있다 가정 해보자.

### 💡 비즈니스 요구사항에 따른 변화

> 테이블은 한 번 만들어지면 추후에 수정하는게 쉽지는 않다.

- **하나의 회원은 여러개의 라커를 가질 수 있다.**
  - 만약 위와 같을 시 LOCKER 테이블이 MEMBER_ID를 가지는게 맞다.
- **하나의 라커는 여러개의 회원을 가질 수 있다.**
  - 반대일 경우에는 MEMBER 테이블이 LOCKER_ID를 가지는게 맞다.

### ❓ 개발자 입장에서 더 나은 방향성은?

일단 **개발자 입장**에서는 Member 테이블에 LOCKER_ID가 있는것이 성능상 유리하다.
대부분의 비즈니스에서 Member를 조회 해와야 하기 때문에 쿼리 한방으로 Locker 값을
쉽게 조회할 수 있기 때문이다. 하지만 회사마다 DBA의 생각이 다르기에 상황에 맞춰
연관관계를 설정해야 한다.

## 📌 일대일 관계 정리

### 🚀 주테이블에 외래키

```text
# 위에서 주 테이블 단방향, 양방향 사진 참고

LOCKER TABLE
------------------------
| LOCKER_ID(PK)        |
| NAME                 |
------------------------

MEMBER TABLE(회원을 주 테이블로 설정)
------------------------
| MEMBER_ID(PK)        |
| LOCKER_ID(FK, UNI) * |
| USERNAME             |
------------------------
```

- 주 객체가 대상 객체의 참조를 가지는것처럼, 주 테이블에 외래키를 두고 대상 테이블을 찾는다.
- 객체지향 개발자가 선호한다
- JPA 매핑 편리
- **장점**: <u class="custom-border-bottom">주 테이블만 조회해도 대상 테이블에 데이터가 있는 확인 가능</u>
- **단점**: 값이 없으면 외래키에 NULL 허용

### 🚀 대상 테이블에 외래키

```text
# 위에서 대상 테이블 단방향, 양방향 사진 참고

LOCKER TABLE(라커를 주 테이블로 설정)
------------------------
| LOCKER_ID(PK)        |
| MEMBER_ID(FK) *      |
| NAME                 |
------------------------

MEMBER TABLE
------------------------
| MEMBER_ID(PK)        |
| USERNAME             |
------------------------
```

- 대상 테이블에 외래키가 존재
- 전통적인 DB 개발자가 선호한다
- **장점**: 주 테이블, 대상 테이블을 일대일에서 일대다로 변경 시 테이블 구조 유지가능
- **단점**: <u class="custom-border-bottom">프록시 기능의 한계로 지연로딩 설정해도 항상 즉시 로딩됨</u>

### 참고 자료

- [일대일[1:1]](https://www.inflearn.com/course/ORM-JPA-Basic/lecture/21702?tab=curriculum&volume=1.00)
