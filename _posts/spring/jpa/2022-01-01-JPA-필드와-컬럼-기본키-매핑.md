---
layout: single
title: "[JPA] 필드와 컬럼 매핑, 기본키 매핑"
date: "2022-01-24 21:43:58"
categories: JPA
tag: [JPA, hibernate]
toc: true
author_profile: true
# sidebar:
#   nav: "docs"
---

## ✔ 요구사항 정리

- 회원은 일반 회원 & 관리자로 구성
- 회원 가입일 & 수정일이 존재
- 회원을 설명할 필드가 존재 해야한다.
- 해당 필드는 길이 제한이 없다

## ✔ @Column

| 속성명               | 설명                                                                        |
| -------------------- | --------------------------------------------------------------------------- |
| **name**             | **필드**와 **매핑**할 **테이블의 컬럼명**                                   |
| **insertable**       | 등록 가능 여부 지정 (**INSERT 가능 여부**)                                  |
| **updatable**        | 변경 가능 여부 지정 (**UPDATE 가능 여부**)                                  |
| **nullable**         | null값 허용 여부, **false 설정**시 DDL 생성시 **not null 제약 조건** 붙는다 |
| **unique**           | 한 컬럼에 유니크 제약 조건을 걸 때 사용                                     |
| **columnDefinition** | 데이터베이스 컬럼정보를 직접 줄 때 사용이된다                               |
| **length**           | 문자 길이에 대한 제약조건 설정                                              |

## ✔ @Id

- **기본키 매핑**시 사용이 된다.

## ✔ @Enumerated

- Java에서 **Enum 사용 시** Enumatrated 어노테이션을 사용하면 된다.

### ✅ Enumerated(EnumType.ORDINAl)

- **EnumType.ORDINAL**을 운영상에서 사용하면 안된다. 📌
- **EnumType.ORDINAL**은 **ENUM**을 **숫자**(1, 2, 3)로 **저장**한다.
- 즉, **EnumType.STRING**을 사용

## ✔ @Temporal

- **날짜 설정 시 사용이 되는 어노테이션**
- **자바**는 **날짜**, **시간**이 다 존재하지만 **보통의 DB**는 **날짜**, **시간을 구분**하여 사용한다
- **Java 8**이상에서는 **LocalDate**, **LocalDateTime을** 사용해도 Hibernate가 인식한다

## ✔ @Lob

- 매핑하는 **필드 타입이 문자**면 **CLOB** 매핑, 나머지 **BLOB** 매핑.
- VARCHAR를 넘어서는 데이터 형식을 표현할 경우 사용.

## ✔ @Transient

```java
@Transient
private Integer temp;
```

- 필드 매핑 x
- 데이터베이스에 저장, 조회 x
- 주로 메모리상에서만 임시로 어떤 값을 보관하는 경우 사용.

---

## ✔ 기본 키 매핑 어노테이션

```java
@Id @GeneratedValue(strategy = GenerationType.AUTO)
private Long id;
```

- **직접 할당**
  - @Id만 사용
- **@Id**
- **@GeneratedValue**

### ✅ @GeneratedValue

```java
public enum GenerationType {
    TABLE,
    SEQUENCE,
    IDENTITY,
    AUTO;

    private GenerationType() {

    }
}
```

- **자동 생성**(**@GeneratedValue**)
  - **IDENTITY 전략**
    - 데이터베이스에 위임, MYSQL
  - **SEQUENCE 전략**
    - 데이터베이스 **시퀸스 오브젝트 사용**, ORACLE
    - @SequenceGenerator 필요
- **TABLE 전략**
  - **키 생성용 테이블 사용**, 모든 DB에서 사용
  - @TableGenerator 필요
- **AUTO**
  - 방언에 따라 자동 지정, 기본값

### ✅ IDENTITY 전략

```java
@Entity
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
}
```

```java
Hibernate:
    /* insert hellojpa.Member
        */ insert
        into
            Member
            (id, age, createdDate, description, lastModifiedDate, roleType, name)
        values
            (null, ?, ?, ?, ?, ?, ?)
```

- 기본 키 **생성 권한**을 **DB에 위임** 한다.
- 즉, DB가 기본 키 생성에 대한 모든 것을 관리 하도록 제어 한다.

**JPA는** 보통 **트랜잭션 커밋 시점**에 **INSERT SQL을 실행**한다는 특징이 있다 하지만 **IDENTITY 전략**은 DB에 데이터가 INSERT가 된 후에 시퀸스가 생성이 된다는 특징을  
가지고 있다.

위 내용에서 주목해야 하는 부분은 **JPA의 영속성의 키 값으로 기본키 PK가 사용이 되어야 하는데** 위 같은 상황에서는 기본키 값(**시퀸스**)을 셋팅할 수가 없다.

<mark style='background-color: #f1f8ff'>위 같은 이유로 인해 IDENTITY 전략은 예외적으로 트랜잭션 커밋 전에  
INSERT 쿼리가 날라간다.</mark>

### ✅ SEQUENCE 전략

```java
@Entity
@SequenceGenerator(
        name = "MEMBER_SEQ_GENERATOR",
        sequenceName= "MEMBER_SEQ", //매핑할 데이터베이스 시퀀스 이름
        initialValue= 1, allocationSize = 50) //initailValie: 초기값, allocationSize: 증가값
public class Member {
    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE)
    private Long id;
}
```

- 영속성 컨텍스트에 값을 저장하기 위해서는 PK값이 필요하다.
- 위 같은 이유로 인해 SEQUENCE 전략은 **DB**에 있는 **시퀸스 값을 가져와서** 넣어준다.
- **IDENTITY 전략**에서는 바로 INSERT를 했는데, **SEQUENCE 전략**은 한 번에 모아서 INSERT 가능.
- 데이터베이스 시퀸스는 유일한 값을 순서대로 생성하는 특별한 DB Object.
- Oracle, PostgreSQL, DB2

### ✅ @SequenceGenerator Options

- **name**
  - 식별자 생성기 이름
- **sequenceName**
  - DB에 등록된 시퀸스 이름
- **initialValue**
  - DDL 생성시 사용, 최초 sequence값 결정
- **allocationSize**
  - 시퀸스 한번 호출 시 **증가값** 설정
  - call next value for MEMBER_SEQ 호출
    - <mark style='background-color: #f1f8ff'>DB에 50개를 미리 올리고 메모리에서 1씩 사용</mark>
    - 성능에 이점을 가져올 수 있다.
  - **첫 번째**는 **DB**에서 **seq값**을 가져온다
    - **두 번째**부터는 **DB가 아닌 memory**에서 **값**을 가져온다
- **catalog**, **schema**
  - DB catalog, schema 이름

### ✅ TABLE 전략

```java
@Entity
@TableGenerator(
    name = "MEMBER_SEQ_GENERATOR",
    table = "MY_SEQUENCES",
    pkColumnValue = "MEMBER_SEQ", allocationSize = 1
)
public class Member{
    @Id
    @GeneratedValue(
        strategy = GenerationType.TABLE,
        generator = "MEMBER_SEQ_GENERATOR"
    )
    private Long id;
}
```

- 키 생성 전용 테이블 생성 후 시퀸스 관리
- **장점**
  - 모든 DB에 적용 가능
- **단점**
  - 성능 저하

### ✅ @TableGenerator Options

| 속성명                     | 설명                                     |
| -------------------------- | ---------------------------------------- |
| **name**                   | 식별자 생성기 이름                       |
| **table**                  | 키 생성 테이블명                         |
| **pkColumnValue**          | 시퀸스 컬럼명                            |
| **valueColumnNa**          | 시퀸스 값 컬럼명                         |
| **pkColumnValue**          | 키로 사용할 값 이름                      |
| **initialValue**           | **초기 값**, 마지막으로 생성된 값이 기준 |
| **allocationSize**         | 시퀸스 한 번 호출에 **증가하는 수**      |
| **Catalog**                | DB catalog, schema 이름                  |
| **uniqueConstraints(DDL)** | 유니크 제약 조건 지정                    |

### ✅ 권장하는 식별자 전략

- 기본 키 제약 조건은?
  - null 아님, 유일, **변하면 안된다.**
- **미래까지 이러한 조건을 유지하는 자연키 찾기 어려움**
- <mark style='background-color: #f1f8ff'>PK값은 type을 Long형 + 대체키 + 키 생성전략</mark>
- Auto Increment, Sequence Object, UUID, 랜덤 값을 사용하자.

### 참고 자료

- [필드와 컬럼 매핑](https://www.inflearn.com/course/ORM-JPA-Basic/lecture/21693?tab=note&mm=close&speed=1)
- [기본키 매핑](https://www.inflearn.com/course/ORM-JPA-Basic/lecture/21694)
