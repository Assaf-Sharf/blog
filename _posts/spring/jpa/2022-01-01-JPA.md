---
layout: single
title: "[JPA] JPA란?"
date: "2022-01-01 15:31:20"
categories: JPA
tag: [JPA, hibernate]
toc: true
author_profile: true
# sidebar:
#   nav: "docs"
---

## ✔ JPA란?

- **JPA**란 **Java Persistence API**의 약자로, **자바 진영의 ORM 표준**을 의미한다.
- JPA와 SQL-Mapper( Mybatis, iBatis )를 비교
  - **객체**를 **중심**으로 **개발** 진행 가능
  - 데이터 **엔티티**의 **신뢰성** 보장
  - 테이블 변경 및 관리에 더욱 더 효과적
    - 엔티티의 컬럼을 변경하면 알아서 반영이 된다
    - 관계형 RDBMS처럼 테이블 중심이 아닌 객체 중심 개발이기 때문에
  - 기본 CRUD, 페이징 처리, 부가 기능이 미리 제공되어 있다.

## ✔ ORM?

- Object-relational mapping( 객체 관계 매핑 )
- 객체는 객체대로, DB는 DB대로 설계 후 ORM이 중간에서 매핑
- 대중적인 언어에는 대부분 ORM 기술이 존재
  - Mybatis ( SQL-MAPPER )
  - iBatis ( SQL-MAPPER )
  - JPA ( 인터페이스의 집합 - 대표적으로 Hibernate )

## ✔ JPA는 Application과 JDBC 사이에서 동작

![jpa_동작방식](https://user-images.githubusercontent.com/53969142/149769448-c363661b-523f-413b-a177-88e63dd6c80c.PNG)

- Java Application => JPA => JDBC API
- JPA는 애플리케이션과 JDBC 사이에서 동작

## ✔ JPA 동작 - 저장

![jpa_동작방식_저장](https://user-images.githubusercontent.com/53969142/149769504-9e2a3956-9d24-489a-b608-eee6519e84e1.PNG)

### 회원 정보를 저장하고 싶다?

- 자바 애플리케이션을 통해 JPA에게 Member 객체 전달
  - JPA가 Entity( 객체 )를 분석
  - 적절한 INSERT 쿼리 생성
  - JDBC API 사용
  - 🚀 **패러다임 불일치 해결**

## ✔ JPA 동작 - 조회

![jpa_동작방식_조회](https://user-images.githubusercontent.com/53969142/149769574-cce90bf4-7adf-461b-8853-9c79098cd833.PNG)

### 회원 정보를 조회하고 싶다?

- 자바 애플리케이션을 통해 JPA에게 Member 객체 전달
  - 적절한 SELECT SQL 생성
  - JDBC API 사용
  - **ResultSet 매핑**
  - 🚀 **패러다임의 불일치 해결**

## ✔ JPA가 나온 배경

1. 과거에는 **EJB**가 존재 하였는데, **기술의 복잡성이 다수 존재**
2. 위 같은 이유로 인해 **Open Source ORM Hibernate**가 탄생
3. 자바 진영에서 Hibernate를 개발한 개발자를 데려와서 JPA( 자바 표준 ) 탄생

### JPA는 표준 명세?

![jpa_interface](https://user-images.githubusercontent.com/53969142/149770497-3e4df540-cb6e-4cd2-a480-9e645df05ecf.PNG)

- **JPA는 인터페이스의 모음**
- JPA 2.1 표준 명세를 구현한 **3가지 구현체**
- 하이버네이트, EclipseLink, DataNucleus

## ✔ JPA를 왜 사용해야 하는가?

- SQL 중심 개발에서 **객체 중심으로 개발**
- 생산성 & 유지보수
- **패러다임 불일치 해결**
- 성능 ( 캐시 )
- 데이터 접근 추상화와 벤더 독립성
- 표준( 자바 표준 )

### ✅ 생산성 ( JPA와 CRUD )

> SQL을 직접 작성하는 것에 비해 모든 메서드(기능)이 미리 구현이 되 있다

- **저장**( **Insert** )
  - jpa.persist(member);
- **조회**( **Select** )
  - Member member = jpa.find(memberId);
- **수정**( **Update** )
  - member.setName("변경할 이름");
  - 자바 컬렉션에서 데이터를 뺀 후에, 값을 수정하는것을 생각하면 된다
- **삭제**( **Delete** )
  - jpa.remove(memberId);

### ✅ 유지보수 - 기존: 필드 변경 시 모든 SQL 수정

- JPA 사용 시 VO의 컬럼만 추가하면 된다
- JPA는 엔티티 및 테이블 관리 변경에 용이하다
- 즉, DB는 건드리지 않고 객체(Entity)만 수정하면 된다

### ✅ JPA와 패러다임의 불일치 해결

> 🚀 관계형 데이터베이스(RDB)와 객체의 패러다임 불일치를 해결 해준다

- JPA와 상속
- JPA와 연관관계
- JPA와 객체 그래프 탐색
- JPA와 비교하기

### ✅ JPA와 상속

### 데이터 저장 시 개발자가 할 일: INSERT

```java
jpa.persist(album); // album Entity를 넣어주면 알아서 INSERT

//JPA의 내부 동작 메커니즘 ( 처리 방식 )
INSERT INTO ITEM ... // 1번 쿼리 생성 ( JPA가 )
INSERT INTO ALBUM ...
```

### ✅ 데이터 조회 시 개발자가 할 일: SELECT

```java
Album album = jpa.find(Album.class, albumId);

//JPA의 내부 동작 메커니즘 ( 처리 방식 )
SELECT I.*, A.*
FROM ITEM I
JOIN ALBUM A ON I.ITEM_ID = A.ITEM_ID // JPA가 알아서 조인을 해서 데이터를 넘긴다
```

### ✅ JPA와 연관관계, 객체 그래프 탐색

```java
//연관관계 저장
member.setTeam(team); //Team 객체 삽입
jpa.persist(member); //member 객체를 JPA에 전달

//객체 그래프 탐색
Member member = jpa.find(Member.class, memberId);
Team team = member.getTeam();
```

```java
// 신뢰할 수 있는 인티티, 계층
class MemberService {
    ...
    public void process() {
        Member member = memberDao.find(memberId);
        member.getTeam(); //자유로운 객체 그래프 탐색 ( JPA를 사용했다면 )
        member.getOrder().getDelivery();
    }
}
```

- persist를 통해 DB에 데이터 삽입
- member.getTeam()을 통해 **컬렉션에서 데이터를 꺼내듯이 객체를 받을 수 있다** ( 영속성 컨텍스트 )
- 쿼리에 종속적이지 않기에 객체 그래프를 자유롭게 탐색 가능 ( 엔티티의 신뢰성 보장 )

### ✅ JPA와 SQL 비교하기

```java
String memberId = "100";
Member member1 = jpa.find(Member.class, memberId);
Member member2 = jpa.find(Member.class, memberId);

member1 == member2 //같다
```

- 🚀 **JPA는 동일한 트랜잭션에서 조회한 엔티티는 같음을 보장해준다**
- SQL의 경우 조회한 엔티티가 같지 않은것으로 나왔다

### ✅ JPA의 성능 최적화 기능

- **1차 캐시**와 **동일성**( identity ) 보장
- **트랜잭션을 지원하는 쓰기 지연**( transaction write-behind )
- **지연 로딩**( Lazy Loading )

### ✍ 1차 캐시와 동일성 보장

1. **같은 트랜잭션 안에서는 같은 엔티티를 반환** ( 약간의 조회 성능 향상 )
2. DB Isolation Level이 Read Commit이여도 애플리케이션에서 Repeatable Read 보장

```java
String memberId = "100";
Member member1 = jpa.find(Member.class, memberId); // SQL 날리고
Member member2 = jpa.find(Member.class, memberId); // 캐시에서 가져옴

println(m1==m2); //true
```

- 위 예시를 보면 jpa.find를 두번 날리고 있다
- SQL의 경우에는 두번 쿼리가 날라가겠지만, **JPA**는 **캐시**를 통해 한번 날라간다
- ex) 비즈니스 로직이 복잡하여 맴버를 무차별적으로 많이 조회를 하는 경우 사용

### ✍ 트랜잭션을 지원하는 쓰기 지연 - INSERT

1. **트랜잭션**을 **커밋**할 때까지 INSERT **SQL**을 **모아둔다**
2. **JDBC**에서는 **BATCH SQL 기능**을 사용해서 한 번에 SQL 전송

```java
transaction.begin();

em.persist(memberA);
em.persist(memberB);
em.persist(memberC);

//commit하는 순간 데이터베이스에 INSERT SQL을 모아서 보낸다.
transaction.commit(); //[트랜잭션 커밋] -> 이 때 날라간다
```

- 하나의 트랜잭션 단위 내에서, commit을 통해 SQL을 관리할 수 있다.
- 비슷한 쿼리가 들어가야 하는 상황
  - 한 번에 들어가든, 한 번에 모아서 들어가든 결과는 똑같음

### ✍ 트랜잭션을 지원하는 쓰기 지연 - UPDATE

1. UPDATE, DELETE로 인한 로우(ROW)락 시간 최소화
2. 트랜잭션 커밋 시 UPDATE, DELETE SQL 실행하고 바로 커밋

```java
tansaction.begin(); //[트랜잭션] 시작

changeMember(memberA);
deleteMember(memberB);
// ...비즈니스_로직_수행; //비즈니스 로직 수행 동안 DB 로우 락이 걸리지 않는다.

//커밋하는 순간 데이터베이스에 UPDATE, DELETE SQL을 보낸다
transaction.commit(); //[트랜잭션] 커밋
```

### 🔥 지연 로딩과 즉시 로딩

> **지연 로딩**은 특정 객체가 사용될 때 SQL 날리는 것  
> **즉시 로딩**은 특정 객체에 맞물려 있는 객체에 대한 SQL을 한 번에 날리는 것  
> **JPA**는 옵션(Option) 하나 만으로 **즉시**, **지연 로딩**을 **설정**할 수 있음

### 지연 로딩: (중요)

```java
// 지연로딩
Member member = memberDao.find(memberId);
Team team = member.getTeam(); // team값이 실제 필요할 경우 해당 쿼리 실행
String teamName = team.getName();

SELECT * FROM MEMBER // 먼저 실행
SELECT * FROM TEAM // team값이 실제 필요할 경우 해당 쿼리 실행
```

### 즉시 로딩: (중요)

```java
// 즉시로딩
Member member = memberDao.find(memberId);
Team team = member.getTeam();
String teamName = team.getName();

SELECT M.*, T.*
FROM MEMBER JOIN TEAM ....
```

- **지연 로딩**
  - **특정 객체**가 **실제로 사용이 될 때 로딩**
  - 지연 로딩은 **쿼리가 두번 날라간다는 단점**이 있다
- **즉시로딩**
  - **JOIN SQL**로 한 번에 **연관된 객체까지 미리 조회**
  - JPA 옵션을 설정 후 즉시 로딩 설정 가능
  - Member랑 Team 조회 시 한 번에 가져오도록 설정 가능

### 참고 자료

- [JPA 소개](https://www.inflearn.com/course/ORM-JPA-Basic/lecture/21683?tab=note&mm=close)
