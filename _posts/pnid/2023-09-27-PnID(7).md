---
layout: singledemo
title: "데모 페이지"
permalink: /projects/pnid/07
tag: [Vision AI, Drawing]
header:
  teaser: /assets/images/drawing_recognition_teaser.jpg
author_profile: false
sidebar:
  nav: "docs1"
date: 2023-09-27
---

## 데모 페이지

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Image Model UI</title>
</head>

<body>
  <div>
    <form action="#">
      백엔드 선택: &nbsp;
      <select id="backend-select">
        <option value="webgl">GPU-WebGL</option>
        <option value="wasm">CPU-WebAssembly</option>
      </select>
      <input type="submit" value="Submit" />
    </form>
    <form action="#">
      <label>이미지 선택</label>
      <select id="image-url">
        <option value="0">select image</option>
        <option value="pnid01">설계도면01</option>
        <option value="pnid02">설계도면02</option>
        <option value="pnid03">설계도면03</option>
        <option value="pnid04">설계도면04</option>
        <option value="pnid05">설계도면05</option>
        <option value="pnid06">설계도면06</option>
        <option value="pnid07">설계도면07</option>
        <option value="pnid08">설계도면08</option>
        <option value="pnid09">설계도면09</option>
      </select>
      <input type="submit" value="Submit" id="upload-image-button" />
    </form>
    <canvas id="canvas" width="300" height="300" style="border:1px solid black;"></canvas>
    <br>
    <div id="predictions"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/onnxjs/dist/onnx.min.js"></script>

  <script>
    // 이미지 로딩 및 모델 실행 함수
    async function runModel(imageUrl, selectedBackend) {
      // 이전 예측 결과를 지웁니다.
      document.getElementById('predictions').innerHTML = '';

      const modelFilepath = `../../assets/model/yolov3-12-int8.onnx`; // 모델 파일 경로 설정
      const image = new Image();
      image.src = imageUrl;

      // 이미지 로딩 완료 후
      image.onload = async function() {
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height); // 기존 그림을 지웁니다.
        ctx.drawImage(image, 0, 0, canvas.width, canvas.height); // 이미지를 그립니다.

        // 모델을 초기화하고 실행하는 로직 추가
        const session = new onnx.InferenceSession({ backendHint: selectedBackend });
        await session.loadModel(modelFilepath);
        const inputTensor = preprocessImage(ctx, canvas); // 이미지 전처리 함수(preprocessImage) 사용
        const output = await session.run([inputTensor]);
        const predictions = Array.from(output.values())[0].data; // 예측 결과값 배열

        // 예측 결과를 화면에 표시하는 로직 추가
        displayPredictions(predictions, ctx);
      };
    }

    // 이미지 전처리 함수 (예시)
    function preprocessImage(ctx, canvas) {
      // 이미지 데이터를 가져옵니다.
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

      // 이미지 전처리 로직 추가
      // ...

      // 전처리된 이미지 데이터를 Float32Array로 변환하여 Tensor 생성
      const inputData = new Float32Array(imageData.data).map(v => v / 255); // 0~1로 정규화 예시
      const tensor = new onnx.Tensor(inputData, 'float32', [1, 3, canvas.width, canvas.height]);
      return tensor;
    }

    // 예측 결과를 화면에 표시하는 함수 (예시)
    function displayPredictions(predictions, ctx) {
      const predictionsDiv = document.getElementById('predictions');
      predictionsDiv.innerHTML = '<h2>Predictions:</h2>';
      predictionsDiv.innerHTML += '<ul>';
      predictions.forEach((prediction, index) => {
        predictionsDiv.innerHTML += `<li>Class ${index}: ${prediction.toFixed(4)}</li>`;
      });
      predictionsDiv.innerHTML += '</ul>';

      // 바운딩 박스 그리기
      const boxColor = 'red';
      const boxThickness = 2;
      // predictions에서 바운딩 박스 좌표를 추출하고 그립니다.
      // 각 바운딩 박스의 좌표는 [x, y, width, height] 형식으로 주어집니다.
      predictions.forEach((prediction, index) => {
        const startX = prediction.x; // 바운딩 박스의 시작 x 좌표
        const startY = prediction.y; // 바운딩 박스의 시작 y 좌표
        const width = prediction.width; // 바운딩 박스의 너비
        const height = prediction.height; // 바운딩 박스의 높이

        // 바운딩 박스 그리기
        ctx.beginPath();
        ctx.rect(startX, startY, width, height);
        ctx.lineWidth = boxThickness;
        ctx.strokeStyle = boxColor;
        ctx.fillStyle = 'transparent'; // 바운딩 박스 내부를 채우지 않음 (투명)
        ctx.stroke();
      });
    }

    document.addEventListener('DOMContentLoaded', function() {
      const backendSelect = document.getElementById('backend-select');
      const imageUrlInput = document.getElementById('image-url');
      const runModelButton = document.getElementById('upload-image-button');

      runModelButton.addEventListener('click', function() {
        const selectedBackend = backendSelect.value;
        const imageName = imageUrlInput.value; // 이미지 파일 이름 가져오기
        const imagePath = `../../assets/images/2023-09-27-PnID(7)/${imageName}.jpg`; // 이미지 경로

        // imagePath과 selectedBackend을 사용하여 모델 실행 로직 수행
        runModel(imagePath, selectedBackend);
      });

      imageUrlInput.addEventListener('change', function() {
        if (imageUrlInput.value === "0") {
          runModelButton.disabled = true;
        } else {
          runModelButton.disabled = false;
        }
      });
    });
  </script>
</body>
