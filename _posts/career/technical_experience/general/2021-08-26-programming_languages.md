---
title: "Programming Languages"
permalink: /categories/career/technical_experience/programming_languages
layout: single
author_profile: false
categories:
  - technical_experience
sidebar:
  nav: "technical_experience"
tag:
  - technical_experience
  - devops
  - tech
  - personal
  - python
  - C++
  - C 
header:
  overlay_image: "/assets/images/categories/career/technical_experience/general/programming_languages_1.jpg"
---


# Overview

Throughout my career, I have had the opportunity to program in several languages, as well as support applications that are written in those languages. Both roles have helped me understand application development more deeply. As a developer, you focus on functionality and capability; as support, you focus on performance and deliverability.

Having insight into both roles helped me understand that code should not only be written to solve the problem but to fit in harmoniously in technical infrastructure. While some developers code in a vacuum and some operational engineers focus solely on execution, the end goal should be for both sides to be mindful of one and other and to work together. For any technical infrastructure to be mature, Dev and Ops must come together.

In this post, I explain my understanding of some of my favorite programming languages, and my experience with them from both sides.

# Python

Python holds a special place in my heart as its the first programming language I learned. I learned Python by watching videos from [Corey Shafer](https://www.youtube.com/c/Coreyms "https://www.youtube.com/c/Coreyms"), reading Dan Bader's book, [Python Tricks](https://realpython.com/products/python-tricks-book/ "https://realpython.com/products/python-tricks-book/"), and most importantly, writing a lot of code. I learned programming fundamentals in Python, and I relearned how to write clean code in Python, as well.

**I have worked with** _**Python**_ **in the following capacity:**
-   I have used Python to write code in Production. Some of the libraries I leveraged were Pandas, NumPy, JSON, Requests, and Logging.
-   I have used Python for ETL, data engineering, monitoring, general scripting, automation, releases, and many other ways.

**I know** _**Python**_ **to the following level:**
-   I understand the core fundamentals of Python and utilize them to write simple, clean, and efficient code.
-   I can easily express my ideas in Python without having to refer to external resources (AKA Google).

**This is how I would like to continue my growth and understanding of** _**Python:**_
-   I love to write a library in C and utilize it in my Python code.
-   I would love to contribute to an open-source library like Pandas or Request.

# C++

Although Python was the first language I learned to program in, applications written in C++ were the first that I ever supported. I was exposed to C++ as an SRE, and I learned to configure the application for maximum performance and minimal latency. After learning Python I spent many months [learning C++](https://www.youtube.com/c/TheChernoProject "https://www.youtube.com/c/TheChernoProject"), and after a long road, I can proudly say I can comfortably write code in C++.

Learning C++ as a developer and an operation engineer really opened my eyes to the intricacies and depth of application development. I was exposed to so many new concepts, both from a programmatic perspective and from a functional perspective.

**I have worked with** _**C++**_ **in the following capacity:**
-   I have supported, configured, monitored, deployed, optimized, and tested low-latency trading applications written in C++.
-   I have written C++ code in a controlled environment to ensure I understand its core fundamentals and vast features.

**I know** _**C++**_ **to the following level:**
-   I understand the dependencies, features, components, and use cases of C++.
-   I can write code in C++, leverage a make file for compilation, and test my application for efficiency and performance.

**This is how I would like to continue my growth and understanding of** _**C++:**_
-   I would love the opportunity to write C++ code in production.
-   I would like to utilize popular C++ libraries in my code (STL, POCO, Boost, etc).

# C

I often find people categorizing C++ and C  but only talking about C++. C deserves its own recognition. In fact, I prefer C over C++. I often find myself (and others) writing unnecessarily complex code in C++ that can be written more simply by leveraging C.

After learning C++, I decided to learn C thinking it would “be the same thing.” I was pleasantly surprised when it wasn’t. I thoroughly enjoy the design of C and its implementation, and I wish more people wrote C code in C++  and only used objects and templates where needed.

C’s simplicity is what makes it stand out to me and millions of other developers. It is no surprise that this easy-to-use language was utilized to build the world's most powerful operating system.

**I have worked with** _**C**_ **in the following capacity:**
-   I have spent many hours reading Linux Kernel Code in C and tinkering with it. By playing around with the kernel, I was able to learn more about Linux and C together (two things that I love).
-   I have written C code in a controlled environment to ensure I understand its core fundamentals and vast features.
-   I learned coding best practices when learning C, and I learned to write clean, simple code because of it.

**I know** _**C**_ **to the following level:**
-   I understand the ideologies and best practices of C and learned to keep my code simple in other languages because of it.
-   I can write code in C, leverage a make file for compilation, and test my application for efficiency and performance.
    
**This is how I would like to continue my growth and understanding of** _**C:**_
-   It is a career goal of mine to contribute  _meaningful_ code to the Linux Kernel.
-   I would love to write a library in C and utilize it in Python.
-   I would like the opportunity to write production-level applications in C.

# Bash

Good old Bash, thank you for saving us all countless hours. Although it is not considered a programming language, Bash has saved programmers lots of time. I have used Bash in many ways, and I am  grateful for its existence.

**I have worked with** _**Bash**_ **in the following capacity:**
-   I have written hundreds of scripts in Bash for basic tasks, validation, and deployment.
-   I have worked with complex Bash scripts written internally and by the open-source community.

**I know** _**Bash**_ **to the following level:**
-   I can write Bash code with relative ease (I still need Google).
-   I am aware of hidden features and certain gotcha’s.

**This is how I would like to continue my growth and understanding of** _**Bash:**_
-   I simply want to keep using this powerful tool to make my life easier.

# Lua

Lua is a gem hidden deep within the glorious application known as NGINX and sometimes goes unnoticed. I have utilized Lua to write powerful extensions within NGINX and custom functionality where needed. As someone who has spent many years working with NGINX, I wish Lua got more attention. Lua is a robust programming language with a direct integration to NGINX that could help a lot of DevOps engineers.

**I have worked with** _**Lua**_ **in the following capacity:**
-   I have written a few Lua scripts to add custom functionality within NGINX.

**I know** _**Lua**_ **to the following level:**
-   I know the basic features of LUA and process the knowledge to use those basic features to make NGINX more robust.

**This is how I would like to continue my growth and understanding of** _**Lua:**_
-   Like Bash, I simply want to keep using this powerful language to make my life easier.

# GO

Go is a new language for me, and one that I am enjoying thoroughly. As someone who enjoys the complexity of low-level applications and languages, yet likes the simple syntax of high-level languages, Go was a must learn. Through books and simple practice, I have been learning Go and learning the best practices of the language.

Although I am new to Go, I can see myself working as a Go developer in the future. There are lots of features and concepts within Go that I am a fan of. In the coming weeks and months, I will be focused on learning Go, and the information in the coming section will more than likely  need to be updated.

**I have worked with** _**Go**_ **in the following capacity:**
-   I have written a few basic programs and applications in Go to understand its basic functionality.
-   I have utilized applications in Go such as Terraform and understand them at a deep level. This understanding gives me some insight into the capabilities and functionalities of Go.

**I know** _**Go**_ **to the following level:**
-   I understand _some_ best practices within Go, as well as the general concepts within the language.
-   I know enough about Go to appreciate its wide set of features and use cases.

**This is how I would like to continue my growth and understanding of** _**Go:**_
-   I will be spending plenty of time in the coming weeks to learn Go as well as I know Python, C, and C++.
-   I would like the opportunity to write production-level code in Go down the road.