---
layout: post
title:  "CSS 1일차"
---





```c++
CSS는 CASCADING STYLE SHEETS로 HTML을 꾸며주는 언어이다.




CSS문법
h1{color: yellow; font-size: 2em;}
여기서 h1은 선택자
color과 font-size는 속성
yellow와 2em은 값
color: yellow와 font-size: 2em는 각각 선언
color: yellow; font-size: 2em; 전체는 선언부
h1{color: yellow; font-size: 2em;} 전체는 규칙이라고 부른다.






주석은 /* 내용 */ 이다.





CSS 문법   
Inline : <p style="color: gray;">Hello, CSS</p>
Internal : <style>
        p { color: gray; }
    </style> 
<style>태그는 <head>태그에 들어간다. 
External : <link rel="stylesheet" href="css/style.css">
link태그는 <head>태그에 들어가야 하며 
css/style.css여기 링크에 미리 p { color: gray; } 이런식으로 작성을 해놔야 한다. 그리고 연결시키는 것이다.
rel속성은 css파일과 연결할때는 stylesheet라고 적어주면 된다.






선택자
요소 선택자
ex) h1 { color: yellow; } 이런식으로 태그에 이름이 들어간다.

그룹화가 가능하다.
ex) h1, h2, h3, h4, h5, h6 { color: yellow; }

전체 선택자 
ex) * { color: yellow; } 편리하지만 성능에 좋지 않아 사용을 지양한다.

선언들도 그룹화가 가능하다
ex) h1 { color: yellow; font-size: 2em; background-color: gray; }

선택자와 선언이 동시에 그룹화가 가능하다
ex) h1, h2, h3, h4, h5, h6 { color: yellow; font-size: 2em; background-color: gray; }





<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>css</title>
    <style>
        .html { color: purple; }
        .css { text-decoration: underline; }
        #id-selector { font-size : 30px; }
    </style>
  </head>
  <body>
    <dl>
        <dt class="html">HTML</dt>
        <dd><span class="html">HTML</span>은 문서의 구조를 나타냅니다.</dd>
        <dt class="css">CSS</dt>
        <dd><span class="css">CSS</span>는 문서의 표현을 나타냅니다.</dd>
        <dt class="html css">JS</dt>
        <dd><span class="html css">JS</span>는 문서의 동작을 나타냅니다.</dd>
    </dl>
    <p id="id-selector">id 선택자는 해쉬 기호를 사용합니다</p>
  </body>
</html> 

HTML의 dt에 스타일을 적용하게 되면 밑에 있는 CSS에도 같이 적용되고
CSS의 span에 스타일을 적용하게 되면 위에 있는 HTML에도 같이 적용된다.
이럴때 class선택자를 사용하는 것이다.
ex) .foo { font-size: 30px; }  <p class="foo"> ... </p>

다중 class도 가능하다
ex) .foo { font-size: 30px; } .bar { color: blue; } <p class="foo bar"> ... </p>

id선택자
ex) #bar { background-color: yellow; } <p id="bar"> ... </p>
class 선택자와의 차이점
1. .기호가 아닌 #기호 사용
2. 태그의 class 속성이 아닌 id 속성을 참조
3. 문서 내에 유일한 요소에 사용
4. 구체성





선택자의 조합
1. 요소와 class의 조합 
p.bar { ... }
2. 다중 class 
.foo.bar { ... }
ex) .html.css { border: 1px solid; } 이렇게 하면 
<dt class="html css">JS</dt>  <dd><span class="html css">JS</span>는 문서의 동작을 나타냅니다.</dd>
JS들에게 적용된다.
3. id와 class의 조합
#foo.bar { ... }




<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>css</title>
    <style>
        p[class] { color: silver; }
        p[class][id] { text-decoration: underline; }
    </style>
  </head>
  <body>
    <p class="foo">Hello</p>
    <p class="bar">CSS</p>
    <p class="baz" id="title">HTML</p>
  </body>
</html> 

p[class] { color: silver; }는 3개 다 적용이 될 것이다.
p[class][id] { text-decoration: underline; } 이것은 p요소이면서 class 속성도 있고 id 속성도 있어야 한다.





정확한 속성값으로 선택
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>css</title>
    <style>
        p[class="foo"] { color: silver; }
        p[id="title"] { text-decoration: underline; }
    </style>
  </head>
  <body>
    <p class="foo">Hello</p>
    <p class="bar">CSS</p>
    <p class="baz" id="title">HTML</p>
  </body>
</html> 




부분 속성값으로 선택

p[class~="color"] { font-style: italic; }
p[class^="color"] { font-style: italic; }
p[class$="color"] { font-style: italic; }
p[class*="color"] { font-style: italic; }


<p class="color hot">red</p> 1, 2, 4
<p class="cool color">blue</p> 1, 3, 4
<p class="colorful nature">rainbow</p> 2, 4


[class~="bar"] : class 속성의 값이 공백으로 구분한 "bar" 단어가 포함되는 요소 선택
[class^="bar"] : class 속성의 값이 "bar"로 시작하는 요소 선택
[class$="bar"] : class 속성의 값이 "bar"로 끝나는 요소 선택
[class*="bar"] : class 속성의 값이 "bar" 문자가 포함되는 요소 선택





<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>css</title>
    <style>

    </style>
  </head>
  <body>
    <div>
        <h1><span>HTML</span>: Hyper Text Markup Language</h1>
        <span>CSS는 문서를 꾸며줍니다.</span>
    </div>
    <span>Javascript는 문서를 동적으로 제어할 수 있습니다.</span>
    <p>HTML과 CSS와 JAVASCRIPT를 이용해서 멋진 웹 사이트를 제작할 수 있습니다.</p>
  </body>
</html> 

자손 선택자(자식, 부모도 포함) div span { clolr: red; } div의 자손 요소인 span을 선택하는 선택자
ex)
<div>
   <h1><span>HTML</span>: Hyper Text Markup Language</h1>
   <span>CSS는 문서를 꾸며줍니다.</span>
</div>
HTML / CSS는 문서를 꾸며줍니다. 이것에 적용된다.

자식 선택자 div > span { clolr: red; }
ex)
<span>CSS는 문서를 꾸며줍니다.</span>
CSS는 문서를 꾸며줍니다.에 적용된다.

인접 형제 선택자 div + span { color: red; } ( 바로 뒤에 오는 형제 )
ex)
<span>Javascript는 문서를 동적으로 제어할 수 있습니다.</span>
Javascript는 문서를 동적으로 제어할 수 있습니다.에 적용된다.

body > div table + ul { ... } 는 body의 자식 요소인 div의 자손 요소인 table의 인접 형제 요소 ul을 말한다.







가상 선택자 : 미리 정의해놓은 상황에 적용이 되도록 약속되어있는 보이지 않는 클래스   
우리가 직접 요소에 클래스를 선언하는 것은 아니고, 약속된 상황이 되면 브라우저 스스로 클래스를 적용해준다.

문서 구조와 관련된 가상 클래스
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>css</title>
    <style>
        li:first-child { color: red; }
        li:last-child { color: blue; }
    </style>
  </head>
  <body>
    <ul>
        <li>HTML</li>
        <li>CSS</li>
        <li>JS</li>
    </ul>
  </body>
</html> 

위의 코드를 실행하면 HTML은 빨간색으로 JS는 파란색으로 나온다.




앵커 요소와 관련된 가상 클래스
:link : 하이퍼링크이면서 아직 방문하지 않은 앵커
:visited : 이미 방문한 하이퍼링크를 의

<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>css</title>
    <style>
        a:link { color: blue; }
        a:visited { color: gray; }
    </style>
  </head>
  <body>
    <a href="http://naver.com/">네이버</a>
    <a href="http://google.com/">구글</a>
    <a href="http://daum.net/">다음</a>
  </body>
</html> 

이 코드를 실행하면 방문하지 않은 사이트의 이름은 파란색 방문한 사이트의 이름은 회색으로 나온다.





사용자 동작 관련 가상 클래스
:focus: 현재 입력 초점을 가진 요소에 적용
:hover: 마우스 포인터가 있는 요소에 적용
:active: 사용자 입력으로 활성화된 요소에 적용

<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>css</title>
    <style>
        a:focus { background-color: yellow; }
        a:hover { font-weight: bold; }
        a:active { color: red; }
    </style>
  </head>
  <body>
    <a href="http://naver.com/">네이버</a>
    <a href="http://google.com/">구글</a>
    <a href="http://daum.net/">다음</a>
  </body>
</html> 





가상 요소 : 미리 정의해놓은 위치에 삽입이 되도록 약속되어있는 보이지 않는 요소

:before : 가장 앞에 요소를 삽입
:after : 가장 뒤에 요소를 삽입
:first-line : 요소의 첫 번째 줄에 있는 텍스트
:first-letter : 블록 레벨 요소의 첫 번째 문자


<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>css</title>
    <style>
        p:before{
            color: red;
            content: "before 가상 요소를 활용한 내용"
        }
        p:after{
            color: blue;
            content: "after 가상 요소를 활용한 내용"
        }
    </style>
  </head>
  <body>
    <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, 
    sed do eiusmod tempor incididunt ut 
    labore et dolore magna aliqua.</p>
  </body>
</html> 

이 코드를 실행하면 맨 앞에 빨간 글씨로 content안에 있는 내용이 생기고 맨 뒤에 파란 글씨로 content안에 있는 내용이 생긴다.

p:first-line { color: yellow; } 를 하면 브라우저 기준 첫번째 줄이 노란색이 된다.
p:first-letter { font-size: 3em; }을 하면 첫 글자 하나의 크기가 3em으로 바뀐다.







구체성 : 선택자를 얼마나 명시적으로 선언했느냐를 수치화 한 것 
구체성은 0, 0, 0, 0 이렇게 4개의 숫자 값으로 이루어져 있다.
값을 비교할 때는 좌측에 있는 값부터 비교하며, 좌측 부분의 숫자가 클수록 높은 구체성을 갖는다.

 0, 1, 0, 0 : 선택자에 있는 모든 id 속성값
 0, 0, 1, 0 : 선택자에 있는 모든 class 속성값, 기타 속성, 가상 클래스
 0, 0, 0, 1 : 선택자에 있는 모든 요소, 가상 요소
 전체 선택자는 0, 0, 0, 0을 가진다.
 조합자는 구체성에 영향을 주지 않는다. (>, + 등)
 
h1 { ... }  0, 0, 0, 1
body h1 { ... } 0, 0, 0, 2
.grape { ... }  0, 0, 1, 0
*.bright { ... } 0, 0, 1, 0
p.bright em.dark { ... } 0, 0, 2, 2
#page { ... } 0, 1, 0, 0
div#page { ... } 0, 1, 0, 1

p#page { color: red; } 0, 1, 0, 1
<p id="page" style="color:blue">Lorem impusm dolor sit.</p> 1, 0, 0, 0
인라인 스타일의 구체성 값은 1, 0, 0, 0 이다. 따라서 아래가 적용된다.

p#page { color: red !important; }
<p id="page" style="color:blue">Lorem impusm dolor sit.</p>
important키워드는 !important 이렇게 사용하며 별도의 구체성 값은 없지만, 모든 구체성을 무시하고 우선권을 갖는다.
따라서 위에 것이 적용된다.






상속
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>css</title>
    <style>
        h1 { color: gray; }
    </style>
  </head>
  <body>
    <h1>Hello, <em>CSS</em></h1>
  </body>
</html> 

이렇게 하면 Hello, CSS 모두 회색으로 나온다.
margin, padding, background, border 등 박스 모델 속성들은 상속되지 않는다


<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>css</title>
    <style>
        * { color: red; }
        h1#page { color: gray; }
    </style>
  </head>
  <body>
    <h1 id="page">Hello, <em>CSS</em></h1>
  </body>
</html> 

이것을 하면 Hello는 회색으로 CSS는 빨간색으로 나온다.
* { color: red; } 0, 0, 0, 0
h1#page { color: gray; } 0, 1, 0, 1
상속된 값은 아무런 구체성을 가지지 않으며 심지어 0, 0, 0, 0도 아니다.
전체 선택자가 없었다면 어떠한 선택자와 겹치지 않아서 아무런 구체성이 없어도 회색으로 나왔을 것이다.






케스케이딩 : 모든 스타일의 규칙들이 어떤 기준으로 어떤 방식으로 문서에 적용되는지 정하는 방식
케스케이드 규칙
1. 중요도(!important) & 출처
기본적으로 !important로 선언된 모든 규칙은 그렇지 않은 규칙보다 우선한다.
출처는 제작자, 사용자, 사용자 에이전트로 구분한다. 

우선순위
1. 사용자 !important 스타일 ( 잘 사용하지 않음 )
2. 제작자 !important 스타일
3. 제작자 스타일 ( 사이트 제작자가 작성한 css )
4. 사용자 스타일 ( 요즘 잘 사용하지 않음 )
5. 사용자 에이전트 스타일 ( 브라우저에서 기본적으로 제공하는 스타일)

2. 구체성 

3. 선언순서
나중에 선언된 것이 더 우선하게 된다. 

만약 구체성이 같은 두 규칙이 동일한 요소에 적용된다면 어떻게 될까?
ex)
h1 { color: red; }
h1 { color: blue; }
파란색으로 적용된다.

```
