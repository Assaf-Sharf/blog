---
title: "Authentication with Http4s Part 2"
date: 2023-02-23
header:
  image: "/images/blog cover.jpg"
tags: []
excerpt: "This is part 2 of the authentication methods covered previously."
toc: true
toc_label: "In this article"
---

# 1. Introduction

This article is a continuation of the authentication methods that were covered in [part1]("#"). Here we will cover two more advanced authentication methods which include One Time Password(OTP) and Two Factor Authentication (2FA).

## 1.1 Requirements.

To follow along with this tutorial, you will need to add the following to your build.sbt file.

```scala
val scala3Version = "3.2.2"

val Http4sVersion = "0.23.18"
val PencilVersion = "1.2.0"
val OtpJavaVersion = "2.0.1"
val ZxingVersion = "3.5.1"

val http4sDsl =       "org.http4s"                  %% "http4s-dsl"          % Http4sVersion
val emberServer =     "org.http4s"                  %% "http4s-ember-server" % Http4sVersion
val otpJava =         "com.github.bastiaanjansen"    % "otp-java"            % OtpJavaVersion
val pencil =          "com.minosiants"              %% "pencil"              % PencilVersion
val zxing =           "com.google.zxing"           % "javase"              % ZxingVersion

lazy val authentication = project
  .in(file("authentication"))
  .settings(
    name := "authentication",
    version := "0.1.0-SNAPSHOT",
    scalaVersion := scala3Version,
    libraryDependencies ++= Seq(
      emberServer,
      http4sDsl,
      otpJava,
      pencil,
      zxing
    )
  )
```

# 2. One Time Password (OTP)

A One Time Password is a form of authentication that is used to grant access to a single login session or transaction. Here's how it works.

1. When a user tries to perform a transaction or action on a system, he or she will present some credentials like an email or a phone number.
1. The system will send a temporary secure PIN-code or token to the user by email or phone number valid for only that session.
1. When the PIN-code is presented to the system and verified, access will be granted to the user.

The One Time Password authentication method is defined in the [RFC 2289]("#") internet standard which provides a detailed explanation of how OTP is implemented.

OTP tokens can either be generated by a software application running on a computer or phone, however, they can also be generated using hardware and there is a wide array of devices on the market providing this functionality.

There are a variety of industry-standard algorithms that are used to generate OTP tokens such as SHA1, however, they require two inputs, a static value known as a secret key and a moving factor which changes each time an OTP value is generated. There a two main types of OTP tokens namely HOTP (HMAC-based One Time Password) and TOTP (Time-based One Time Password).

## 2.1 HMAC-based One Time Password (HOTP)

The `H` in HOTP stands for HMAC (Hash-based Message Authentication Code). This is a cryptographic technique that requires a hash function such as SHA1 and a set of parameters (secret key, moving factor). Under HOTP, the moving factor is based on a counter.
Each time a user requests for the HOTP, the counter is incremented. When the server receives the HOTP, it also increments its counter after validating the token, thereby keeping in sync with the OTP generator.
It is possible to generate many HOTP tokens without validating with the server, this throws the two entities out of sync. Because of this, different HOTP generators provide different methods for resynchronization.
The HOTP standard is defined under [RFC 4226]("#") which gives a detailed explanation of how HOTP operates.

### 2.1.0 HOTP scala implementation

To implement HOTP in Scala, we will use the [otp-java]("#") library by Bastiaan Jansen.
First, we'll need to acquire a secret key. The library provides a mechanism to generate this.

```scala
import com.bastiaanjansen.otp.*

val secret = SecretGenerator.generate()
```

Next, we will use the builder to generate an HOTP instance.

```scala
val hotp = new HOTPGenerator.Builder(secret)
              .withPasswordLength(6)
              .withAlgorithm(HMACAlgorithm.SHA1)
              .build()
```

Here instantiate a new `HOTPGenerator` class, pass it the `secret`, password length, and algorithm type, `SHA1`. We can now use `hotp` to generate the code.

```scala
val counter = 5
val code = hotp.generate(counter)
```

In the above code, we initialized the counter to 5 and used that the generate the `hotp` code.

When the server receives this code, it can verify it in the following way.

```scala
val isValid = hotp.verify(code, counter)
```

Remember the client and server must keep their counters in sync for the verification phase to work otherwise resynchronization is needed.

## 2.2 Time-based One Time Password (TOTP)

The TOTP token is generated similarly to HOTP with the main difference being the moving factor. Here the moving factor is based on a time counter. The time counter is calculated by dividing the current Unix time by a timestep value which is the life span of a TOTP usually 30 seconds.

### 2.2.0 TOTP scala implementation

Otp-java also provides an implementation for TOTP token generation.

```scala
import java.time.Duration

val secret = SecretGenerator.generate()

val totp = new TOTPGenerator.Builder(secret)
    .withHOTPGenerator(builder => {
            builder.withPasswordLength(6)
            builder.withAlgorithm(HMACAlgorithm.SHA1)
    })
    .withPeriod(Duration.ofSeconds(30))
    .build()
```

Here the `TOTPGenerator` class is instantiated with a `secret`, the `withHOTPGenerator()` method provides a `builder` that we use to set the password length and algorithm type. The last method is `withPeriod()` where we set the duration to 30 seconds, this is also the timestep, which sets the lifespan for each `TOTP`.

```scala
val codeValue = totp.now()
```

The `now()` method on the `TOTPGenerator` class is used to generate the token.
In order to verify totp tokens, we use also use the `verify()` method.

```scala
totp.verify(code)
```

# 3. Two Factor Authentication (2FA)

Two Factor Authentication is an authentication method that requires a user to provide two distinct forms of identification to access a website or resource. Here's how it works
a. Imagine a user is trying to access imgbank.com. imgbank.com will require the user to sign in with his or her username and password.
b. Once the username and password have been verified by imgbank.com, it alerts the user that it has sent a code or token to his or her email and presents a form for code input.
c. When the user checks his or her email and inputs the correct code into the form, imgbank.com will grant access to the user.

The code or token is the One Time Password that we generated in the previous sections

## 3.1 2FA implementation in scala

In this section, we will create a small application to showcase 2FA using java-otp, http4s, pencil, google zxing, and google authenticator.

### 3.1.0 Handling User Information

Let's create a case class to hold the user's information.

```scala
case class User(username: String, email: String, password: String, counter: Long)
```

Notice that we've added `counter` to keep track of the counter value used in `HOTP`. Next we will create a trait to manage the database

```scala
import scala.collection.mutable

trait MyDatabase:
    val database: mutable.Map[Int, User] = mutable.Map(1 -> User("johnDoe", "john@email.com", "password", 0))
    def getCounterValue (database: mutable.Map[Int, User]): Long =
        database(1).counter

    def incrementCounter (database: mutable.Map[Int, User]) =
        database.update(1, User(database(1).username, database(1).email, database(1).password, database(1).counter + 1))
end MyDatabase
```

The `MyDatabase` trait contains our `database` which is a mutable Map of type `mutable.Map[Int, User]` and two functions. The `getCounterValue()` function gets the counter value from our user while the `incrementCounter()` will increment the counter value by one after we successfully verify a One Time Password.

### 3.1.1 Creating the BarCodeService

Google Authenticator gives us two options to capture the OTP code, we can type it manually or scan a bar code. In this section, we will use the Google Zxing library to create a barcode image in our application.

```scala
import scala.util.Try
import java.net.URLEncoder
import com.google.zxing.common.BitMatrix
import com.google.zxing.MultiFormatWriter
import com.google.zxing.BarcodeFormat
import java.io.FileOutputStream
import com.google.zxing.client.j2se.MatrixToImageWriter

trait BarCodeService extends MyDatabase:
    def getGoogleAuthenticatorBarCode(secretKey: String, account: String, issuer: String, generator: String): Try[String] =
        generator match
            case "Hotp" =>
                Try{
                s"otpauth://${generator.toLowerCase()}/" +
                URLEncoder.encode(issuer + ":" + account, "UTF-8").replace("+","%20") +
                "?secret=" + URLEncoder.encode(secretKey, "UTF-8").replace("+","%20") +
                "&issuer=" + URLEncoder.encode(issuer, "UTF-8").replace("+","%20") +
                "&conter=0"
                }
            case "Totp" =>
                Try{
                    s"otpauth://${generator.toLowerCase()}/" +
                    URLEncoder.encode(issuer + ":" + account, "UTF-8").replace("+","%20") +
                    "?secret=" + URLEncoder.encode(secretKey, "UTF-8").replace("+","%20") +
                    "&issuer=" + URLEncoder.encode(issuer, "UTF-8").replace("+","%20")
                }

    def createQRCode(barCodeData: String, filePath: String, height: Int, width: Int) =
        val matrix: BitMatrix = new MultiFormatWriter().encode(barCodeData, BarcodeFormat.QR_CODE, width, height)
        val outVal: FileOutputStream = new FileOutputStream(filePath)
        MatrixToImageWriter.writeToStream(matrix,"png",outVal)
end BarCodeService
```

The `BarCodeService` trait has two methods. The `getGoogleAuthenticatorBarCode()` method takes a `secretKey` which we will create with `otp-java`, an `account` and `issuer` which are the email address and name of the business or person issuing the barcode, and lastly, a `generator` which is a string of `Hotp` or `Totp` (used to choose the type of `otp`). This function creates a `URI` in the format `otpauth://TYPE/LABEL?PARAMETERS` that we'll use to create the QR Bar Code. For the `Hotp` implementation, we added a `counter=0` as an extra parameter.

The `createQRCode()` function creates the BarCode. It takes as parameters, `barCodeData` which is our `URI`, a `filePath`, and `height` and `width` of our image. The `MultiFormatWriter` class has an encode method that takes our arguments and creates a 2D matrix of bits.
The `writeToStream` method on the `MatrixToImageWriter` object takes the `matrix`, `"png"` as the image format and a `FileOutputStream`. This method writes the image to a png file and saves it to the file path.

### 3.1.2 Creating the OtpService

This service is what will house our logic for One Time Passwords

```scala
import com.bastiaanjansen.otp.*
import java.time.Duration
import scala.util.Success
import scala.util.Failure

class OtpService(generator: String) extends MyDatabase with BarCodeService:
    private val secret: Array[Byte] = SecretGenerator.generate()

    enum Generator:
        case Hotp, Totp

        def getHotp: HOTPGenerator = new HOTPGenerator.Builder(secret)
            .withPasswordLength(6)
            .withAlgorithm(HMACAlgorithm.SHA1)
            .build()

        def getTotp: TOTPGenerator = new TOTPGenerator.Builder(secret)
            .withHOTPGenerator(builder => {
                    builder.withPasswordLength(6)
                    builder.withAlgorithm(HMACAlgorithm.SHA1)
            })
            .withPeriod(Duration.ofSeconds(30))
            .build()
    end Generator

    def getToken(generator: String): String = Generator.valueOf(generator) match
        case Generator.Hotp => Generator.Hotp.getHotp.generate(getCounterValue(database))
        case Generator.Totp => Generator.Totp.getTotp.now()

    private def verifyUtility (value: Try[Boolean], database: mutable.Map[Int, User] = database): String =
        value match
            case Success(v) =>
                v match
                    case true =>
                        incrementCounter(database)
                        s"Code Verified?: $v"
                    case false =>
                        s"Code Verified?: $v"
            case Failure(exception) =>
                exception.getMessage()

    def verifyCode(code: String, generator: String = generator, database: mutable.Map[Int, User] = database): String =
        Generator.valueOf(generator) match
            case Generator.Hotp =>
                verifyUtility(Try{Generator
                    .Hotp
                    .getHotp
                    .verify(code, getCounterValue(database))})
            case Generator.Totp =>
                verifyUtility(Try{Generator
                    .Totp
                    .getTotp
                    .verify(code)})

    val barCodeUrl = getGoogleAuthenticatorBarCode(new String(secret), "karlsambade@gmail.com","karl", generator)
end OtpService
```

The OtpService contains a secret value which we generate using `otp-java`
The `Generator` enum is what we use to choose between `Hotp` and `Totp` depending on our needs, it also contains two methods, getHotp, and getTotp used to generate `HOTPGenerator` and `TOTPGenerator` instances respectfully.

The `getToken()` function takes a string and passes it to the `Generator.valeOf` enum method, this will yield either a `Hotp` or `Totp` Generator case which we pattern match on to give us a token. Note that in order to use Google Authenticator, we password length of 6 and an algorithm of `SHA1`. We supply these same values as we generate the `HOTPGenerator` and `TOTPGenerator` instances.

The `verifyCode()` function is used to check if the code the user passes is genuine. It takes a `code` (the otp token), a generator (either `Hotp` or `Totp`, this value is passed from the OtpService constructor.), and a `database` (This value comes from `MyDatabase`) as arguments. Again we pattern match on `Generator.valueOf(generator)` and use the `verifyUtility()` to complete the verification process. The `verifyUtility()` takes a `Try[Boolean]` and `database` as arguments. It matches against the result of the `verify()` function of which we have two impelmentations, `HOTPGenerator` and `TOTPGenerator` defined on following lines.

```scala
Try{Generator
  .Hotp
  .getHotp
  .verify(code, getCounterValue(database))}
```

and

```scala
Try{Generator
  .Totp
  .getTotp
  .verify(code)}
```

Finally `barCodeUrl` generates a `Try[String]` which contains our authentication `URI`.

### 3.1.3 Creating our EmailService

For this section we will use `pencil` which is an smtp client to send an email with the barcode to our user.

```scala
import com.minosiants.pencil.data.{Email,Body,Credentials,Username,Password}
import com.minosiants.pencil.{from,to,subject,attachment}
import com.minosiants.pencil.Client
import org.typelevel.log4cats.slf4j.Slf4jLogger
import fs2.io.net.Network
import com.minosiants.pencil.protocol.Replies
import com.comcast.ip4s.SocketAddress
import com.comcast.ip4s.*
import org.http4s.dsl.io.*

class EmailService(token: String):
  val message = s"""
      |<H3>Website Login</H3>
      |<p>Please complete the login process using google authenticator</p>
      |<p>You can either manually enter the code or scan the QR code below </p>
      |<p>Code: $token </p>
      |<p>The QR Code image attached to this email.</p>
      """
  val email = Email.mime(
      from"karlsambade@gmail.com",
      to"karlsambade@gmail.com",
      subject"complete login",
      Body.Html(message)
  )

  val logger = Slf4jLogger.getLogger[IO]

  val credentials = Credentials(
      Username("karlsambade@gmail.com"),
      Password("password")
  )

  val action: IO[Replies] =
      for
          tls <- Network[IO].tlsContext.system
          client = Client[IO](SocketAddress(host"smtp.gmail.com", port"587"), Some(credentials))(tls,logger)
          response <- client.send(email)
      yield response

  def sendEmail = action.attempt.flatMap{
                      case Right(replies) => Ok(s"Recieve a reply: $replies")
                      case Left(error) => Ok(s"Recieved an Error: ${error.getMessage}")
                          }
end EmailService
```

The `EmailService` class takes a string, `token` as a constructor argument and passes it to the `message` variable which informs the user of the second authentication process.

We use the `Email` object from pencil to create our email. It contains a `mime()` method to which we supply our `email`, the email `to` which we are sending, the `subject`, and the message body. In our case, we are using `Body.Html(message)` since our message is in `HTML` format.

Pencil provides `Username` and `Password` case classes, which we can use to structure our `Credentials` (case class also supplied by pencil).
The pencil `Client` takes a `host`, `port` number, `Credentials`, `tlsContext`, and a `logger`. Depending on your email server these values will change. For this application, we use Gmail. To send the email we call `send()` from the `Client` and pass it `email`.

We run `attempt()` on `action` which gives us an `IO[Either[Throwable, Replies]]` which we process to give a `String` containing either a `reply` or an `error` message in case the email failed to send.

### 3.1.4 Creating our FinalService

```scala
class FinalService(generator: String):
    val otpService = new OtpService(generator)
    val emailService = new EmailService(otpService.getToken(generator))
end FinalService
```

The `FinalService` class will help us instantiate our `OtpService` and `EmailService` services with the appropriate constructor argument.

### 3.1.5 Http4s Routes and Server

In this section, we create the routes and server using http4s.

```scala
import org.http4s.*

val tokenService = new FinalService("Hotp")

val routes: HttpRoutes[IO] =
    HttpRoutes.of[IO]{
        case GET -> Root / "login" =>
            tokenService.otpService.barCodeUrl match
                case Success(burl) =>
                    IO{tokenService.otpService.createQRCode(burl, "barCode.png", 400, 400)} >>
                    tokenService.emailService.sendEmail
                case Failure(_) =>
                    Ok("Error occurred generating QR Code...")
        case GET -> Root / "code" / value =>
            Ok(s"${tokenService.otpService.verifyCode(value)}")
    }
```

`tokenService` is a new instance of `FinalService` to which we passed `Hotp` as a constructor argument.
We create our routes using the `HttpRoutes.of[IO]` function. For this application, we are using two routes, `/login` to receive our code and barcode image and `/code/value` that we will use to pass our code for verification.

When processing a request through the `/login` route, we acquire our `barCodeUrl` by running `tokenService.otpService.barCodeUrl`, this will give us a `Try[String]` which we pattern match on. If we successfully generated the barcode `URL`, we create the bar code by running `tokenService.otpService.createQRCode(burl, "barCode.png", 400, 400)` and send our email, `tokenService.emailService.sendEmail`, other wise we reply with an error message, `Error occurred generating QR Code...`.

When the user receives the code and passes it to `/code/value`, we verify it by running `tokenService.otpService.verifyCode(value)` which yields a string `s"Code Verified?: $v"` ($v is a boolean value) or an error message in case of failure.

```scala
import org.http4s.ember.server.EmberServerBuilder

val server = EmberServerBuilder
    .default[IO]
    .withHost(ipv4"0.0.0.0")
    .withPort(port"8080")
    .withHttpApp(routes.orNotFound)
    .build

override def run(args: List[String]): IO[ExitCode] =  server.use(_ => IO.never).as(ExitCode.Success)
```

Finally can run our server.

Let's test our application

```bash
curl -vv localhost:8080/login
```

```bash
curl -vv localhost:8080/code/123456
```

Here is the full code.

```scala
import cats.effect.{IOApp, IO, ExitCode}
import org.http4s.*
import org.http4s.dsl.io.*
import com.comcast.ip4s.*
import com.bastiaanjansen.otp.*
import scala.util.Try
import scala.util.Success
import scala.util.Failure
import java.time.Duration
import java.net.URLEncoder
import com.google.zxing.common.BitMatrix
import com.google.zxing.MultiFormatWriter
import com.google.zxing.BarcodeFormat
import java.io.FileOutputStream
import com.google.zxing.client.j2se.MatrixToImageWriter
import com.minosiants.pencil.data.{Email,Body,Credentials,Username,Password}
import com.minosiants.pencil.{from,to,subject,attachment}
import com.minosiants.pencil.Client
import org.typelevel.log4cats.slf4j.Slf4jLogger
import fs2.io.net.Network
import com.minosiants.pencil.protocol.Replies
import com.comcast.ip4s.SocketAddress
import scala.collection.mutable
import org.http4s.ember.server.EmberServerBuilder

object OtpAuth extends IOApp:
    case class User(username: String, email: String, password: String, counter: Long)

    trait MyDatabase:
        val database: mutable.Map[Int, User] = mutable.Map(1 -> User("johnDoe", "john@email.com", "password", 1))
        def getCounterValue (database: mutable.Map[Int, User]): Long =
            database(1).counter

        def incrementCounter (database: mutable.Map[Int, User]) =
            val counter: Long = database(1).counter + 1
            database.update(1, User(database(1).username, database(1).email, database(1).password, counter))
    end MyDatabase

    trait BarCodeService extends MyDatabase:
        def getGoogleAuthenticatorBarCode(secretKey: String, account: String, issuer: String, generator: String): Try[String] =
            generator match
                case "Hotp" =>
                    Try{
                    s"otpauth://${generator.toLowerCase()}/" +
                    URLEncoder.encode(issuer + ":" + account, "UTF-8").replace("+","%20") +
                    "?secret=" + URLEncoder.encode(secretKey, "UTF-8").replace("+","%20") +
                    "&issuer=" + URLEncoder.encode(issuer, "UTF-8").replace("+","%20") +
                    "&conter=0"
                    }
                case "Totp" =>
                    Try{
                        s"otpauth://${generator.toLowerCase()}/" +
                        URLEncoder.encode(issuer + ":" + account, "UTF-8").replace("+","%20") +
                        "?secret=" + URLEncoder.encode(secretKey, "UTF-8").replace("+","%20") +
                        "&issuer=" + URLEncoder.encode(issuer, "UTF-8").replace("+","%20")
                    }

        def createQRCode(barCodeData: String, filePath: String, height: Int, width: Int) =
            val matrix: BitMatrix = new MultiFormatWriter().encode(barCodeData, BarcodeFormat.QR_CODE, width, height)
            val outVal: FileOutputStream = new FileOutputStream(filePath)
            MatrixToImageWriter.writeToStream(matrix,"png",outVal)
    end BarCodeService

    class OtpService(generator: String) extends MyDatabase with BarCodeService:
        private val secret: Array[Byte] = SecretGenerator.generate()

        enum Generator:
            case Hotp, Totp

            def getHotp: HOTPGenerator = new HOTPGenerator.Builder(secret)
                .withPasswordLength(6)
                .withAlgorithm(HMACAlgorithm.SHA1)
                .build()

            def getTotp: TOTPGenerator = new TOTPGenerator.Builder(secret)
                .withHOTPGenerator(builder => {
                        builder.withPasswordLength(6)
                        builder.withAlgorithm(HMACAlgorithm.SHA1)
                })
                .withPeriod(Duration.ofSeconds(30))
                .build()
        end Generator

        def getToken(generator: String): String = Generator.valueOf(generator) match
            case Generator.Hotp => Generator.Hotp.getHotp.generate(getCounterValue(database))
            case Generator.Totp => Generator.Totp.getTotp.now()

        private def verifyUtility (value: Try[Boolean], database: mutable.Map[Int, User] = database): String =
            value match
                case Success(v) =>
                    v match
                        case true =>
                            incrementCounter(database)
                            s"Code Verified?: $v"
                        case false =>
                            s"Code Verified?: $v"
                case Failure(exception) =>
                    exception.getMessage()

        def verifyCode(code: String, generator: String = generator, database: mutable.Map[Int, User] = database): String =
            Generator.valueOf(generator) match
                case Generator.Hotp =>
                    verifyUtility(Try{Generator
                        .Hotp
                        .getHotp
                        .verify(code, getCounterValue(database))})
                case Generator.Totp =>
                    verifyUtility(Try{Generator
                        .Totp
                        .getTotp
                        .verify(code)})

        val barCodeUrl = getGoogleAuthenticatorBarCode(new String(secret), "karlsambade@gmail.com","karl", generator)
    end OtpService

    class EmailService(token: String):
        val message = s"""
            |<H3>Website Login</H3>
            |<p>Please complete the login process using google authenticator</p>
            |<p>You can either manually enter the code or scan the QR code below </p>
            |<p>Code: $token </p>
            |<p>The QR Code image attached to this email.</p>
            """
        val email = Email.mime(
            from"karlsambade@gmail.com",
            to"karlsambade@gmail.com",
            subject"complete login",
            Body.Html(message)
        )

        val logger = Slf4jLogger.getLogger[IO]

        val credentials = Credentials(
            Username("karlsambade@gmail.com"),
            Password("password")
        )

        val action: IO[Replies] =
            for
                tls <- Network[IO].tlsContext.system
                client = Client[IO](SocketAddress(host"smtp.gmail.com", port"587"), Some(credentials))(tls,logger)
                response <- client.send(email)
            yield response

        def sendEmail = action.attempt.flatMap{
                            case Right(replies) => Ok(s"Recieve a reply: $replies")
                            case Left(error) => Ok(s"Recieved an Error: ${error.getMessage}")
                                }
    end EmailService

    class FinalService(generator: String):
        val otpService = new OtpService(generator)
        val emailService = new EmailService(otpService.getToken(generator))
    end FinalService

    val tokenService = new FinalService("Hotp")

    val routes: HttpRoutes[IO] =
        HttpRoutes.of[IO]{
            case GET -> Root / "login" =>
                tokenService.otpService.barCodeUrl match
                    case Success(burl) =>
                        IO{tokenService.otpService.createQRCode(burl, "barCode.png", 400, 400)} >>
                        tokenService.emailService.sendEmail
                    case Failure(_) =>
                        Ok("Error occurred generating QR Code...")
            case GET -> Root / "code" / value =>
                Ok(s"${tokenService.otpService.verifyCode(value)}")
        }

    val server = EmberServerBuilder
        .default[IO]
        .withHost(ipv4"0.0.0.0")
        .withPort(port"8080")
        .withHttpApp(routes.orNotFound)
        .build

    override def run(args: List[String]): IO[ExitCode] =  server.use(_ => IO.never).as(ExitCode.Success)
```
