---rockthejvm
title: "Http Authentication with Scala and Http4s Part 2"
date: 2023-06-17
header:
  image: "/images/blog cover.jpg"
tags: []
excerpt: "Learn about One Time Passwords such as HOTP and TOTP and create a small application showcasing Two Factor Authentication."
toc: true
toc_label: "In this article"
---

## 1. Introduction

This article is a continuation of the authentication methods that were covered in [part1](https://blog.rockthejvm.com/http4s-authentication-part1/). Here we will cover two more advanced authentication methods which include One Time Password(OTP) and Two Factor Authentication (2FA).

### 1.1 Requirements.

To follow along with this tutorial, you will need to add the following to your build.sbt file.

```scala
val scala3Version = "3.2.2"

val Http4sVersion = "0.23.18"
val OtpJavaVersion = "2.0.1"
val ZxingVersion = "3.5.1"
val SendGridVersion = "4.9.3

val http4sDsl =       "org.http4s"                  %% "http4s-dsl"          % Http4sVersion
val emberServer =     "org.http4s"                  %% "http4s-ember-server" % Http4sVersion
val otpJava =         "com.github.bastiaanjansen"    % "otp-java"            % OtpJavaVersion
val zxing =           "com.google.zxing"             % "javase"              % ZxingVersion
val sendGrid =        "com.sendgrid"                 % "sendgrid-java"       % SendGridVersion

lazy val otpauth = project
  .in(file("otpauth"))
  .settings(
    name := "othauth",
    version := "0.1.0-SNAPSHOT",
    scalaVersion := scala3Version,
    scalacOptions ++= Seq("-java-output-version", "11"),
    libraryDependencies ++= Seq(
      http4sDsl,
      otpJava,
      zxing,
      emberServer,
      sendGrid
    )
  )
```

The latest version of java `sendgrid-java` uses is java 11, therefore we needed to add `scalacOptions ++= Seq("-java-output-version", "11")` to our build.

## 2. One Time Password (OTP)

A One Time Password is a form of authentication that is used to grant access to a single login session or transaction.

The One Time Password authentication method is defined in the [RFC 2289](https://www.ietf.org/rfc/rfc2289.txt) internet standard which provides a detailed explanation of how OTP is implemented.

OTP tokens can either be generated by a software application running on a computer or phone, or they can also be generated using hardware and there is a wide array of devices on the market providing this functionality.

There are a variety of industry-standard algorithms that are used to generate OTP tokens such as SHA256, however, they require two inputs, a static value known as a secret key and a moving factor which changes each time an OTP value is generated. There a two main types of OTP tokens namely HOTP (HMAC-based One Time Password) and TOTP (Time-based One Time Password).

### 2.1 HMAC-based One Time Password (HOTP)

The `H` in HOTP stands for HMAC (Hash-based Message Authentication Code). This is a cryptographic technique that requires a hash function such as SHA256 and a set of parameters (secret key, moving factor). Under HOTP, the moving factor is based on a counter.
Each time a user requests for the HOTP, the counter is incremented. When the server receives the HOTP, it also increments its counter after validating the token, thereby keeping in sync with the OTP generator.
It is possible to generate many HOTP tokens without validating with the server, this throws the two entities out of sync, because of this, different HOTP generators provide different methods for resynchronization.
The HOTP standard is defined under [RFC 4226](https://www.ietf.org/rfc/rfc4226.txt) which gives a detailed explanation of how HOTP operates.

#### 2.1.0 HOTP scala implementation

HOTP generation is quite tedious, therefore for simplicity, we will use a java library, [otp-java](https://github.com/BastiaanJansen/otp-java) by Bastiaan Jansen.
First, we'll need to acquire a secret key. The library provides a mechanism to generate this.

```scala
import com.bastiaanjansen.otp.*

val secret = SecretGenerator.generate()
```

Next, we will use the builder to generate an HOTP instance.

```scala
val hotp = new HOTPGenerator.Builder(secret)
              .withPasswordLength(6)
              .withAlgorithm(HMACAlgorithm.SHA256)
              .build()
```

Here we instantiate a new `HOTPGenerator` class, pass it the `secret`, password length as 6, and algorithm type as `SHA256`. We can now use `hotp` to generate the code.

```scala
val counter = 5
val code = hotp.generate(counter)
```

In the code above, we initialized the counter to 5 and used that to generate the `hotp` code.

When the server receives this code, it can verify it in the following way.

```scala
val isValid = hotp.verify(code, counter)
```

Remember the client and server must keep their counters in sync for the verification phase to work otherwise resynchronization is needed.

### 2.2 Time-based One Time Password (TOTP)

The TOTP token is generated similarly to HOTP with the main difference being the moving factor. Here the moving factor is based on a time counter. The time counter is calculated by dividing the current Unix time by a timestep value which is the life span of a TOTP usually 30 seconds.

#### 2.2.0 TOTP scala implementation

Otp-java also provides an implementation for TOTP token generation.

```scala
import java.time.Duration

val secret = SecretGenerator.generate()

val totp = new TOTPGenerator.Builder(secret)
    .withHOTPGenerator(builder => {
            builder.withPasswordLength(6)
            builder.withAlgorithm(HMACAlgorithm.SHA256)
    })
    .withPeriod(Duration.ofSeconds(30))
    .build()
```

Here the `TOTPGenerator` class is instantiated with a `secret`, the `withHOTPGenerator()` method gives access to a `builder` that we use to set the password length and algorithm type. The last method is `withPeriod()` where we set the duration to 30 seconds, which is the lifespan for each `TOTP`.

```scala
val codeValue = totp.now()
```

The `now()` method on the `TOTPGenerator` class is used to generate the token.
In order to verify totp tokens, we also use the `verify()` method.

```scala
totp.verify(code)
```

## 3. Two Factor Authentication (2FA)

Two Factor Authentication is an authentication method that requires a user to provide two distinct forms of identification to access a website or resource. Here's how it works.

1. When a user tries to perform a transaction or action on a system, he or she will present some credentials like an email or a phone number.
1. The system will send a temporary secure PIN-code or token to the user by email or phone number valid for only that session.
1. When the PIN-code is presented to the system and verified, access will be granted to the user otherwise it will be denied.

The code or token is the One Time Password that we generated in the previous sections

### 3.1 2FA implementation in Scala

In this section, we will create a small application to showcase 2FA using java-otp, Http4s, SendGrid, Google Zxing, and Google Authenticator.

**Creating the User case class.**

We will need to simulate a user who has gone through the first step to login to the application, we do this by defining a `User` case class with required fields. Create a User.scala file and add the following information.

```scala
package com.rockthejvm

case class User(username: String, email: String, var counterValue: Long = 1){
    def incrementCounter =  counterValue += 1
}
```

This case class will hold the `username`, `email`, and `counterValue` that we will need in case of `Hotp`. It also has one method `incrementCounter()` that increments the `counterValue` by 1, we'll call this function after we have successfully verified the `Hotp` code.

**Creating the Generator sealed trait.**

Create a Generator.scala file and add the following code.

```scala
package com.rockthejvm

sealed trait Generator

object Generator{
    case object Hotp extends Generator
    case object Totp extends Generator
}
```

Generator is a sealed trait with two case objects, we will this to choose between `Hotp` and `Totp` implementations depending on our needs.

**Creating the BarCodeService object.**

Google Authenticator gives us two options to capture the OTP code, we can type it manually or scan a bar code. In this section, we will use the Google Zxing library to create barcode images for our application. Let's create a new scala file called `BarCodeService.scala` where we will add our code.

```scala
package com.rockthejvm

import com.rockthejvm.Generator.*
import cats.effect.IO

object BarCodeService{
    def getGoogleAuthenticatorBarCode(secretKey: String, account: String, issuer: String, generator: Generator): IO[String] =
      IO{generator match
            case Hotp =>
                s"otpauth://hotp/$issuer:$account?secret=$secretKey&issuer=$issuer&algorithm=SHA256&counter=0"
            case Totp =>
                s"otpauth://totp/$issuer:$account?secret=$secretKey&issuer=$issuer&algorithm=SHA256"
      }
```

The `getGoogleAuthenticatorBarCode()` method takes a `secretKey` which we create with `otp-java`, an `account` and `issuer` which are the email address and name of the business or person issuing the barcode, and a `generator` which is a string of either `Hotp` or `Totp` (used to choose the type of `otp`), this gives us an `IO[String]`. This function creates a `URI` in the format `otpauth://TYPE/LABEL?PARAMETERS` that we'll use to create the QR Bar Code image in the next section.
We also specify the algorithm as `SHA256` for both cases and set `counter` to 0 only for `Hotp`.

```scala
import scala.util.*
import com.google.zxing.common.BitMatrix
import com.google.zxing.MultiFormatWriter
import com.google.zxing.BarcodeFormat
import java.io.FileOutputStream
import com.google.zxing.client.j2se.MatrixToImageWriter

object BarCodeService{
    ...
    def createQRCode(barCodeData: IO[String], filePath: String = "barCode.png", height: Int = 400, width: Int = 400): IO[Either[String, Unit]] =
        barCodeData.map{data =>
                Try{
                    val matrix: BitMatrix = new MultiFormatWriter().encode(data, BarcodeFormat.QR_CODE, width, height)
                    val outVal: FileOutputStream = new FileOutputStream(filePath)
                    MatrixToImageWriter.writeToStream(matrix,"png",outVal)
                }.toEither.left.map(_.getMessage)
            }
}
```

The `createQRCode()` function creates the BarCode image. It takes as parameters, `barCodeData` which is our `URI`, a `filePath`, and `height` and `width` of our image, all of which we initialize to `barCode.png`, `400` and `400` respectively giving use an `IO[Either[String, Unit]]`. The barCodeData will come from the `getGoogleAuthenticatorBarCode()`.
The `MultiFormatWriter` class has an `encode()` method that takes our arguments and creates a 2D matrix of bits.
The `writeToStream` method on the `MatrixToImageWriter` object takes the `matrix` (of type `BitMatrix`), `"png"` as the image format and a `FileOutputStream`, writes the image to a png file and saves it to the file path.

Here's the full code

```scala
package com.rockthejvm

import scala.util.*
import com.google.zxing.common.BitMatrix
import com.google.zxing.MultiFormatWriter
import com.google.zxing.BarcodeFormat
import java.io.FileOutputStream
import com.google.zxing.client.j2se.MatrixToImageWriter
import com.rockthejvm.Generator.*
import cats.effect.IO

object BarCodeService{
    def getGoogleAuthenticatorBarCode(secretKey: String, account: String, issuer: String, generator: Generator): IO[String] =
      IO{generator match
            case Hotp =>
                s"otpauth://hotp/$issuer:$account?secret=$secretKey&issuer=$issuer&algorithm=SHA256&counter=0"
            case Totp =>
                    s"otpauth://totp/$issuer:$account?secret=$secretKey&issuer=$issuer&algorithm=SHA256"
      }

    def createQRCode(barCodeData: IO[String], filePath: String = "barCode.png", height: Int = 400, width: Int = 400): IO[Either[String, Unit]] =
        barCodeData.map{data =>
                Try{
                    val matrix: BitMatrix = new MultiFormatWriter().encode(data, BarcodeFormat.QR_CODE, width, height)
                    val outVal: FileOutputStream = new FileOutputStream(filePath)
                    MatrixToImageWriter.writeToStream(matrix,"png",outVal)
                }.toEither.left.map(_.getMessage)
            }
}
```

**Creating the OtpService.**

Let's create a scala file and save it as `OtpService.scala`. This service will contain the implementation for `Hotp` and `Totp` that we will use for this application.

```scala
package com.rockthejvm

import scala.util.*
import com.rockthejvm.Generator

class OtpService(generator: Generator, user: User){
    private val secret: Array[Byte] = SecretGenerator.generate()
}
```

We create it as a class in order to pass a `Generator` and `User` as constructor arguments during instantiation. A new `secret` value is generated by otp-java every time a user tries to sign in and saved as an `Array[Byte]` in a private val.

```scala
import com.bastiaanjansen.otp.*
import java.time.Duration

class OtpService(generator: Generator, user: User){
    ...
    private object GenInstance {
        def hotpGen(secretValue: Array[Byte]) = new HOTPGenerator.Builder(secretValue)
            .withPasswordLength(6)
            .withAlgorithm(HMACAlgorithm.SHA256)
            .build()
        def totpGen(secretValue: Array[Byte]) = new TOTPGenerator.Builder(secretValue)
                .withHOTPGenerator(builder => {
                        builder.withPasswordLength(6)
                        builder.withAlgorithm(HMACAlgorithm.SHA256)
                })
                .withPeriod(Duration.ofSeconds(30))
                .build()
    }
}
```

The `GenInstance` object contains two functions `hotpGen()` and `totpGen()` used to provide instances of `HOTPGenerator` and `TOTPGenerator` respectively. They both take a `secret` as a parameter. Note that Google Authenticator displays a token length of 6, we supply the same value to our function implementations. We also use the same algorithm type `SHA256` as our `URI`. This object is created as `private` so that it's only used within this class.

```scala
import cats.effect.IO
import com.rockthejvm.Generator.*

class OtpService(generator: Generator, user: User){
    ...
    def getToken(generator: Generator = generator, counter: Long = user.counterValue): IO[Either[String,String]] =
            IO{generator match
                case Hotp =>
                    Try{GenInstance.hotpGen(secret).generate(counter)}.toEither.left.map(_.getMessage)
                case Totp =>
                    Try{GenInstance.totpGen(secret).now()}.toEither.left.map(_.getMessage)
            }
}
```

The `getToken()` function takes two optional arguments, a `Generator` and a `User`, both of which are passed through the `OtpService` constructor. We pattern match on `Generator` to give us an `IO[Either[String,String]]`. The `hotpGen` and `totpGen` functions could fail when supplied with a wrong argument, therefore we map the error message from the Try to a `Left` of an `Either` by calling `.toEither.left.map(_.getMessage)`.

```scala
class OtpService(generator: Generator, user: User){
    ...
    def verifyCode(code: String, user: User = user , generator: Generator = generator): IO[Either[String,Boolean]] =
            IO{generator  match
                case Hotp =>
                    Try{GenInstance
                        .hotpGen(secret)
                        .verify(code, user.counterValue)
                    }.toEither.left.map(_.getMessage)
                case Totp =>
                    Try{GenInstance
                        .totpGen(secret)
                        .verify(code)
                    }.toEither.left.map(_.getMessage)
            }
}
```

The `verifyCode()` function is used to check if the code the user sends our service is genuine. It takes a `code` (the otp token), a `User` (from the constructor), and a `Generator` as arguments. Again we pattern match on `Generator` and use the `verify()` function to authenticate our code, this produces an `IO[Either[String,Boolean]]` with the `String` representing an error message in case `verify()` fails and a `Boolean` otherwise.

```scala
class OtpService(generator: Generator, user: User){
    ...
    def makeBarCodeImg: IO[Either[String, Unit]] = BarCodeService.createQRCode(
        BarCodeService.getGoogleAuthenticatorBarCode(new String(secret), "<youremail@email.com>","you", generator)
    )
}
```

The `makeBarCodeImg()` function calls `createQRCode()` with `getGoogleAuthenticatorBarCode()` from the `BarCodeService` as a parameter representing the bar code `URI`. You can provide your name and email address to the `getGoogleAuthenticatorBarCode()` function.

Here is the full code.

```scala
package com.rockthejvm

import cats.effect.IO
import com.bastiaanjansen.otp.*
import java.time.Duration
import scala.util.*
import com.rockthejvm.Generator.*

class OtpService(generator: Generator, user: User){
    private val secret: Array[Byte] = SecretGenerator.generate()

    private object GenInstance {
        def hotpGen(secretValue: Array[Byte]) = new HOTPGenerator.Builder(secretValue)
            .withPasswordLength(6)
            .withAlgorithm(HMACAlgorithm.SHA256)
            .build()
        def totpGen(secretValue: Array[Byte]) = new TOTPGenerator.Builder(secretValue)
                .withHOTPGenerator(builder => {
                        builder.withPasswordLength(6)
                        builder.withAlgorithm(HMACAlgorithm.SHA256)
                })
                .withPeriod(Duration.ofSeconds(30))
                .build()
    }

    def getToken(generator: Generator = generator, counter: Long = user.counterValue): IO[Either[String,String]] =
            IO{generator match
                case Hotp =>
                    Try{GenInstance.hotpGen(secret).generate(counter)}.toEither.left.map(_.getMessage)
                case Totp =>
                    Try{GenInstance.totpGen(secret).now()}.toEither.left.map(_.getMessage)
            }

    def verifyCode(code: String, user: User = user , generator: Generator = generator): IO[Either[String,Boolean]] =
            IO{generator  match
                case Hotp =>
                    Try{GenInstance
                        .hotpGen(secret)
                        .verify(code, user.counterValue)
                    }.toEither.left.map(_.getMessage)
                case Totp =>
                    Try{GenInstance
                        .totpGen(secret)
                        .verify(code)
                    }.toEither.left.map(_.getMessage)
            }

    def makeBarCodeImg: IO[Either[String, Unit]] = BarCodeService.createQRCode(
        BarCodeService.getGoogleAuthenticatorBarCode(new String(secret), "<youremail@email.com>","you", generator)
    )
}
```

**Creating the OtpInteractiveService**

Let's create an OtpInteractiveService.scala file and add the following contents.

```scala
package com.rockthejvm

class OtpInteractiveService(generator: Generator, user: User){
    def otpService = new OtpService(generator, user)
}
```

The `OtpInteractiveService` class will be used to create an instance of `OtpService` with the appropriate constructor arguments.

```scala
package com.rockthejvm

import cats.effect.IO
import com.sendgrid.Response

class OtpInteractiveService(generator: Generator, user: User){
    ...
    def send2FA(sendto: User): IO[Either[String,Response]] = ???
}
```

It also contains a `send2FA()` function used to send an email to a user with our QR Bar Code image as an attachment. To send this email we'll use Sendgrid's email java API, but it requires an API key.

Follow these steps to get your API Key

1. Head over to sendgrid.com and click on the pricing tab.
   SendGrid offers 100 emails per day for free, which is more than enough for this tutorial.
   Click the Start for free button to register

   ![SendGrid Pricing](../images/httpAuthPart2/step1.png)

1. Fill in your email address and password and create the account.

   ![Register](../images/httpAuthPart2/step2.png)

1. Fill in the required information and click get started.

   ![Get Started](../images/httpAuthPart2/step3.png)

1. Check your inbox and click the link to set up 2FA.

1. Select the Text Messages option and click Next.

   ![SetUp 2FA](../images/httpAuthPart2/step6.png)

1. Select your country code and input your mobile number then click next.

   ![Contacts](../images/httpAuthPart2/step7.png)

1. Check your sms and fill in the authentication code and save.

   ![Contacts](../images/httpAuthPart2/step8.png)

1. Log back into SendGrid, You will be prompted for another authentication code.
   Sometimes it's not sent, your can resend it with the link provided. Then click continue.
   After which you will be sent to a welcome screen.

   ![Contacts](../images/httpAuthPart2/step10.png)

1. Click the create identity button.

   ![Contacts](../images/httpAuthPart2/step11.png)

1. Fill in the details and create a sender

   ![Contacts](../images/httpAuthPart2/step12.png)

1. Check the sender email you supplied to verify the single sender.

   ![Contacts](../images/httpAuthPart2/step14.png)

1. Under Email Api and Integration Guide, select Web API, then choose JAVA

   ![Contacts](../images/httpAuthPart2/step15.png)

1. Add an API key name then click the Create Key button.

   ![Contacts](../images/httpAuthPart2/step17.png)

1. Finally follow the steps in part 3 to add your key as an environment variable in the root of our project.

   ![Contacts](../images/httpAuthPart2/step18.png)

Now let's define our `send2FA()` function.

```scala
import com.sendgrid.helpers.mail.objects.{Email, Content}
import java.nio.file.Paths

class OtpInteractiveService(generator: Generator, user: User){
    ...
    def send2FA(sendto: User): IO[Either[String,Response]] = {
        val from = new Email("hkateu@gmail.com")
        val to = new Email(sendto.email)

        val subject = "Sending with SendGrid is Fun"
        val message = s"""
            |<H3>Website Login</H3>
            |<p>Please complete the login process using google authenticator</p>
            |<p>Scan the QR Barcode attached and send us the token number.</p>
            """.stripMargin

        val file = Paths.get("barCode.png")
        val content = new Content("text/html", message)
}
```

We start by defining some variables needed to send an email. The `from` and `to` variables represent the person sending the email and the person to whom the email will be sent. SendGrid provides an `Email` class to structure these email addresses. Notice that we pass the email address of the person we are sending to as a function parameter.

We also define `subject` as a string and `message` as a string containing HTML. The `file` variable is a `Path` to the BarCode png image. `content` is an instance of the `Content` class that tells SendGrid what type of message we are sending, in our case `text/html`.

```scala
import com.sendgrid.helpers.mail.objects.{Email, Content, Attachments}
import com.sendgrid.helpers.mail.Mail
import java.util.Base64
import java.nio.file.{Paths, Files}

...
def send2FA(sendto: User): IO[Either[String,Response]] = {
...
    val mail = new Mail(from, subject, to, content)
    val attachments = new Attachments()
    attachments.setFilename(file.getFileName().toString())
    attachments.setType("application/png")
    attachments.setDisposition("attachment")
    val attachmentContentBytes = Files.readAllBytes(file)
    val attachmentContent = Base64.getEncoder().encodeToString(attachmentContentBytes)
    attachments.setContent(attachmentContent)
    mail.addAttachments(attachments)
}
```

SendGrid provides a `Mail` class that takes our `from`, `subject`, `to`, and `content` variables as parameters to structure our email. We then create `attachments` which is an instance of the `Attachments` class, it provides `setFilename()`, `setType()`, and `setDisposition()` methods to structure our attachment.

We use the `readAllBytes()` method from `Files` to convert our png image to type `Array[Byte]` and store it in `attachmentContentBytes`, then encode it to Base64 and store it in `attachmentContent` since SendGrid requires Base64 encoding to send attachments.

We then call `attachments.setContent(attachmentContent)` and `mail.addAttachments(attachments)` to add our file as an attachment on our `Mail` instance.

```scala
import scala.util.*
import com.sendgrid.{SendGrid, Method, Request, Response}

...
def send2FA(sendto: User): IO[Either[String,Response]] = {
...
    val sg = new SendGrid(Properties.envOrElse("SENDGRID_API_KEY","undefined"))
    val request = new Request()
    val response: IO[Either[String,Response]] =
        IO{
            Try {
                request.setMethod(Method.POST)
                request.setEndpoint("mail/send")
                request.setBody(mail.build())
                val res = sg.api(request)
                res
            }.toEither.left.map(_.getMessage)
        }

    response
}
```

`sg` is an instance of the `SendGrid` class that takes our API Key as an argument. Since the API Key is saved as an environment variable, we call `Properties.envOrElse("SENDGRID_API_KEY","undefined")` to fetch it. If it doesn't exist, this function will set it to `undefined`.

We create a `Request` class and use that to build our mail. Within the response variable we call `setMethod()`, `setEndpoint()`, and `setBody()` methods on the `request` class and return `sg.api(request)` as a `Try[Response]` then call `.toEither.left.map(_.getMessage)` to convert it to an `Either[String,Response]`. `Response` will hold the response from the SendGrid server, however, if an error occurred sending the email, the error message is mapped to a `Left`. Finally, we return our `response` on the last line of the function.

Here is the full code.

```scala
package com.rockthejvm

import com.sendgrid.{SendGrid, Method, Request, Response}
import com.sendgrid.helpers.mail.objects.{Email, Content, Attachments}
import com.sendgrid.helpers.mail.Mail
import java.nio.file.{Paths, Files}
import java.util.Base64
import scala.util.*
import cats.effect.IO

class OtpInteractiveService(generator: Generator, user: User){
    def otpService = new OtpService(generator, user)

    def send2FA(sendto: User): IO[Either[String,Response]] = {
        val from = new Email("hkateu@gmail.com")
        val to = new Email(sendto.email)

        val subject = "Sending with SendGrid is Fun"
        val message = s"""
            |<H3>Website Login</H3>
            |<p>Please complete the login process using google authenticator</p>
            |<p>Scan the QR Barcode attached and send us the token number.</p>
            """.stripMargin

        val file = Paths.get("barCode.png")
        val content = new Content("text/html", message)

        val mail = new Mail(from, subject, to, content)
        val attachments = new Attachments()
        attachments.setFilename(file.getFileName().toString())
        attachments.setType("application/png")
        attachments.setDisposition("attachment")
        val attachmentContentBytes = Files.readAllBytes(file)
        val attachmentContent = Base64.getEncoder().encodeToString(attachmentContentBytes)
        attachments.setContent(attachmentContent)
        mail.addAttachments(attachments)

        val sg = new SendGrid(Properties.envOrElse("SENDGRID_API_KEY","undefined"))
        val request = new Request()
        val response: IO[Either[String,Response]] =
            IO{
                Try {
                    request.setMethod(Method.POST)
                    request.setEndpoint("mail/send")
                    request.setBody(mail.build())
                    val res = sg.api(request)
                    res
                }.toEither.left.map(_.getMessage)
            }

        response
    }
}
```

**Http4s Routes and Server.**

In this section, we create the routes and server using http4s. Let's create a new scala file called OtpAuth.scala and add the following.

```scala
import cats.effect.{IOApp, IO, ExitCode}
import com.rockthejvm.OtpInteractiveService
import com.rockthejvm.User
import com.rockthejvm.Generator.*

object OtpAuth extends IOApp:
    val user = User("john", "john@email.com")
    val tokenService = new OtpInteractiveService(Hotp, user)

    override def run(args: List[String]): IO[ExitCode] =  ???
```

Here we create an instance of `OtpInteractiveService` to which we supply a `Generator` of type `Hotp` and a `User` as constructor arguments.

```scala
import org.http4s.*
import org.http4s.dsl.io.*
import scala.util.*
    ...
    val routes: HttpRoutes[IO] =
        HttpRoutes.of[IO]{
            case GET -> Root / "login" =>
                tokenService.otpService.makeBarCodeImg.flatMap{value =>
                    value match
                        case Right(_) =>
                            tokenService.otpService.getToken().map(println) >>
                            tokenService.send2FA(user).flatMap{response =>
                                response match
                                    case Right(res) =>
                                        IO(println(res.getBody())) >>
                                        IO(println(res.getStatusCode())) >>
                                        IO(println(res.getHeaders())) >>
                                        Ok("We sent you an email, please follow the steps to complete the signin process.")
                                    case Left(ex) =>
                                        IO(println(s"Error: $ex")) >>
                                        Ok("Oops, something went wrong, please try again later.")
                            }
                        case Left(ex) => Ok("Error occurred generating QR Code...")
                }
        }

    override def run(args: List[String]): IO[ExitCode] =  ???
```

Next, we create our routes using the `HttpRoutes.of[IO]` method. When a user tries to log into the application using the `/login` route, we use the `tokenService` to try to create the bar code image by running `tokenService.otpService.makeBarCodeImg`, this gives us an `IO[Either[String, Unit]]` that we `flatMap` and match.
If the bar code image was successfully created we get the token value and print it to the console for debugging purposes otherwise for security reasons it should be removed. This is done by running `println(tokenService.otpService.getToken())`.

We then proceed to send our email by calling `tokenService.send2FA(user)` which we `flatMap` and `match` on the `response`. If the email was sent successfully, we print the body, status code and headers to the console for debugging purposes by calling `res.getBody()`, `res.getStatusCode()`, and `res.getHeaders()` on `response` respectively, and inform the user to check his or her email, otherwise we print the error to the console and inform the user that an error occurred.

In case an error occurred creating the bar code image, we also inform the user by returning `Ok("Error occurred generating QR Code...")`.

```scala
val routes: HttpRoutes[IO] =
    HttpRoutes.of[IO]{
    ...
        case GET -> Root / "code" / value =>
            tokenService.otpService.verifyCode(value).flatMap{value =>
                value match
                    case Right(result) =>
                        if(true) then
                            IO(user.incrementCounter) >>
                            Ok(s"Code Verified?: $result")
                        else
                            Ok(s"Code Verified?: $result")
                    case Left(ex) =>
                        IO(println(ex)) >>
                        Ok("An error occurred during verification")
            }
    }
```

The `/code/value` route receives the code from the user and verifies it by calling `tokenService.otpService.verifyCode(value)` where `value` is the 6-digit code. If the code is correctly verified we increment the user's counter by 1 and respond with `Ok(s"Code Verified?: true")`, assuming that the verification failed, we respond with `Ok(s"Code Verified?: false")`.

Supposing an error occurred during the verification process, we print the error to the console and respond with `Ok("An error occurred during verification")`.

```scala
import com.comcast.ip4s.*
import org.http4s.ember.server.EmberServerBuilder
    ...
    val server = EmberServerBuilder
        .default[IO]
        .withHost(ipv4"0.0.0.0")
        .withPort(port"8080")
        .withHttpApp(routes.orNotFound)
        .build

    override def run(args: List[String]): IO[ExitCode] =  server.use(_ => IO.never).as(ExitCode.Success)
```

Finally, we use ember to create our `server` and add it the the `run` function.

Here is the full code.

```scala
import cats.effect.{IOApp, IO, ExitCode}
import org.http4s.*
import org.http4s.dsl.io.*
import com.comcast.ip4s.*
import org.http4s.ember.server.EmberServerBuilder
import com.rockthejvm.OtpInteractiveService
import com.rockthejvm.User
import com.rockthejvm.Generator.*

object OtpAuth extends IOApp:
    val user = User("john", "john@email.com")
    val tokenService = new OtpInteractiveService(Totp, user)


    val routes: HttpRoutes[IO] =
        HttpRoutes.of[IO]{
            case GET -> Root / "login" =>
                tokenService.otpService.makeBarCodeImg.flatMap{value =>
                    value match
                        case Right(_) =>
                            tokenService.otpService.getToken().map(println) >>
                            tokenService.send2FA(user).flatMap{response =>
                                response match
                                    case Right(res) =>
                                        IO(println(res.getBody())) >>
                                        IO(println(res.getStatusCode())) >>
                                        IO(println(res.getHeaders())) >>
                                        Ok("We sent you an email, please follow the steps to complete the signin process.")
                                    case Left(ex) =>
                                        IO(println(s"Error: $ex")) >>
                                        Ok("Oops, something went wrong, please try again later.")
                            }
                        case Left(ex) => Ok("Error occurred generating QR Code...")
                }
            case GET -> Root / "code" / value =>
                tokenService.otpService.verifyCode(value).flatMap{value =>
                    value match
                        case Right(result) =>
                            if(true) then
                                IO(user.incrementCounter) >>
                                Ok(s"Code Verified?: $result")
                            else
                                Ok(s"Code Verified?: $result")
                        case Left(ex) =>
                            IO(println(ex)) >>
                            Ok("An error occured during verification")
                }
        }

    val server =
        EmberServerBuilder
            .default[IO]
            .withHost(ipv4"0.0.0.0")
            .withPort(port"8080")
            .withHttpApp(routes.orNotFound)
            .build

    override def run(args: List[String]): IO[ExitCode] =  server.use(_ => IO.never).as(ExitCode.Success)
```

Finally can run our server and test our application.
Make sure you provide an actual email to our user, this is where the token will be sent.

```scala
val user = User("john", "john@email.com")

```

**Testing our application.**

```bash
curl -vv http://localhost:8080/login
*   Trying ::1:8080...
* Connected to localhost (::1) port 8080 (#0)
> GET /login HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.71.1
> Accept: */*
>
* Mark bundle as not supporting multiuse
< HTTP/1.1 200 OK
< Date: Fri, 16 Jun 2023 14:59:55 GMT
< Connection: keep-alive
< Content-Type: text/plain; charset=UTF-8
< Content-Length: 77
<
* Connection #0 to host localhost left intact
We sent you an email, please follow the steps to complete the signin process.⏎
```

Here's what we printed to the console.

```bash
829449

202
{Strict-Transport-Security=max-age=600; includeSubDomains, Server=nginx, Access-Control-Allow-Origin=https://sendgrid.api-docs.io,
Access-Control-Allow-Methods=POST, Connection=keep-alive, X-Message-Id=w46GLwNYTLuqboNNO7gqAw, X-No-CORS-Reason=https://sendgrid.com/docs/Classroom/Basics/
API/cors.html, Content-Length=0, Access-Control-Max-Age=600, Date=Fri, 16 Jun 2023 14:59:46 GMT, Access-Control-Allow-Headers=Authorization, Content-Type,
On-behalf-of, x-sg-elas-acl}
```

We can see that SendGrid successfully sent our email.
You can now open your mail and scan the BarCode image with Google Authenticator then pass the 6-digit code to the verification URL. The code outputted by Google Authenticator should be the same as what's displayed in our console.

```bash
curl -vv http://localhost:8080/code/829449
*   Trying ::1:8080...
* Connected to localhost (::1) port 8080 (#0)
> GET /code/829449 HTTP/1.1
> Host: localhost:8080
> User-Agent: curl/7.71.1
> Accept: */*
>
* Mark bundle as not supporting multiuse
< HTTP/1.1 200 OK
< Date: Fri, 16 Jun 2023 15:01:10 GMT
< Connection: keep-alive
< Content-Type: text/plain; charset=UTF-8
< Content-Length: 20
<
* Connection #0 to host localhost left intact
Code Verified?: true⏎
```

The server feedback should be the same as above.

Repeat the same process for `Totp` by making the following change to OtpAuth.scala

```scala
val tokenService = new OtpInteractiveService("Totp", user)
```

Note that for `Totp` to work, make sure your phone and computer date and time down to the seconds are the same and current. You can use the network time for both devices, this should give you the same results.

One may also limit the time the user takes to submit the code as an extra security measure.

## 3. Conclusion

In this tutorial we learned about One Time Password Authentication, we explored HMAC-based One Time Password (HOTP) and Time-based One Time Password (TOTP) and created a small application where we implemented Two Factor Authentication using the knowledge we learned. 2FA has gained traction in recent years and as displayed, adds another layer of security to your application.
