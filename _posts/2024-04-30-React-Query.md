---
layout: single
title: "React Query란?"
published: true
---

# React Query란

프론트 개발을 하며 API 호출 이후에 데이터를 효과적으로 관리하기 위한 방법을 찾던 중, React Query를 찾았다.
이에 대해 몇 번 스쳐들었을 뿐이기에 이번 포스트를 통해 정확히 어떤 개념인지 알아보자.

<!-- 이미지 -->

[공식문서](https://tanstack.com/query/v5/docs/framework/react/overview)에선 React Query를 다음과 같이 설명하고 있다.

> React Query는 fetching, caching, 서버 데이터와의 동기화를 지원하는 라이브러리

즉, React 환경에서 서버와 지속적으로 동기화 하도록 지원한다.

비동기 데이터를 불러오는 과정에서 발생하는 문제를 해결하는 건데, 어떤 문제들을 어떻게 해결하는지 확인해보자.

# 1. 캐싱

React Query는 여러가지 장점이 있는데, 먼저 캐싱을 알아보자.

> 캐싱이란, 이전에 사용한 데이터를 임시로 저장하고 동일한 데이터에 대한 접근 속도를 높이는 것

캐싱을 통하여 동일한 데이터에 대한 비동기 호출을 방지하며, 서버에 대한 부담감을 덜어줄 수 있다.

하지만 아래의 의문점을 가질 수 있는데,

👤 **현재 데이터가 최신인지 어떻게 구분해?**

만약 캐싱된 데이터를 사용하고 있던 중, 서버 상의 데이터가 변경되었다면 사용자는 잘못된 정보를 제공받게 된다.

장점이 단점으로 전환되는 상황을 방지하기 위해서는 적절한 시기에 데이터를 갱신하는 것이 중요하다.

## a. 데이터 갱신

> fresh: (신선한) 캐싱한 데이터를 사용 <br />
> stale: (신선하지 않은) fetching이 필요한 상태

기본적으로 React Query는 캐시된 데이터를 stale로 간주한다.

즉, 최신화가 필요한 데이터라는 의미이며 아래와 같은 시점에 데이터를 갱신한다.

* 화면을 이탈했다가 다시 포커스를 가졌을 때
* 새로운 Query 인스턴스가 마운트 될 때
* 네트워크 재연결이 발생했을 때

예를 들어 정보 변경이 잦지 않은 **유저 정보**에 대해 캐싱한다고 치자.

현재 서버 부담은 크고, 호출하는 API가 많다.

심지어 유저 페이지에 진입할 때마다 get 요청을 보내 불필요한 API 호출이 생기게 된다.

이러한 상태 값을 캐싱하기 위해선 staleTime과 cacheTime을 알아야 하는데,

## b. staleTime? cacheTime?

> * staleTime은 데이터가 fresh에서 stale 상태로 변경되는 데 걸리는 시간 <br />
> * cacheTime은 데이터가 inactive한 상태일 때 캐싱된 상태로 남아있는 시간
> * inactive란 해당 쿼리가 현재 활성화 되지 않은 상태. <br /> 사용자가 화면에 포커스를 두지 않을 때 inactive 라고 한다. 쿼리가 캐시에 남아있지만, 자동으로 재요청하지 않는다.

staleTime에 의해 데이터가 fresh 상태인 경우엔, 위의 데이터 갱신 (refetch) 트리거가 발생해도 재요청을 하지 않는다.
cacheTime이 지난 이후 캐싱되었던 데이터는 가비지 콜렉터로 수집되어 메모리에서 해제된다.

결국 staleTime과 cacheTime이 뭐가 다른지 궁금할 수 있는데, 

만약 staleTime이 지나 데이터가 stale 상태가 되었지만, cacheTime은 지나지 않은 상태에서 <br />
해당 데이터를 사용하는 화면에 다시 포커스가 잡힌 경우에 (mount) 

**새로운 데이터를**  fetch 하는 동안 임시로 캐싱된 데이터를 보여준다.

이외에 사용자가 원하는 시점마다 직접 refetching을 하도록 설정할 수도 있다.

# 2. 간단한 비동기 데이터 관리

React Query는 API 호출과 비동기 데이터 관리를 간편하게 처리할 수 있도록 도와준다. <br />

React 개발 초창기 (2015-2018), Redux와 같은 라이브러리를 사용하여 이러한 작업을 처리했다. Redux는 Flux 패턴을 활용하여 상태를 관리하며, redux-thunk, redux-saga 등의 미들웨어를 사용하여 비동기 작업을 처리했다.

그러나 Redux를 사용하며 겪은 단점이 존재했는데, **장황한 Boilerplate 코드**이다. 이러한 이슈를 해결하기 위해 redux-toolkit가 등장하였음에도 불구하고, 여전히 Boilerplate의 복잡도는 높았다. 하지만 React Query를 사용하면 이러한 복잡성을 줄일 수 있다.

<!-- Redux sample code -->

