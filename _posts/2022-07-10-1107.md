---
layout: single
title:  "[백준]1107번: 리모컨"
categories: baekjoon
tag: [python, class_3, algolithm, gold, brute force]
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

# 리모컨

solved_ac[Class3] [리모컨](https://www.acmicpc.net/problem/1107)

## 문제

수빈이는 TV를 보고 있다. 수빈이는 채널을 돌리려고 했지만, 버튼을 너무 세게 누르는 바람에, 일부 숫자 버튼이 고장났다.

리모컨에는 버튼이 0부터 9까지 숫자, +와 -가 있다. +를 누르면 현재 보고있는 채널에서 +1된 채널로 이동하고, -를 누르면 -1된 채널로 이동한다. 채널 0에서 -를 누른 경우에는 채널이 변하지 않고, 채널은 무한대 만큼 있다.

수빈이가 지금 이동하려고 하는 채널은 N이다. 어떤 버튼이 고장났는지 주어졌을 때, 채널 N으로 이동하기 위해서 버튼을 최소 몇 번 눌러야하는지 구하는 프로그램을 작성하시오. 

수빈이가 지금 보고 있는 채널은 100번이다.


## 입력

첫째 줄에 수빈이가 이동하려고 하는 채널 N (0 ≤ N ≤ 500,000)이 주어진다.  둘째 줄에는 고장난 버튼의 개수 M (0 ≤ M ≤ 10)이 주어진다. 고장난 버튼이 있는 경우에는 셋째 줄에는 고장난 버튼이 주어지며, 같은 버튼이 여러 번 주어지는 경우는 없다.

## 출력

첫째 줄에 채널 N으로 이동하기 위해 버튼을 최소 몇 번 눌러야 하는지를 출력한다.

## 예제 입력 1 

```
5457
3
6 7 8
```

## 예제 출력 1 

```
6
```

## 예제 입력 2 

```
100
5
0 1 2 3 4
```

## 예제 출력 2 

```
0
```

## 예제 입력 3 

```
500000
8
0 2 3 4 6 7 8 9
```

## 예제 출력 3 

```
11117
```

## 예제 입력 4 

```
100
3
1 0 5
```

## 예제 출력 4 

```
0
```

## 예제 입력 5 

```
14124
0
```

## 예제 출력 5 

```
5
```

## 예제 입력 6 

```
1
9
1 2 3 4 5 6 7 8 9
```

## 예제 출력 6 

```
2
```

## 예제 입력 7 

```
80000
2
8 9
```

## 예제 출력 7 

```
2228
```



# 문제 해석

완전탐색 문제이다. 0채널부터 시작해서 마지막 채널까지 전부 탐색을 하면서 +버튼이나 -버튼만 눌렀을 경우와 직접 가까운 채널로 이동해서 정답 숫자까지 +나 -로 접근을 하는지 크게 두가지 경우로 나누어서 풀어야한다.

# 풀이

- 고장난 리모컨의 숫자의 갯수(M)이 0개가 아니라면?
    - 고장난 숫자가 1개라도 있다는 뜻이기에 broken 배열에 입력을 받아서 집어 넣어준다.
- 목표하고자 하는 채널이 100번이라면?
    - 첫 시작이 100번이였으니 나머지 입력 숫자가 무엇이든 관계없이 답은 0이다.
- 고장난 숫자의 갯수가 0이 아니고, 10이 아니면?
    - 0일때는 하나도 고장이 안난것이고, 10이면 모든 숫자가 다 고장이 난것이기 때문에 하나이상 그리고 적어도 안 고장난 숫자가 1개라도 있는 경우를 나누었다.
    - min을 구하기 위한 최솟값으로 큰 숫자를 넣어준다.
    - a라는 숫자는 최솟값을 비교하기 위해서 쓰일 것인데 초깃값으로 min_num보다 1 크게 잡아준다. 밑에서 설명하겠다.
    - 50만개의 채널인데 +버튼과 -버튼이 있으니 1000000 채널에서 -를 500000번 해서 내려오는 경우도 있으니 범위를 100001으로 해준다.
        - num을 0부터 탐색을 시작하는데 아까 broken에 넣어주었던 못쓰는 숫자들과 비교를 하기위해서 같은 str형으로 바꾸어준다.
        - num의 자릿수만큼 루프를 돌면서 각 자리수가 broken 배열에 들어가있는 수와 일치하는지 확인한다.
            - 만약 일치한다면?
                - 만들어진 num은 고장난 숫자가 하나라도 들어갔다는 뜻이기에 못쓰는 숫자여서 break로 루프를 탈출한다.
            - 만약 루프를 다 돌았는데 고장난 숫자가 하나도 없다면?
                - 목표하는 숫자와 num의 차이를 구해서 루프를 도는 동안 가장 작은 값을 비교하기 위해 a에 저장해준다.
                - 여기서 위에 왜 a를 min_num보다 1 크게 했냐면 첫 루프부터 고장난 숫자에 접근을 해서 a를 업데이트 안 시켜준 상태로 밑에 내려갈 수도 있다. 그렇다면 무조건 min_num보다 a가 커야하기 때문에 1을 증가시켜준 초기값으로 설정했다.
        - 만약 목표치와의 차의 최소값으로 정해놓은 a가 전 min_num보다 작다면?
            - min_num을 a로 업데이트 시켜주고 res라는 결과 변수에 해당하는 num을 업데이트 시켜준다.
    - 묙표치와 가장 근사하는 값인 res와 목표치와의 차이의 절대값은 +나 -를 누르는 횟수이며 res의 자릿수는 res 채널을 누르는 횟수이다.
    - 목표치와 100채널의 차이이다.
    - 위의 두개를 비교하는 이유는 고장나지 않은 숫자들로 아무리 근사치의 숫자를 구했더라도 단순히 시작 채널인 100에서 +나 -만으로 가는게 더 가까울 수도 있기 때문에 비교를 해서 더 작은수를 뽑아내야 한다.
- 만약 리모컨의 숫자가 전부다 고장난 경우?
    - 숫자를 누를 수 없기 때문에 +나 -로 두 수의 차이만큼 이동 하는 것이 답이다.
- 하나도 고장나지 않은 경우?
    - 이것도 위의 풀이와 마찬가지로 숫자를 입력해서 가는것과 +나 -만을 입력해서 가는 것을 따로 구해서 비교 후 최솟값을 출력해준다.

```python
import sys

N = sys.stdin.readline().rstrip()

M = int(sys.stdin.readline())

if M != 0:
    broken = list(sys.stdin.readline().split())

if int(N) == 100:
    print("0")
    exit()
    
elif M != 0 and M != 10:
    min_num = 99999999999
    a = min_num + 1
    for num in range(1000001):
        str_num = str(num)
        
        for i in range(len(str_num)):
            if str(str_num[i]) in broken:
                break    
            
            elif i == len(str_num) - 1:
                a = abs(int(N) - num)
                
        if min_num > a:
            min_num = a
            res = num
    sum_a = abs(res - int(N)) + len(str(res))
    sum_b = abs(int(N) - 100)
    
    if sum_a > sum_b:
        print(sum_b)
    else:
        print(sum_a)
    
elif M == 10:
    print(abs(int(N) - 100))
            
else:
    a = abs(int(N) - 100)
    b = len(N)
    
    if a > b:
        print(b)
    else:
        print(a)
```

# 깨달은 점

아무리 범위가 많다고 하더라도 브루트 포스를 무조건 제외하고 풀지말자. 오늘과 같은 실수가 또 반복이 될 수가 있으며 문제를 풀면서 경우의 수를 나누지 말고, 필기를 하면서 코딩을 하기 전에 모든 경우의 수를 생각해 놓고 코딩을 하도록 하자.
