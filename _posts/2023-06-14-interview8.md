---
layout: single
title:  "[Interview] 면접 관련 정리8"
categories: Business
tag: [web, server, DB, JPA, spring boot]
toc: true
toc_sticky: true
author_profile: false
sidebar:
    nav: "docs"
---

<br>

# 디자인 패턴

## 분류

- 생성 패턴(Creational) : 객체의 생성 방식 결정
    - Ex) DB Connection을 관리하는 인스턴스를 하나만 만들 수 있도록 제한하여, 불필요한 연결을 막는다.

- 구조 패턴(Structural) : 객체간의 관계를 조직
    - Ex) 2개의 인터페이스가 서로 호환이 되지 않을 때, 둘을 연결해주기 위해 새로운 클래스를 만들어서 연결시킬 수 있도록 한다.

- 행위 패턴(Behavioral) : 객체의 행위를 조직/관리/연합
    - Ex) 하위 클래스에서 구현해야 하는 함수 및 알고리즘들을 미리 선언하여, 상속시 이를 필수로 구현하도록 한다.

## 종류

- 생성 패턴
    - 팩토리 패턴 : 객체를 생성하기 위한 디자인 패턴
        - 객체를 생성하는 부분을 Sub Class에 맡기는 패턴

    - 추상 팩토리 패턴 : 객체를 생성하는 팩토리를 생성하기 위한 디자인 패턴

    - 싱글톤 패턴 : 객체를 1개만 생성하여 항상 참조 가능하도록 보장하는 디자인 패턴

- 구조 패턴
    - 어댑터 패턴 : 호환성이 맞지 않는 두 클래스를 연결하여 사용하기 위한 디자인 패턴

    - 프록시 패턴 : 어떤 객체에 접근 제어를 위해 대리인을 사용하는 디자인 패턴

- 행위 패턴
    - 전략 패턴 : 상황에 따라 다른 전략을 사용하기 위한 디자인 패턴

    - 옵저버 패턴 : 값을 관찰하여 빠르게 반영하기 위한 디자인 패턴
    
    - 커맨드 패턴 : 실행될 기능을 캡슐화하여 재사용성이 높은 클래스를 설계하기 위한 디자인 패턴

<br>

# Spring 싱글톤 패턴

Java로 기본적인 싱글톤 패턴을 구현하면 다음과 같은 단점이 존재한다.
- private 생성자를 갖고 있어 상속이 불가능하다.
- 테스트하기 힘들다.
- 서버 환경에서는 싱글톤이 1개만 생성됨을 보장하지 못한다.

그래서 스프링은 컨테이너를 통해 직접 싱글톤 객체를 생성하고 관리하고, 다음과 같은 장점을 얻는다.
- static 메소드나 private 생성자 등을 사용하지 않아, 객체지향적 개발을 할 수 있다.
- 테스트를 하기 편리하다.

<br>

# Dispatcher Servlet

Tomcat과 같은 서블릿 컨테이너를 통해 들어오는 모든 요청을 제일 앞에서 받는 프론트 컨트롤러이다.<br>
Dispatcher Servlet은 공통된 작업을 처리한 후, 적절한 세부 컨트롤러로 작업을 위임해준다.<br>
그리고, 각각의 세부 컨트롤러는 작업을 처리하고, 반환할 view를 Dispatcher Servlet으로 넘겨준다.

<br>

# Spring MVC

웹 애플리케이션 개발을 위한 MVC 패턴 기반의 웹 프레임워크.<br>
Spring MVC는 애플리케이션 구성 요소를 Model, View, Controller로 분리하고, 다음과 같은 컴포넌트들로 구성된다.

- Dispatcher Servlet : 클라이언트의 요청을 먼저 받아들이는 서블릿으로, 요청에 맞는 컨트롤러에게 요청을 전달
- Handler Mapping : 해당 요청이 어떤 컨트롤러에게 온 요청인지 검사
- Controller : 클라이언트의 요청을 받아 처리하고, 결과를 디스패처 서블릿에게 전달
- ViewResolver : View 이름을 통해 알맞은 View를 찾음
- View : 사용자게에 보여질 UI 화면

<br>

# Spring MVC 작동 원리

![springMVC](/images/interview/springMVC.jpg)

1. 클라이언트가 URL을 통해 요청을 전송
2. 디스패처 서블릿은 핸들러 매핑을 통해 해당 요청을 처리할 수 있는 컨트롤러를 찾는다.
3. 디스패처 서블릿은 핸들러 어댑터에게 요청의 전달을 맡긴다.
4. 핸들러 어댑터는 해당 컨트롤러에 요청을 전달한다.
5. 컨트롤러는 비즈니스 로직을 처리한 후, 반환해야 할 View의 이름을 반환한다.
6. 디스패처 서블릿은 ViewResolver를 통해 반환할 View를 찾는다.
7. 디스패처 서블릿은 컨트롤러에서 넘어온 View에 전달할 데이터를 추가한다.
8. 데이터가 추가된 View를 반환한다.

<br>

# Spring MVC의 장단점

## 장점

- 의존성 주입을 통해 컴포넌트 간 결합도를 낮출 수 있어, 단위 테스트가 용이하다.
- 제어의 역전을 통해 빈(객체)의 라이프사이클에 관여하지 않고, 개발에 집중할 수 있다.

## 단점

- XML을 기반으로 하는 프로젝트 설정은 많은 시간을 필요로 한다.
- 톰캣과 같은 WAS를 별도로 설치해 주어야 한다.

## 단점 보완

- **Spring Boot**
    - 자주 사용되는 라이브러리들의 버전 관리 자동화
    - AutoConfig로 복잡한 설정 자동화
    - Tomcat과 같은 내장 웹서버 제공
    - 실행 가능한 JAR로 개발 가능

<br>

# Spring 어노테이션

- @Bean : 개발자가 직접 제어가 불가능한 외부 라이브러리 또는 설정을 위한 클래스를 수동으로 빈 등록할 때 사용
- @Configuration
    - 외부 라이브러리 또는 내장 클래스를 Bean으로 등록하고자 할 경우 사용(개발자가 제어 불가능한 클래스)
    - 1개 이상의 @Bean 메소드를 갖는 클래스의 경우 반드시 명시해 주어야 함
- @Component : 개발자가 직접 개발한 클래스를 Bean으로 등록하고자 할 경우 사용

<br>

# @SpringBootApplication

- @SpringBootConfiguration
    - 스프링 컨테이너는 `@Bean`으로 정의된 클래스 메소드를 처리해 Bean을 생성한다.
    - 생성된 Bean을 통해 스프링 컨테이너의 의존성 주입을 가능하게 만들어 준다.
- @EnableAutoConfiguration
    - 필요한 설정들을 자동으로 해주는 자동 설정 기능을 활성화함
- @ComponentScan
    - 빈을 찾아서 등록하기 위한 위치를 지정함
    - 해당 클래스에 구현한 `@Bean`을 스프링 컨테이너에 포함시킬 수 있다.

<br>

# Spring Filter / Interceptor

## Filter

- 관리되는 컨테이너 : 웹 컨테이너
- Request/Response 조작 가능

### 용도

- 보안 관련 공통 작업
- 모든 요청에 대한 로깅 또는 감사
- 이미지/데이터 압축 및 문자열 인코딩

## Interceptor

- 관리되는 컨테이너 : 스프링 컨테이너
- Request/Response 조작 불가능

### 용도

- 인증/인가 등과 같은 공통 작업
- Controller로 넘겨주는 정보의 가공
- API 호출에 대한 로깅 또는 감사

## 차이

실행 순서에 차이가 있다.
<br>

**Http 요청 - WAS - 필터 - 서블릿 - 인터셉터 - 컨트롤러**