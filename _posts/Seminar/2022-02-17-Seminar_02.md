---
published: true
layout: single
title: "Tech Seminar"
category: seminar
tags:
comments: true
sidebar:
  nav: "mainMenu"
---  
* * *

#### 들어가기에 앞서서
* * *
- 모던 C++에서 권장되는 코딩 방법이나 문법 등을 알아보자
- 당장, 실제 제품 코드에 적용하지 못하더라도 외부 C++ 코드를 봤을 때 조금이나마 이해하는데 도움이 되었으면 합니다.

#### constexpr specifier (since C++11)
* * *
> ***Explanation***  
> The constexpr specifier declares that it is possible to evaluate the value of the function or variable at compile time.

constexpr 한정자는 C++11부터 도입된 문법 입니다. 어떠한 식이 상수식이라고 명시해주는 키워드 입니다. 객체의 정의에 constexpr가 오게 된다면,
 해당 객체는 어떠한 상수식에도 사용할 수 있습니다.
  
설명만 들었을 때, const와 별 차이가 없어 보입니다. 하지만 둘은 엄연히 다른 차이를 가지고 있습니다.
  
아래의 코드에서 b는 값을 변경할 수 없지만 b의 값을 프로그램이 컴파일 타임에 알 필요는 없겠지요.
```c++
...
...
int a = 0;
// Do something
const int b = a;
...
...
```
  
반면, constexpr 변수의 경우, 반드시 오른쪽에 다른 상수식이 와야합니다. 상수식이 오지 않으면 
컴파일 에러가 발생합니다.

```c++
int a = 0;
// Do someting
constexpr int b = a;  // Compile Error
```

그렇다면 아래와 같이 상수식을 사용하는 const 예제는 항상 런타임에 초기화가 되는 것일까요? 정답은 "알 수 없다" 입니다, 
const는 컴파일러에 따라 컴파일 타임에 초기화가 될 수도 있고 런타임에 될 수도 있습니다.

```c++
const bool isInitCompileTime = false;
```

그러면 왜 런타임이 아닌 컴파일 타임에서 실행되도록 하는 것이 성능적으로 더 뛰어날까요?
  
컴파일 타임에 실행된 구문은 읽기 전용 메모리에 올라가기 때문에 프로그램이 더 빠르게 동작할 수 있게 됩니다. 
그 외의 사용할 수 있는 곳은 템플릿 메타 프로그래밍에서 사용할 수 있는데 기존의 전통적인 방법들보다 훨씬 직관적인 방법을 사용할 수 있습니다.

그렇다면 constexpr를 함수에 사용할 경우에는 어떤 동작을 수행 할까요? 당장 생각해보면 컴파일 타임 상수 객체를 반환할 것이라고 예상이 가능한데요.
  
다만, 컴파일 타임 상수를 반환하도록 동작할 수도 있고 동작하지 않을 수도 있습니다. constexpr 함수에 인자로 컴파일 타임 상수가 아닌 값을 전달하면 그냥 일반 함수 처럼 동작하게 됩니다.
    
더 나아가서 이번엔 constexpr를 생성자에 붙이면 어떻게 될까요? 생성자의 경우엔 함수에서 적용되었던 제약 조건이 모두 적용되고 추가 제약 조건이 생깁니다.
 생성자의 인자들은 모두 리터럴 타입(void, char, int, &, Lambda, constexpr 객체 등)이여야만 하고, 해당 클래스는 가상 상속(다중상속 방지를 위한 virtual 상속) 받을 수 없습니다.

#### decltype specifier
* * *

> **Explanation**  
>  decltype is useful when declaring types that are difficult or impossible to declare using standard notation, 
like lambda-related types or types that depend on template parameters.

decltype 한정자는 C++ 11 에 추가된 키워드로, decltype 라는 이름의 함수 처럼 사용됩니다. 하지만
 실제 함수처럼 동작하지는 않고요. decltype으로 둘러 쌓인 식의 타입으로 치환됩니다.
  
*설명만 들었을 때, auto보다 더 불편한 것 같고 별 쓸모도 없어 보이는데요. 이 부분은 차차 설명드리도록 하겠습니다.*

```c++
decltype(/* 타입을 알고자 하는 식*/)
```
<br>
즉, 아래 예제 코드에서 decltype을 사용하고 있는 위치가 타입으로 치환되어 동작하게 되는 것 입니다.
```c++
#include <iostream>

struct A {
  double d;
};

int main() {
  int a = 3;
  decltype(a) b = 2;  // int

  int& r_a = a;
  decltype(r_a) r_b = b;  // int&

  int&& x = 3;
  decltype(x) y = 2;  // int&&

  A* aa;
  decltype(aa->d) dd = 0.1;  // double
}
```
  
위의 예제에서는 decltype에 연산이 없는 표현식만을 사용했습니다. 그렇다면 표현식이 아니라 연산이 있는 식을 사용하면 어떻게 될까요?
  
해당 식의 Value Category에 따라 달라지게 됩니다.
- 식의 연산 결과가 xvalue 라면 decltype 는 T&& 가 됩니다.
- 식의 연산 결과가 lvalue 라면 decltype 는 T& 가 됩니다.
- 식의 연산 결과가 prvalue 라면 decltype 는 T 가 됩니다.
  
xvalue, lvlaue, prvalue는 rvalue reference 처리를 위해 C+11부터 도입된 lvalue, rvalue의 확장 개념입니다.
 오늘 이시간에는 굳이 다루지 않고 그런게 있다 정도만 알고 넘어가도록 하겠습니다.
  
#### decltype vs auto ( + Trailling Return Type)
* * *
decltype 는 도대체 왜 쓰이는 것일까요? 타입 추론이 필요한 부분에는 그냥 auto 로도 충분하지 않을까요? 

```c++
int i = 102607;
auto j = i;  // int j = i;

int i = 102607;
decltype(i) j = i;  // int j = i;
```

즉, 위의 두 경우는 완벽하게 동일하게 동작하는 것 아니냐는 것 입니다. 하지만 auto의 암시적 변환이 발생합니다. 
암시적 변환이 발생하는 예제를 같이 확인해봅시다.

```c++
const int i = 102607;
auto j = i;         // int j = i;
decltype(i) k = i;  // const int k = i;

int arr[10];         // 배열의 경우 auto는 포인터로 암시적 변환
auto arr2 = arr;     // int* arr2 = arr;
decltype(arr) arr3;  // int arr3[10];
```
<br>
이뿐만이 아닙니다. decltype의 경우, 템플릿에서 특정 객체의 타입이 템플릿 인자들에 대해 결정되어야 하는 경우에도 사용할 수 있습니다. (auto는 당연히 사용할 수 없지요.....)

```c++
template <typename T, typename U>
void add(T t, U u, /* What Type */ result) {
  *result = t + u;
}

template <typename T, typename U>
void add(T t, U u, decltype(t + u)* result) {
  *result = t + u;
} // 이렇게 쓸 수 있습니다.
```
<br>
이번에는 return type으로 decltype을 사용하면 어떨까요? 
아쉽지만, 컴파일 에러가 발생합니다. 컴파일러가 decltype안의 t 와 u 를 해석할 때 **"아니 이건 뭔 타입이야"** 한 겁니다. 
t 와 u 의 정의가 decltype 나중에 나오기 때문이지요. 
```c++
template <typename T, typename U>
decltype(t + u) add(T t, U u) {
  return t + u;
} // Compile Error
```
<br>
이러한 경우에 우리는 Trailing Return Type이라는 문법을 사용해서 return type 추론을 뒤로 미룰 수 있습니다. 
참고로 엠비션에서는 Trailing Return Type을 return type 추론을 뒤로 미뤄야하는 경우가 아니더라도 대부분의 코드에서 적극 사용하고 있는 것을 본적이 있습니다. 
(물론 제가 봤던 코드에서는 그런데 아닌 코드가 있을 수 도 있습니다 ^_^)
```c++
template <typename T, typename U>
auto add(T t, U u) -> decltype(t + u) {
  return t + u;
} // OK, Good
```

#### std::declval
* * *
다음으로 알아볼 것은 std::declval 함수 입니다. declval 은 decltype 과는 다르게 키워드가 아닌 <utilty> 에 정의된 함수 입니다.
  
예를 들어서 어떤 타입 T 의 f 라는 함수의 리턴 타입을 정의하고 싶다고 해봅시다. 그렇다면 decltype 를 이용하면 아래와 같은 코드를 작성할 수 있을 것입니다.

```c++
struct A // struct는 모든 멤버가 public인 class 
{
  int f() { return 0; }
};

struct B {
  B(int x) {} // 생성자를 재정의 했기 때문에, 기본 생성자는 없습니다.
              // 사용자 실수를 방지하기 위해 인터페이스 설계자는 
              // 기본 생성자를 제공하지 않기로 했다고 가정합시다.
  int f() { return 0; }
};

int main()
{
    decltype(A().f()) ret_val; // int ret_val; 이 된다
    
    /* Compile Error*/
    // decltype(B().f()) ret_val; 

    decltype(B(1).f()) ret_val; // OK
}
```

하지만, 만약 아래와 같은 템플릿을 사용해야하는 상황이라면 어떨까요? 
B는 기본 생성자가 없으므로 아래 정의된 template을 사용할 수 없을 것 입니다.
```c++
template <typename T>
decltype(T().f()) call_f_and_return(T& t) {
  return t.f();
}
```

이러한 상황에서 아래와 같이 std::declval을 사용할 수 있습니다.

```c++
// A, B 정의
...
...
template <typename T>
decltype(std::declval<T>().f()) call_f_and_return(T& t) {
  return t.f();
}

int main() 
{   
    A a;
    B b(1);

    call_f_and_return(a);  // ok
    call_f_and_return(b);  // ok

    /* 참고로 Runtime 사용시 Error */
    // B b = std::declval<B>();  
}
```
<br>
그런데 말입니다... 참고로 지금까지 설명드린 내용이 무색하게도.... 
C++ 14 부터는 함수의 리턴 타입을 컴파일러가 알아서 유추해주는 기능이 추가되었습니다. 이 경우 그냥 함수 리턴 타입을 auto 로 지정해주면 됩니다.

```c++
// Trailing Return Type도 사용안하고 auto만 사용하고 있습니다.
template <typename T>
auto call_f_and_return(T& t) {
  return t.f();
}
```
<br>
그렇다면 declval의 쓰임새가 무용해지냐?라고 하면 그것은 아닙니다. 
일단 기본적으로 사용하고 있던 레거시 코드들을 이해하기 위해서 알아야하겠지요. 또한 <type_traits> 라이브러리를 다루면서 
decltype과 std::declval을 사용한 놀라운 템플릿 메타프로그래밍 기법들이 있습니다.

#### SFINAE - 치환 오류는 컴파일 오류가 아니다 (Substitution failure is not an error)
* * *
- 진행 중

#### type_traits & enable_if
* * *
- 진행중

#### 그래서 구체적으로 어디에 활용할 수 있나요?
* * *
다음 기회에...