---
published: true
layout: single
title: "C++11에서 추가된 라이브러리를 배워서 복잡한 템플릿을 분석해보자(type_traits, SFINAE, enable_if, declval)"
category: seminar
tags:
comments: true
sidebar:
  nav: "mainMenu"
---  
* * *

#### 복잡한 템플릿 코드를 분석해보자
* * *

오픈 소스, C++ Reference 페이지 등의 코드에서 아래처럼 매우 복잡한 템플릿 코드를 보신적이 있을텐데요.
  
이 시간을 통해서 아래 코드를 어느 정도? 해석할 수 있도록 C++11부터 추가 된 몇가지 라이브러리를 배워보도록 하겠습니다.
  
참고로 아래 코드는 basic_ostream의 operator<< 오버로딩 함수 중 std::unique_ptr<T>에 해당하는 구현부 입니다.

```c++
template <class _CharT, class _Traits, class _Yp, class _Dp>
typename enable_if<
  is_same<void, typename __void_t<decltype(
                  (declval<basic_ostream<_CharT, _Traits>&>() << declval<
                     typename unique_ptr<_Yp, _Dp>::pointer>()))>::type>::value,
  basic_ostream<_CharT, _Traits>&>::type
operator<<(basic_ostream<_CharT, _Traits>& __os,
           unique_ptr<_Yp, _Dp> const& __p) {
  return __os << __p.get();
}
```

```c++
#include <iostream>
#include <memory>

int main() {
	std::unique_ptr<int> test = std::make_unique<int>(1);

	std::cout << "주소 : " << test << std::endl;
	std::cout << "주소 : " << test.get() << std::endl;
}
```
```
-----------------------
주소 : 01340550
주소 : 01340550
-----------------------
```

#### 템플릿 메타 함수
* * *
위 코드를 해석하려면, 가장 먼저 템플릿 메타 함수라는 것에 대해 알아야 합니다.
  
템플릿 메타 함수란 함수는 아니지만, 함수처럼 동작하는 템플릿 클래스들을 말합니다. 보통의 함수들은 
값에 대한 연산을 수행하지만, 템플릿 메타 함수는 타입에 대한 연산을 수행합니다.
  
```c++
// 일반적인 함수
if( is_negative(x) )
{
    // Do something.
}

// 템플릿 메타 함수
if( is_void<T>::value )
{
    // Do something.
    // 템플릿 인자 T의 type이 void일 경우에만 참
}
```
<br>
그리고 is_void의 실제 구현은 아래와 같이 되어 있습니다. void에 대한 함수 템플릿 특수화를 해서 
템플릿 인자가 void일 경우에만 value 값이 상수값 true가 되도록 구현되어 있습니다.
  
일반적인 모든 타입에 대해서는 false로 초기화되고, void 타입에 대해서만 true로 초기화 되겠지요.

```c++
template <typename T>
struct is_void 
{
  static constexpr bool value = false;
};

template <>
struct is_void<void> 
{
  static constexpr bool value = true;
};
```
<br>
참고로 constexpr의 경우 컴파일 타임에 해당 값이 상수라고 명시해주는 키워드 입니다.
const와 다른 점은 const는 해당 값이 컴파일 타임에 상수 값으로 초기화 되는 것을 보장하지 않습니다.
경우에 따라 런타임에 상수로 초기화 될 수 있다는 차이점이 있습니다.

#### SFINAE (Substitution Failure Is Not An Error)
* * *
이번에는 C++ 컴파일러의 Template 관련 인자 추론 동작에서 중요한 원칙을 알아보겠습니다. SFINAE라고 하는 원칙인데요.
  
바로 치환 오류는 컴파일 오류가 아니다 (Substitution Failure Is Not An Error) 흔히 줄여서 SFINAE 라는 원칙 때문에, 
**템플릿 인자 치환 후에 만들어진 식이 문법적으로 맞지 않는다면, 컴파일 오류를 발생 시키는 대신 단순히 함수의 오버로딩 후보군에서 제외만 시키게 됩니다.**


```c++
#include <iostream>

template <typename T>
void test(typename T::x a) {
  std::cout << "T::x \n";
}

template <typename T>
void test(typename T::y b) {
  std::cout << "T::y \n";
}

struct A {
  // type alias
  // typedef 같은 역할
  using x = int;
};

struct B {
  using y = int;
};

int main() {
  test<A>(33);
  test<B>(22);
}

----------------
T::x 
T::y
----------------
```
<br>
참고로 위 코드에서 함수의 파라미터에 typename이라는 키워드가 붙어 있는 이유는 
템플릿 인자 추론 과정에서 파라미터가 중첩의존타입이기 때문에 해당 템플릿 인자는 타입명이라고 명시해준 것 입니다.
  
예를 들어 아래와 같은 코드에서 C::const_iterator*는 포인터형 변수로 해석되는 것이 아니라 C::const_iterator 와 x의 곱으로 해석되어 빌드에러가 발생하게 됩니다.
  
그러므로 만약 템플릿 인자 추론 과정에서 중첩의존타입이 있는 경우, typename 키워드를 사용해야만 컴파일 에러를 막을 수 있습니다.

```c++
template<typename C>
void print2nd(const C* container)
{
    C:const_iterator * x;
    ...
    ...
}
```


#### declval & decltype
* * *



#### enable_if
* * *


#### Reference 
* * * 
- ***<https://modoocode.com/295>***