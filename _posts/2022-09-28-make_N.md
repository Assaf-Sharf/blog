---
layout: single
title:  "N으로 표현"
categories: Programmers, Class2
tag: [DP]
toc: true
author_profile: false
sidebar: 
nav: "docs"
---

# N으로 표현, Programmers

## 최초 접근법

처음에는 BFS로 접근하였다. Queue를 돌면서 해당하는 숫자가 나올 경우 반환하는 식으로 구성하였다. 

- 숫자를 2번 사용하는 경우의 수는 1번 사용하는 경우의 수에서 연산을 한번 더 한 경우이다. 

- 숫자를 3번 사용하는 경우의 수는 2번 사용하는 경우의 수에 서 연산을 한번 더 한 경우이다.  

## 최초 코드

```python
from collections import deque


q = deque()

calculate = ['+', '-', '*', '//']


def solution(N, number):
    visited = dict()
    q.append((N, 1))
    visited[N] = 1

    while q:
        num, ans = q.popleft()
        print(num, ans)
        print(visited)

        #범위를 초과할 경우
        if ans > 7:
            return -1


        # 이전의 연산에서 사칙연산을 해준다.
        for i in range(4):
            if calculate[i] == '+':
                if num + N == number:
                    print(num, calculate[i])
                    return ans + 1
                else:
                    if (num + N) not in visited:
                        q.append((num+N, ans+1))
                        visited[num+N] = ans+1
            elif calculate[i] == '-':
                if num - N == number:
                    print(num, calculate[i])
                    return ans + 1
                else:
                    if (num - N) not in visited:
                        q.append((num-N, ans+1))
                        visited[num-N] = ans+1
            elif calculate[i] == '*':
                if num * N == number:
                    print(num, calculate[i])
                    return ans + 1
                else:
                    if (num * N) not in visited:
                        q.append((num*N, ans+1))
                        visited[num*N] = ans+1
            elif calculate[i] == '//':
                if num // N == number:
                    print(num, calculate[i])
                    return ans + 1
                else:
                    if (num // N) not in visited:
                        q.append((num//N, ans+1))
                        visited[num//N] = ans+1

        if int(str(N)*(ans+1)) == num:
            return ans+1
        else:
            if (int(str(N)*(ans+1))) not in visited:
                q.append((int(str(N)*(ans+1)), ans+1))
                visited[int(str(N)*(ans+1))] = ans+1

        # visited의 연산 결과값과 연산하였을 때
        for i in visited:
            if num + i == number and ans + visited[i] <= 8:
                print(num, i)
                return ans + visited[i]
            elif num - i == number and ans + visited[i] <= 8:
                print(num, i)
                return ans + visited[i]
            elif num * i == number and ans + visited[i] <= 8:
                print(num, i)
                return ans + visited[i]
            elif i != 0 and num // i == number and ans + visited[i] <= 8:
                print(num, i)
                return ans + visited[i]
```

## 설명

- 최초 접근법과 동일한 논리의 접근법으로 접근하였다. 

- 다만, 2번 연산한 것과 2번 연산한 것끼리의 연산을 하는 경우와 같은 경우도 있기 때문에 visited에 있는 숫자들과의 연산도 포함하여 계산하였다. 

이와 같은 경우로 접근하는 경우 더 적은 연산인 경우가 존재하지만, visited에서 연산하는 경우가 먼저 나와 더 큰 수가 정답으로 처리되는 오류가 있었다. 

## 수정된 접근법

- 해당 문제는 DP로 접근하면 굉장히 용이하다. 

- 이전의 결과값이 현재의 결과에 영향을 미치는 경우 dp를 고려해볼만 하다. 

## 수정된 코드

```python
def solution(N, number):
    dp = []

    for i in range(1, 9):
        nums = set()
        # 숫자 이어붙이기 추가
        string_num = int(str(N) * i)
        nums.add(string_num)

        for j in range(0, i-1):
            for x in dp[j]:
                for y in dp[-j-1]: # 뒤에서부터
                    nums.add(x + y)
                    nums.add(x-y)
                    nums.add(x*y)
                    if y != 0:
                        nums.add(x//y)

        if number in nums:
            return i

        dp.append(nums)
```

## 설명

- dp 리스트를 만들어 연산 횟수별로 indexing하여 검사한다.

- 중복된 결과를 막기위해 set을 만들어 준다. 

- 숫자를 이어붙이는 경우 연산과는 무관하므로 따로 처음에 추가해준다. 

- 이전의 연산의 결과 값들을 for문과 indexing을 활용하여 모든 경우의 수와 연산이 될 수 있도록 한다. 

- dp의 i번째 set에는 i번 연산한 경우의 수들이 들어있게 된다.

![KakaoTalk_20220928_161409797](../../images/2022-09-28-make_N/KakaoTalk_20220928_161409797.jpg)

위 그림을 참고하면 조금 더 이해하기 쉽다.

## 요점 및 배운점

문제를 보고 dp를 떠올리지 못하였다. 아무래도 dp에 대한 경험이 부족한 탓인 것 같다. 좀 더 익숙해질 수 있도록 dp문제들을 더 많이 풀어봐야겠다. 

- 이전의 결과값이 현재의 결과에 영향을 미친다면 dp를 떠올려보자.

- 조금 복잡할 수 있는 indexing이 잘 떠올려지지 않는 것 같다. 꾸준히 문제 풀면서 감을 잃지 않도록 유지하자.
