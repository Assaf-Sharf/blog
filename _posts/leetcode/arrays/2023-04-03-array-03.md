---
title: "[Arrays] Squares of a Sorted Array"

categories:
  - Arrays
tags:
  - [Squares]

toc: true
toc_sticky: true

date: 2023-04-03
last_modified_at: 2023-04-03
---

<!-- {% capture notice-2 %}

üìã This is the tech-news archives to help me keep track of what I am interested in!

- Reference tech news link: <https://thenextweb.com/news/blockchain-development-tech-career>
  {% endcapture %}

<div class="notice--danger">{{ notice-2 | markdownify }}</div> -->

üìã This is my note-taking from what I learned in LeetCode!
{: .notice--danger}

# Problem

Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.

> Example 1:
>
> - Input: nums = [-4,-1,0,3,10]
> - Output: [0,1,9,16,100]
> - Explanation: After squaring, the array becomes [16,1,0,9,100].
> - After sorting, it becomes [0,1,9,16,100].

> Example 2:
>
> - Input: nums = [-7,-3,2,3,11]
> - Output: [4,9,9,49,121]

Constraints:

- 1 <= nums.length <= 10<sup>4</sup>
- -10<sup>4</sup> <= nums[i] <= 10<sup>4</sup>
- nums is sorted in non-decreasing order.

Follow up: Squaring each element and sorting the new array is very trivial, could you find an O(n) solution using a different approach?

<br>

# Solution

## Approach 1: Sort

Algorithm:

1. Get the length of the input array nums.
2. Create a new array array of the same length as nums.
3. Loop through the input array nums, and for each element:
   : Calculate the square of the current element and assign it to the corresponding element in the array.
4. Sort the array in ascending order.
5. Return the sorted array.

{% capture notice-2 %}

Complexity Analysis

- Time Complexity: O(NlogN), where N is the length of nums.
- Space complexity: O(N) or O(logN).
  : The space complexity of the sorting algorithm depends on the implementation of the sorting function used. In C#, the Array.Sort() function is implemented as a variant of quicksort algorithm whose space complexity is O(logN). However, if the array is highly structured (has few sorted sub-arrays), then linear space may be used instead.
  {% endcapture %}

<div class="notice--info">{{ notice-2 | markdownify }}</div>

```
using System;

namespace square_sorted
{
  class Program
  {
    static void Main(string[] args)
    {
      int[] array = new int[] { -4, -1, 0, 3, 10 };
      int[] result = SortedSquares(array);
      Console.WriteLine(string.Join(", ", result));
    }

    public static int[] SortedSquares1(int[] nums)
    {
      int N = nums.Length;
      int[] result = new int[N];

      for (int i = 0; i < N; ++i)
      {
        result[i] = nums[i] * nums[i];
      }

      Array.Sort(result);
      return result;
    }
  }
}
```

<br>

## Approach 2: Two Pointer

Since the array A is sorted, loosely speaking it has some negative elements with squares in decreasing order, then some non-negative elements with squares in increasing order.

For example, with [-3, -2, -1, 4, 5, 6], we have the negative part [-3, -2, -1] with squares [9, 4, 1], and the positive part [4, 5, 6] with squares [16, 25, 36]. Our strategy is to iterate over the negative part in reverse, and the positive part in the forward direction.

Algorithm:

1. Initialize two pointers i and j at the beginning and end of the array respectively.
2. Initialize an empty array result of length n.
3. Loop through the result array from index n-1 to 0.
4. If the absolute value of A[i] is greater than the absolute value of A[j], square A[i] and assign it to the current index in the result array. Increment i.
5. Otherwise, square A[j] and assign it to the current index in the result array. Decrement j.
6. Return the result array.

{% capture notice-2 %}

Complexity Analysis

- Time complexity: O(N), where N is the length of the input array.
- Space complexity: O(N) if you take the output into account, and O(1) otherwise.
  {% endcapture %}

<div class="notice--info">{{ notice-2 | markdownify }}</div>

```
using System;

namespace square_sorted
{
  class Program
  {
    static void Main(string[] args)
    {
      int[] array = new int[] { -4, -1, 0, 3, 10 };
      int[] result = SortedSquares2(array);
      Console.WriteLine(string.Join(", ", result));
    }

    public static int[] SortedSquares2(int[] nums)
    {
      int N = nums.Length;
      int[] result = new int[N];
      int left = 0;
      int right = N - 1;

      for (int i = N - 1; i >= 0; i--)
      {
        int square;
        if (Math.Abs(nums[left]) < Math.Abs(nums[right]))
        {
          square = nums[right];
          right--;
        }
        else
        {
          square = nums[left];
          left++;
        }
        result[i] = square * square;
      }
      return result;
    }
  }
}
```

<br>

# For better understanding

## Console.WriteLine(string.Join(", ", result));

"Console.WriteLine()" is a method used in C# to print output to the console. "string.Join()" is a method that concatenates a specified separator string between each element of an array and returns the concatenated string.

In this case, "string.Join(", ", result)" takes the result array and concatenates each element with a comma and space separator (", ") in between. This creates a single string that can be printed to the console using "Console.WriteLine()".

So "Console.WriteLine(string.Join(", ", result))" prints each element of the result array to the console, separated by a comma and space.

## Array.Sort(result);

"Array.Sort(result);" is a method in C# that sorts the elements of an array in ascending order. In this particular context, it sorts the elements in the "result" array in ascending order after they have been squared and added to the "result" array.

The "Array.Sort" method uses the quicksort algorithm, which has an average time complexity of O(n log n), where n is the length of the array being sorted. In the worst case, quicksort has a time complexity of O(n^2), but this is rare and unlikely to occur in practice.

## Math.Abs(nums[left]) < Math.Abs(nums[right])

"Math.Abs()" is a built-in method in C# that returns the absolute value of a number. The "Math.Abs()" method is used to get the absolute values of "nums[left]" and "nums[right]" to compare their magnitudes without considering their signs.

<br>

---

<br>

    üñãÔ∏è This is my self-taught blog! Feel free to let me know
    if there are some errors or wrong parts üòÜ

[Back to Top](#){: .btn .btn--primary }{: .align-right}
