---
title: "[Arrays] Sort Array By Parity"

categories:
  - Arrays
tags:
  - [Sort]

toc: true
toc_sticky: true

date: 2023-05-06
last_modified_at: 2023-05-08
---

<!-- {% capture notice-2 %}

📋 This is the tech-news archives to help me keep track of what I am interested in!

- Reference tech news link: <https://thenextweb.com/news/blockchain-development-tech-career>
  {% endcapture %}

<div class="notice--danger">{{ notice-2 | markdownify }}</div> -->

📋 This is my note-taking from what I learned in LeetCode!
{: .notice--danger}

<br>

# Problem

[Problem Link](https://leetcode.com/explore/learn/card/fun-with-arrays/511/in-place-operations/3260/)

Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.

Return any array that satisfies this condition.

Example 1:

- Input: nums = [3,1,2,4]
- Output: [2,4,3,1]
- Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.

Example 2:

- Input: nums = [0]
- Output: [0]

Constraints:

1 <= nums.length <= 5000
0 <= nums[i] <= 5000

<br>

# Solution

[Solution Link](https://leetcode.com/problems/sort-array-by-parity/editorial/)

## Approach 1: Sort

Use a custom comparator when sorting, to sort by parity.

Algorithm:

1. Sort the input list "nums" based on the remainder of each element when divided by 2. The key function used for sorting is a lambda function that returns the result of x%2 for each element x in the list.
2. Return the sorted list as the output. The sorted list will have all the even numbers first, followed by all the odd numbers.

```
def sortArrayByParity(nums: list[int]) -> list[int]:
    nums.sort(key=lambda x: x % 2)
    return nums

nums = [3, 1, 2, 4]
sorted_nums = sortArrayByParity(nums)
print(sorted_nums)
```

> 코드 설명
>
> - 람다(lambda) 함수를 사용해서 리스트 내의 값을 2로 나눈 나머지 값을 구합니다.
> - sort를 사용해 나머지 값들을 정렬합니다.
> - 따라서 해당 nums 리스트를 반환하면, 짝수가 먼저 오고 홀수가 나중에 오는 리스트를 구할 수 있습니다.

Complexity Analysis

- Time Complexity: O(Nlog⁡N), where N is the length of A.
- Space Complexity: O(N) for the sort, depending on the built-in implementation of sort.

<br>

## Approach 2: Two Pass

Algorithm:

```
def sortArrayByParity(nums: list[int]) -> list[int]:
    return [x for x in nums if x % 2 == 0] + [x for x in nums if x % 2 == 1]

nums = [3, 1, 2, 4]
sorted_nums = sortArrayByParity(nums)
print(sorted_nums)
```

> 코드 설명
>
> - 2로 나눈 나머지가 0인 짝수 값들을 구하고, 나머지가 1인 홀수 값들을 구합니다.
> - 짝수 리스트와 홀수 리스트를 + 연산자를 사용하여 이어 붙인 후 결과를 반환합니다.

Complexity Analysis

- Time Complexity: O(N), where N is the length of A.
- Space Complexity: O(N), the space used by the answer.

<br>

## Approach 3: In-Place

If we want to do the sort in-place, we can use quicksort, a standard textbook algorithm.

Algorithm:

We'll maintain two pointers i and j. The loop invariant is everything below i has parity 0 (ie. A[k] % 2 == 0 when k < i), and everything above j has parity 1.

Then, there are 4 cases for (A[i] % 2, A[j] % 2):

- If it is (0, 1), then everything is correct: i++ and j--.
- If it is (1, 0), we swap them so they are correct, then continue.
- If it is (0, 0), only the i place is correct, so we i++ and continue.
- If it is (1, 1), only the j place is correct, so we j-- and continue.

Throughout all 4 cases, the loop invariant is maintained, and j-i is getting smaller. So eventually we will be done with the array sorted as desired.

```
def sortArrayByParity(nums: list[int]) -> list[int]:
    i, j = 0, len(nums) - 1
    while i < j:
        if nums[i] % 2 > nums[j] % 2:
            nums[i], nums[j] = nums[j], nums[i]
        if nums[i] % 2 == 0:
            i += 1
        if nums[j] % 2 == 1:
            j -= 1
    return nums

nums = [3, 1, 2, 4]
sorted_nums = sortArrayByParity(nums)
print(sorted_nums)
```

> 코드 설명
>
> - Two Pointers 알고리즘을 사용합니다.
> - 하나의 포인터는 왼쪽 끝에서 시작하고 다른 하나의 포인터는 오른쪽 끝에서 시작합니다.
> - 포인터 i와 j를 각각 리스트의 왼쪽 끝과 오른쪽 끝에 위치시킵니다.
> - 만약 nums[i]가 홀수이고 nums[j]가 짝수이면, 두 값의 위치를 서로 바꿉니다.
> - 만약 nums[i]가 짝수이면, i를 증가시킵니다.
> - 만약 nums[j]가 홀수이면, j를 감소시킵니다.
> - 이렇게 하면, i와 j가 교차하는 시점에는 모든 짝수가 리스트의 왼쪽에 모이고, 모든 홀수가 리스트의 오른쪽에 모이게 됩니다.
> - 그리고 그 결과를 반환합니다.

Complexity Analysis

- Time Complexity: O(N), where N is the length of A. Each step of the while loop makes j-i decrease by at least one. (Note that while quicksort is O(Nlog⁡N) normally, this is O(N) because we only need one pass to sort the elements.)
- Space Complexity: O(1) in additional space complexity.

<br>

---

<br>

    🖋️ This is my self-taught blog! Feel free to let me know
    if there are some errors or wrong parts 😆

[Back to Top](#){: .btn .btn--primary }{: .align-right}
