---
title: "[Arrays] Sort Array By Parity"

categories:
  - Arrays
tags:
  - [Sort]

toc: true
toc_sticky: true

date: 2023-05-06
last_modified_at: 2023-05-06
---

<!-- {% capture notice-2 %}

📋 This is the tech-news archives to help me keep track of what I am interested in!

- Reference tech news link: <https://thenextweb.com/news/blockchain-development-tech-career>
  {% endcapture %}

<div class="notice--danger">{{ notice-2 | markdownify }}</div> -->

📋 This is my note-taking from what I learned in LeetCode!
{: .notice--danger}

<br>

# Problem

[Problem Link](https://leetcode.com/explore/learn/card/fun-with-arrays/511/in-place-operations/3260/)

Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.

Return any array that satisfies this condition.

Example 1:

- Input: nums = [3,1,2,4]
- Output: [2,4,3,1]
- Explanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.

Example 2:

- Input: nums = [0]
- Output: [0]

Constraints:

1 <= nums.length <= 5000
0 <= nums[i] <= 5000

<br>

# Solution

[Solution Link](https://leetcode.com/problems/sort-array-by-parity/editorial/)

## Approach 1: Sort

Use a custom comparator when sorting, to sort by parity.

Algorithm:

1. Sort the input list "nums" based on the remainder of each element when divided by 2. The key function used for sorting is a lambda function that returns the result of x%2 for each element x in the list.
2. Return the sorted list as the output. The sorted list will have all the even numbers first, followed by all the odd numbers.

```
def sortArrayByParity(nums: list[int]) -> list[int]:
    nums.sort(key=lambda x: x % 2)
    return nums

nums = [3, 1, 2, 4]
sorted_nums = sortArrayByParity(nums)
print(sorted_nums)
```

> 코드 설명
>
> - 람다(lambda) 함수를 사용해서 리스트 내의 값을 2로 나눈 나머지 값으로 정렬합니다.
> -

Complexity Analysis

- Time Complexity: O(Nlog⁡N), where N is the length of A.
- Space Complexity: O(N) for the sort, depending on the built-in implementation of sort.

<br>

## Approach 2: (Space Optimal, Operation Sub-Optimal) [Accepted]

This is a 2 pointer approach. The fast pointer which is denoted by variable "cur" does the job of processing new elements. If the newly found element is not a 0, we record it just after the last found non-0 element. The position of last found non-0 element is denoted by the slow pointer "lastNonZeroFoundAt" variable. As we keep finding new non-0 elements, we just overwrite them at the "lastNonZeroFoundAt + 1" 'th index. This overwrite will not result in any loss of data because we already processed what was there(if it were non-0,it already is now written at it's corresponding index,or if it were 0 it will be handled later in time).

After the "cur" index reaches the end of array, we now know that all the non-0 elements have been moved to beginning of array in their original order. Now comes the time to fulfil other requirement, "Move all 0's to the end". We now simply need to fill all the indexes after the "lastNonZeroFoundAt" index with 0.

Algorithm:

1. Initialize a variable lastNonZeroFoundAt to 0.
2. Loop through the input array nums and check if the current element is non-zero.
3. If the current element is non-zero, append it to the position just in front of the last non-zero element found, which is indicated by the lastNonZeroFoundAt variable, and increment lastNonZeroFoundAt.
4. After all non-zero elements are processed, all the non-zero elements will be at the beginning of the array, up to the lastNonZeroFoundAt index. Fill the remaining indices with zeros.

```
def moveZeroes(nums: list[int]) -> None:
    lastNonZeroFoundAt = 0
    for i in range(len(nums)):
        if nums[i] != 0:
            nums[lastNonZeroFoundAt] = nums[i]
            lastNonZeroFoundAt += 1

    for i in range(lastNonZeroFoundAt, len(nums)):
        nums[i] = 0

nums = [0, 1, 0, 3, 12]
moveZeroes(nums)
print(nums)
```

> 코드 설명
>
> - 0이 아닌 경우 해당 값을 리스트에 할당합니다.
> - 그러면 0이 아닌 값이 리스트의 처음에 위치하게 되므로, 나머지 리스트를 0으로 채웁니다.

Complexity Analysis

- Space Complexity : O(1). Only constant space is used.
- Time Complexity: O(n). However, the total number of operations are still sub-optimal. The total operations (array writes) that code does is nnn (Total number of elements).

<br>

## Approach 3: (Optimal) [Accepted]

The optimal approach is again a subtle extension of above solution. A simple realization is if the current element is non-0, its' correct position can at best be it's current position or a position earlier. If it's the latter one, the current position will be eventually occupied by a non-0 ,or a 0, which lies at a index greater than 'cur' index. We fill the current position by 0 right away,so that unlike the previous solution, we don't need to come back here in next iteration.

In other words, the code will maintain the following invariant:

1. All elements before the slow pointer (lastNonZeroFoundAt) are non-zeroes.
2. All elements between the current and slow pointer are zeroes.

Therefore, when we encounter a non-zero element, we need to swap elements pointed by current and slow pointer, then advance both pointers. If it's zero element, we just advance current pointer.

With this invariant in-place, it's easy to see that the algorithm will work.

Algorithm:

- Initialize a variable lastNonZeroFoundAt to 0.
- Iterate over the input list nums using a for loop with a variable cur.
- If the current element of nums is not 0:
  : - Swap the current element with the element at index lastNonZeroFoundAt.
  : - Increment lastNonZeroFoundAt by 1.
- The resulting list will have all the non-zero elements appear before the zeros.

```
def moveZeroes(nums: list[int]) -> None:
    lastNonZeroFoundAt = 0
    for cur in range(len(nums)):
        if nums[cur] != 0:
            nums[lastNonZeroFoundAt], nums[cur] = nums[cur], nums[lastNonZeroFoundAt]
            lastNonZeroFoundAt += 1

nums = [0, 1, 0, 3, 12]
moveZeroes(nums)
print(nums)
```

> 코드 설명
>
> - 현재 요소가 0이 아닌 경우, 현재 요소를 lastNonZeroFoundAt 위치의 요소와 교환합니다.
> - 해당 리스트를 반환합니다.

Complexity Analysis

- Space Complexity : O(1). Only constant space is used.
- Time Complexity: O(n). However, the total number of operations are optimal. The total operations (array writes) that code does is Number of non-0 elements.This gives us a much better best-case (when most of the elements are 0) complexity than last solution. However, the worst-case (when all elements are non-0) complexity for both the algorithms is same.

<br>

# For Better Understanding

## "key = lambda x: x % 2"

"key = lambda x: x % 2" is a lambda function that is used as the sorting key for the sort() method. In this case, the lambda function takes an integer x and returns its remainder when divided by 2.

When sort() method is called, it sorts the array in-place based on the result of this lambda function, which will be either 0 or 1, with even numbers coming first and odd numbers coming after them.

In Python, lambda is a keyword used to define an anonymous function, which is a function without a name. It is a small, anonymous function that can have any number of arguments but only one expression. The expression is evaluated and returned when the function is called.

The general syntax for a lambda function is:

```
lambda arguments: expression
```

Here, arguments represent the input arguments to the function and expression represents the operation or computation that the function is supposed to perform on those arguments.

The lambda function can be assigned to a variable and used like a regular function. It is often used as a throwaway function or a short function that you only need to use once.

For example, the following lambda function takes two arguments and returns their sum:

```
add = lambda x, y: x + y
```

This can be used in the same way as a normal function:

```
>>> add(2, 3)
5
```

<br>

---

<br>

    🖋️ This is my self-taught blog! Feel free to let me know
    if there are some errors or wrong parts 😆

[Back to Top](#){: .btn .btn--primary }{: .align-right}
