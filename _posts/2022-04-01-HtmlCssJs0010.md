---
layout: single
title: "반응형 홈페이지 만들기 - 009"
categories: CSS
tag: [HTML, CSS, JavaScript, 자바스크립트, js]
toc: true
author_profile: false
toc: false
sidebar:
nav: "docs"
search: true
---

<center>**[공지사항]** <strong> [개인적인 공부를 위한 내용입니다. 오류가 있을 수 있습니다.] </strong></center>
{: .notice--success}


<h2>[반응형 홈페이지 만들기-009]</h2>


<h3> Section 內 화살표 이동 버튼 기능 구현</h3>

<div align="center">
<img src="https://github.com/Gibson1211/Gibson1211.github.io/blob/master/assets/images/moveButton.jpg?raw=true" width="600"><br>
</div>
<br>
<h6> 첫째 화살표 아이콘의 작동과 관련된 class-card 태그는 ul 태그에서 시작이 된다.<br>그래서 ul태그에 기준 시작점을 세팅할 필요가 있고 그 시작점으로 부터 어느만큼 이동했는지 그 값을 활용하여 기능 구현을 할 수 있다.<br>이를 구현하는 방법으로는 HTML5에서 태그에 변수선언 및 변수값 지정으로 구현할 수 있는데 변수값을 넣고자 할때 <br>"data-변수이름=변수값"으로 작성하면 된다.<br>따라서 여기에서는 data-position="0"으로 작성을 하였다[data-변수이름(position)=변수값("0")]. <br>index.html 內 모든 ul 태그에 적용해야 한다.</h6>

<h6>두번째는 여러개의 class-list에는 각각의 화살표 아이콘있기에 하나의 화살표 아이콘을 눌렀을 때<br> 이에 해당하는 class-list와 class-card만 동작해야 한다.<br> 동일한 영역에 존재하지 않는 것들은 동작해서 안되는 것이다. <br>따라서 해당 화살표 아이콘과 해당 class-list & class-card간 연관관계는<br> 위치값을 이용한 인자(ex. nextsibling 등)를 이용해서 설정해야 한다. <br>연관관계를 정상적으로 찾은 경우 li 태그 내 class-card의 총 갯수를 계산하고 <br>또한 화면에 보여질 class-card 숫자를 계산해서 li 태그 내 class-card 숫자가 <br>화면에 보여지는 class-card보다 큰 경우에만 화살표 아이콘이 보이고, 작동되어야 한다. <br>여기에 화면의 위치가 우측 시작점이라면 우측 화살표는 비활성화 되어야 하고 <br>좌측 끝지점이라면 좌측 화살표가 비활성화 되어야 한다. <br>다만 li 태그 내 class-card 숫자가 화면보다 적다면 화살표가 보여질 필요도 없고 작동할 필요도 없다. <br>이러한 조건을 토대로 코드는 작성되어져야 한다.   </h6>

```html
<!-- HTML5에서는 태그에 확장적인 처리를 위해 변수값을 넣고자 할때 "data-변수이름=변수값"으로 작성하면 된다.
     따라서 여기에서는 data-position="0"으로 작성을 하였다.  -->
<ul class="class-list" data-position="0">
  <li class="class-card">
    <a href="https://gibson1211.github.io/" target="_blank"><img src="https://github.com/Gibson1211/Gibson1211.github.io/blob/master/assets/images/itpartImage.JPG?raw=true" alt="IT분야" class="class-image" />
      <div class="class-container">
        <div class="class-skill">
          <div class="class-type">제목1</div>
          <div class="class-format">제목2</div>
        </div>
```
<br>

<h6>style.css는 아래와 같이 작성한다.</h6>

```css
#backtotop { /* id 호출은 #으로 */
  background-color: rgb(47, 48, 89);
  width: 40px;
  height: 40px;
  text-align: center;

  border-radius: 20px; /* 정사각형인 박스의 border-radius를 중간값을 적용해주면 원이 된다. 여기서는 20px */
  position: fixed; /* 고정해야 하며 따라서 아래의 위치값이 필요함 */
  bottom: 30px;
  right: 30px;
  transition-property: background-color, opacity, visibility; /* 약간의 움직임 효과를 주기 위함 */
  transition-duration: 0.3s, 0.5s, 0.5s;
  opacity: 0; /* 투명도를 0으로 */
  visibility: hidden;  /* 맨처음에는 안보이게끔한다. */
  z-index: 999;  /* 이 박스(아이콘)가 보여지게 되면 최상단에 보여져야 한다는 의미로 999 적용 */
}

/* 아이콘을 만들고자 할 때 적용 방법
  1. ::after (요소 뒤에 content 추가) 가상 요소에서,
  2. content: "폰트어썸 유니코드" 를 넣고,
  3. font-family: FontAwesome 이라고 넣으면 됨
  */
#backtotop::after { /* 즉 위에 정의한 backtotop의 뒤에 적용할 가상 요소라는 의미임 */
  content: "\f077";  /*  폰트어썸 유니코드를 넣을때 앞에 역슬래쉬[\]를 꼭 넣어줘야 한다. */
  font-family: FontAwesome;
  font-size: 1.5rem;
  line-height: 40px; /* 아이콘을 중간에 놓으려면 line-height를 backtotop의 height값과 동일하게 적용 시 수직 정렬됨  */
  color: #fff;
}

#backtotop.show:hover {
  cursor: pointer; /* 커서를 손모양으로 바꾸기 */
  background-color: #2186c4; /* 컬러를 바꾸기 */
}

#backtotop.show {
  opacity: 1; /* 불투명 100%로 backtotop이 보여진다 */
  visibility: visible; /* 보이게한다. */
  background-color: rgb(47, 48, 49);
}
```
<br>
<h6>backtotop 아이콘은 화면이 가장 상단으로 올라와 있는 경우에는 화면에서 보여질 필요가 없고<br> 스크롤 다운이 된 경우에 보여지게끔 기능을 구현한다. 또한 클릭 시 화면은 최상단으로 이동되어져야 되고<br> 아이콘은 사라져야 한다. <br>이러한 기능을 구현하기 위해서는 자바스크립트를 사용해야 한다.<br>js 폴더 內 main.js를 생성하고 아래와 같이 작성한다.</h6>

```js
/*----------------------------------------------------------------------*/

function transformNext(event) {
  const slideNext = event.target;
  const slidePrev = slideNext.previousElementSibling;

  const classList = slideNext.parentElement.parentElement.nextElementSibling;
  let activeLi = classList.getAttribute('data-position');
  const liList = classList.getElementsByTagName('li');

  // 하나의 카드라도 왼쪽으로 이동했다면, 오른쪽으로 갈 수 있음
  if (Number(activeLi) < 0) {
    activeLi = Number(activeLi) + 260;

    // 왼쪽에 있던 카드가 오른쪽으로 갔다면, 다시 왼쪽으로 갈 수 있으므로 PREV 버튼 활성화
    slidePrev.style.color = '#2f3059';
    slidePrev.classList.add('slide-prev-hover');
    slidePrev.addEventListener('click', transformPrev);

    // 맨 왼쪽에 현재 보이는 카드가, 맨 첫번째 카드라면, 오른쪽 즉, NEXT 로 갈 수 없으므로 NEXT 버튼 비활성화
    if (Number(activeLi) === 0) {
      slideNext.style.color = '#cfd8dc';
      slideNext.classList.remove('slide-next-hover');
      slideNext.removeEventListener('click', transformNext);
    }
  }

  classList.style.transition = 'transform 1s';
  classList.style.transform = 'translateX(' + String(activeLi) + 'px)';
  classList.setAttribute('data-position', activeLi);
}

function transformPrev(event) {
  // 현재 클릭 이벤트를 받은 요소, 즉 slide-prev 클래스를 가진 요소를 나타냄
  const slidePrev = event.target;
  // slide-prev 클래스를 가진 요소 다음 요소는 slide-next 클래스를 가진 요소임
  const slideNext = slidePrev.nextElementSibling;

  // ul 태그 선택
  const classList = slidePrev.parentElement.parentElement.nextElementSibling;
  let activeLi = classList.getAttribute('data-position');
  const liList = classList.getElementsByTagName('li');

  /* classList.clientWidth 는 ul 태그의 실질적인 너비
   * liList.length * 260 에서 260 은 각 li 요소의 실질 너비(margin 포함)
   * activeLi 는 data-position 에 있는 현재 위치 
   * 즉, liList.length * 260 + Number(activeLi) 는 현재 위치부터 오른쪽으로 나열되야 하는 나머지 카드들의 너비
   */

  /* classList.clientWidth < (liList.length * 260 + Number(activeLi)) 의미는
   * 오른쪽으로 나열될 카드들이 넘친 상태이므로, 왼쪽으로 이동이 가능함
   */

  if (classList.clientWidth < (liList.length * 260 + Number(activeLi))) {
    // 위치를 왼쪽으로 260 이동 (-260px)
    activeLi = Number(activeLi) - 260;

    /* 위치를 왼쪽으로 260 이동 (-260px)
    * 해당 위치는 변경된 activeLi 값이 적용된 liList.length * 260 + Number(activeLi) 값임
    * 이 값보다, classList.clientWidth (ul 태그의 너비)가 크다는 것은
    * 넘치는 li 가 없다는 뜻으로, NEXT 버튼은 활성화되면 안됨
    */
    if (classList.clientWidth > (liList.length * 260 + Number(activeLi))) {
      slidePrev.style.color = '#cfd8dc';
      slidePrev.classList.remove('slide-prev-hover');
      slidePrev.removeEventListener('click', transformPrev);
    }

    slideNext.style.color = '#2f3059';
    slideNext.classList.add('slide-next-hover');
    slideNext.addEventListener('click', transformNext);
  }

  classList.style.transition = 'transform 1s';
  classList.style.transform = 'translateX(' + String(activeLi) + 'px)';
  classList.setAttribute('data-position', activeLi);
}

const slidePrevList = document.getElementsByClassName('slide-prev'); 
/* 1. 여러개의 좌측 화살표를 한번에 적용시키고자 class 이름으로 동작을 조정 할 태그(slide-prev)를 list로 지정한다. */

for (let i = 0; i < slidePrevList.length; i++) { 
   /* 2. 리스트의 길이만큼 반복문을 돌린다. slide-prev가 세개면 세번 돌아간다.*/
  /* 3.ul 태그를 아래와 같이 선택한다. */
  let classList = slidePrevList[i].parentElement.parentElement.nextElementSibling;
  let liList = classList.getElementsByTagName('li');

  // 카드가 ul 태그 너비보다 넘치면, 왼쪽(PREV) 버튼은 활성화하고, 오른쪽(NEXT)는 현재 맨 첫카드 위치이므로 비활성화
  if (classList.clientWidth < (liList.length * 260)) {
    slidePrevList[i].classList.add('slide-prev-hover');
    slidePrevList[i].addEventListener('click', transformPrev);
  } else {
    /* 카드가 ul 태그 너비보다 넘치지 않으면, PREV, NEXT 버튼 불필요하므로, 아예 삭제함
    태그 삭제시, 부모 요소에서 removeChild 를 통해 삭제해야 함
       따라서, 1. 먼저 부모 요소를 찾아서,
             2. 부모 요소의 자식 요소로 있는 PREV 와 NEXT 요소를 삭제함
    */
    const arrowContainer = slidePrevList[i].parentElement;
    arrowContainer.removeChild(slidePrevList[i].nextElementSibling);
    arrowContainer.removeChild(slidePrevList[i]);
  }
}
```
<br>
<h6>크롬 브라우저에서 개발자도구[f12]를 열어 console을 클릭하고 slidePrevList[0]을 입력하면 해당 값을 리턴해준다.<br> 아래 그림과 같이 숫자를 하나씩 증가시켜 보면 3개가 있음을 확인할 수 있다.</h6>
<div align="center">
<img src="https://github.com/Gibson1211/Gibson1211.github.io/blob/master/assets/images/debugging.jpg?raw=true" width="1000"><br>
</div>
<br>
<h6>위의 내용을 모두 적용하여 실행하면 아래 화면에서 기능을 확인할 수 있다.</h6>
<div>
<iframe width="1000" height="700" src="https://www.youtube.com/embed/t2vu6dVB008" frameborder="0" allowfullscreen></iframe> </div>
<br>
