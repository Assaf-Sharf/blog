layout: single
published: true
title:  "13.스프링프레임워크와개요"
categories : Jsp
tag : ["java","jsp","sping"]
toc : true
toc_sticky: true
author_profile: true
sidebar :
    nav : "docs"

## 1. 스프링 프레임 워크란?

- 스프링 프레임워크란 자바 기반의 오픈소스 프레임워크로 JAVA EE를 사용하지 않고 복잡한 기능을 구현하기위해서 시작되었다.

- 스프링 프레임워크의 특징 

  - 경량 컨테이너 : 객체의 생성주기를 관리, 스프링 컨테이너로부터 필요한 객체를 얻어옴
  - 제어의 역행 지원 : 메서드나 객체의 호출이 프레임워크에 있어서 필요시 스프링에서 사용자 코드를 호출함
  - 의존성 주입지원 : 각각의 계층이나 서비스 간에 의존성이 존재할 경우 프레임워크가 연결해줌.
  - 관점 지향 프로그램 지원 : 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있음 

- 스프링부트란? 

  - 스프링 프로젝트로 스프링 프레임워크 기반의 프로젝트를 빠르고 간편하게 만들어줌 

  - 톰캣과 같은 WAR이 내장되어 있어 별도의 웹 서버 설치나 실행 없이 스프링 부트 애플리케이션을 실행하는 것으로 

    웹 애플리케이션을 구동할 수 있다.



## 2. IoC, DI, AOP



### IoC란 

- 프로그램 제어를 스프링 컨테이너에 위임하는 형태로, 스프링의 경우  객체는 스프링 컨테이너에서 생성되고, 공급된다. 



### DI란?

- IoC를 시스템적으로 구현하는 방법으로는 DI와, DL이있다. DI는 의존성 주입이라고 불리며, 클래스 간의 의존관계를 Bean설정에 기반해 컨테이너가 자동으로 연결해주는 방식이다. 
- DL을 저장소에 저장되어 있는 Bean에 개발자가 컨테이너에서 제공하는 API를 이용해 Bean을 찾는 방식으로 컨테이너에 대한  의존성이 커지고 불필요한 코드 사용이 증가하므로 DI 방식이 좋다. 



### 3. AOP란?

- 관점 지향 프로그래밍
- AOP(관점 지향 프로그래밍)을 사용하는 이유는 횡단 관심사 cross-cutting concern의 분리를 허용하여 모듈성을 증가시키기 위함
- 코드 자체를 수정하지 않는 대신 기존 코드에 추가 동작인 어드바이스를 정의하여 추가된 기능을 실행하며, 어느 코드가 포인트컷(특정 이름으로 시작하는 메서드)를 통해 수정되는지 별도로 지정하는 구조를 가지고 있음



## 4. WebMVC와 RestController 모듈



### WebMVC

####  - 컨트롤러 구현하기

- MVC 패턴에서는 직접 컨트롤러를 구현했으나, 스프링은 직접 구현할 필요 없이 특정 요청에 대한 처리 메서드만 작성하면 된다.

- ```
  @Controller
  @RequestMapping("/hello")
  public class test2 {
  }
  ```

  - Controller : MVC컨트롤러로 동작할 클래스를 의미
  - @RequestMapping : 서블릿의 @WebServlet의 request mapping 속성과 같음 



#### 모델구현하기

- 모델은 기존 코드를 완전히 재사용 가능
- 컨트롤러의 요청처리 메서드에서 DAO 객체를 불러와 필요한 메서드를 호출
- 스프링의 JDBCTemplate 또는 JPA를 사용하여 개선할 수 있음
- @Autowired로 스프링 컨테이너로부터 ProductDAO 객체를 전달받아 요청메서드에서 사용한다.





#### RestController란?

- 스프링에서 REST API를 구현하기 위해 사용하는 모듈

- 사용 예 (/api/hello2)

  ```
  
  @RestController
  @RequestMapping("/api")
  public class TestRestController {
  
  	@GetMapping("/hello2")
  	public HashMap<String, String>hello3() {
  		HashMap<String,String> map = new HashMap<String, String>(){
  			put("이름", "홍길동")
  			put("나이", "30")
  			put("국적", "서울")
  		};
  		
  		return map;
  	}
  }
  ```

  ```
  {"국적":"서울","이름":"홍길동","나이":"30"}
  ```



## 스프링 빈 선언과 오토와이어링

- 스프링 빈이란 ? 스프링 컨테이너에 의해 관리되는 자바 객체

- 설정 xml, 애너테이션, 설정 클래스를 이용해 등록된 클래스는 스프링 컨테이너에 의해 자동의 생성되어 스프링 빈으로 등록되고, 오토와이어링을 통해 공급된다.

- 1.  @Bean : 개발자가 컨트롤 할 수 없는 외부 라이브러리를 Bean으로 등록할 때 사용함
  2.  @Component : 개발자가 직접 만든 클래스를 Bean으로 등록할 때 사용
  3.  @Controller, @Service, @Repository : @Component와 기본적으로 동일하며 역할에 따라 다른 이름으로 사용한 것 

- 가장 기본적인 Component로 자바 빈 등록하는 방법

  1. 인터페이스 정의 

     ```
     package com.example.demo;
     
     public interface Weapon {
     
     	void fire();
     }
     
     ```

  2.  Weapon 인터페이스를 구현하는 ShotGun 클래스를 자바빈으로 등록 

     ``` 
     package com.example.demo;
     
     import org.springframework.stereotype.Component;
     
     @Component
     public class ShotGun implements Weapon {
     	
     	private String model = "Basic ShotGun";
     	
     	
     	public String getModel() {
     		return model;
     	}
     
     
     	public void setModel(String model) {
     		this.model = model;
     	}
     
     
     	@Override
     	public void fire() {
     		// TODO Auto-generated method stub
     		System.out.println("종료 :" + model);;
     
     	}
     
     }
     ```

- 설정 클래스를 사용하는 @Bean 

  - @Configuration으로 설정 클래스임을 알리고 

  - @Bean을 위의 Weapon 객체를 등록하는 메서드에 붙혀준다.

  - 메서드에서의 리턴이 빈으로 등록 됨.

    ```
    package com.example.demo;
    
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    
    @Configuration
    public class BasicConfiguration {
    	@Bean
    	 public Weapon superShotGun() {
    		 ShotGun sg = new ShotGun();
    		 
    		 sg.setModel("Super Shotgun");
    		 
    		 return sg;	
    	 }
    }
    
    ```

    

- 오토와이어링으로 스프링 빈 사용하기

  - 오토와이어링하는 방법에는 필드, 생성자, setter 세 가지 방식이 있음

    1.  필드 주입 : 클래스 필드에 @Autowired를 사용하는 방식으로 final로 지정할 수 없어 불변 객체를 만들 수 없다는 문제점이 있음. 

       ```
       class Game {
       	
       	@Autowired
       	private Weapon w;
       	
       	public gameRun(){
       		w.fire();
       	}
       }
       ```

    2. 생성자 주입 : 생성자에 참조할 클래스를 인자로 받아 필드에 매핑하는 방식 

       ```
       class Game {
       	private final Weapon w;
       	
       	@Autowired	
       	public Game(Weapon w){
       		this.w = w;
       	}
       	
       	public gameRun(){
       		w.fire();
       	}
       }
       ```

    3. Setter 주입 : setter 메서드를 통해 빈을 주입하는 방식 , final을 사용할 수 없음

       ```
       class Game {
       	private Weapon w;
       	
       	@Autowired	
       	public setWeapon(Weapon w){
       		this.w = w;
       	}
       	
       	public gameRun(){
       		w.fire();
       	}
       	
       }
       ```

       



 
