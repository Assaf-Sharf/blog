---
layout: post
title:  "엘라스틱으로 간편 검색 엔진 만들기 Part 1"
subtitle: "쉬운 개념 풀이, 더불어 자격증 공부까지!"
author: "코마"
date:   2019-02-01 14:34:34 +0900
categories: elasticsearch search engine
excerpt_separator: <!--more-->
---

안녕하세요 **코마**입니다. 이번 포스트는 엘라스틱 서치에 대해서 알아보겠습니다. 이 글을 쓰는 시점에 본인은 현 회사에서 엘라스틱 서치를 구축하고 운영하고 있습니다.
잘 알려진 엘라스틱에 대해 좀 더 자세히 알려드리고 토론하기 위해 시리즈로 글을 올리도록 하겠습니다.

<!--more-->

# 개요

엘라스틱 서치는 말 그대로 검색 플랫폼입니다. 루쉰(Lucene) 검색 엔진을 기반으로 개발된 플랫폼으로 준 실시간(NRT, Near Realtime) 검색 기능을 제공합니다.

예를들어 10000여 건의 문서 중에서 `코마` 라는 단어가 포함된 문서를 찾으려면 어떻게 해야할까요? 시스템이 없는 분들은 간단한 프로그램을 통해서 단어가 포함된 문서를 검색할 수도 있습니다. 하지만 문서의 수가 늘어 날 수록 검색에 시간이 많이 걸리고 결과가 부정확할 수 있습니다.

그리고 중요한 점은 검색과 기다림 사이에 유휴 시간이 생긴다는 점이죠. 이는 작업의 연속성 유지에 큰 영향을 주게됩니다. 즉, 작업 의욕이 떨어지는 것이겠죠? 엘라스틱 서치는 이러한 점을 크게 개선해 줍니다. 여기에 자동으로 데이터를 넘겨주는 프로그램을 같이 제공해주니 신경 쓸 내용이 거의 없어집니다.

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 수평형 광고 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-7572151683104561"
     data-ad-slot="5543667305"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>

## 기본 개념

자 그렇다면 서두는 이만하고 엘라스틱 서치의 기본 개념을 이해해 보겠습니다. 엘라스틱 서치는 크게 6 개의 기본 개념으로 나누어 이해할 수 있습니다. 분산 클러스터이다 보니 이해해야할 양이 조금 많습니다. 저 **코마**는 여러분에게 필수적인 핵심 내용만 간추려서 전해드리겠습니다.

## 1. 서버의 모임 (클러스터)

클러스터는 말 그대로 서버의 모임입니다. 서버의 모임은 보통 한개 이상의 서버로 구성됩니다. 나중에 설치 편에서 알려드리겠지만 서버 모임은 고유한 이름을 가져야합니다. 만약 이름이 중복된다면 개별 서버는 자신의 모임이 어딘지 헷갈려 할 수 있습니다.

## 2. 노드 (서버)

노드란 곧 서버입니다. 노드란 명칭은 분산 처리 환경에서 주로 사용하는 용어입니다. 맞습니다. 엘라스틱 서치는 분산 처리 환경에 특화되어 있습니다. 개별 노드는 **색인화**, **검색**, **데이터 저장** 기능에 참여합니다. 노드는 고유의 이름을 가지는데 명칭을 지정하거나 임의 UUID 로 사용이 가능합니다.

또한, 모든 노드의 기본 클러스터 이름은 `elasticsearch` 입니다. 따라서 새로운 노드를 생성하면 이는 곧바로 클러스터에 포함됩니다.

## 3. 인덱스 (문서 모음, 색인)

엘라스틱 서치의 기본 단위는 문서입니다. 이는 관계형 데이터베이스의 레코드(행)과 같습니다. 문서는 비슷한 종류의 문서끼리 합쳐서 인덱스(색인)라고 부릅니다. **색인화, 검색, 업데이트, 삭제 작업에서 해당 색인을 가리키는 데 쓰입니다.**

### 3.1. 데이터베이스 인덱스 (Database index, 위키피디아)

인덱스란 데이터베이스 분야에 있어서 테이블의 동작 속도를 높여주는 자료구조를 말합니다. 즉, 고속 검색 동작 및 레코드 접근을 효율적으로 수행하는데 기초를 제공합니다.

## 4. 타입 (유형)

색인은 하나의 이상의 유형을 정의할 수 있습니다. 만약에 영화 리뷰 서비스를 제공하고 있고 모든 정보가 색인에 저장된다고 가정해 봅니다. 이 색인에서 **제목**, **평점**, **줄거리** 등에 대한 유형을 정의할 수 있습니다.

## 5. 도큐먼트 (문서, 기본 정보 단위, JSON)

문서는 색인화할 수 있는 기본 정보 단위입니다. 위에서 언급한 영화 리뷰 서비스의 경우 특정 비평가가 작성한 리뷰 하나를 지칭할 수 있습니다. 이 문서는 JSON(Javascript Object Notation) 형식이며 널리 알려진 데이터 교환 형식입니다.

**하나의 색인/유형에 원하는 문서를 저장할 수 있습니다. 이는 관계형 데이터베이스가 테이블 작성 후 인덱스를 만드는 것과는 순서가 반대입니다.**

## 6. 샤드 (Shard) 그리고 레플리카(Replica)

데이터가 너무 클 경우 성능에 영향을 미치질 수 있습니다. 따라서 엘라스틱 서치는 이를 샤드라는 단위로 분할하여 관리합니다. 각 샤드는 하나의 온전한 색인(인덱스)입니다. 샤딩의 목적은 아래와 같습니다.

- 볼륨의 수평 분할/확장이 가능
- 작업(Operations, 검색, 색인화, 저장)을 사드에 분산 배치하고 병렬화 함으로써 성능/처리량을 증대

요약하자면, 각 색인은 샤드 5개, 레플리카 1개의 설정을 갖습니다. 각 인덱스(색인)은 다수의 샤드로 분리됩니다. 그리고 복제본(레플리카)가 0개 이상일 수 있습니다. 일단 복제되면 각 인덱스는 원본 샤드와 복제 샤드를 가집니다. 만약에 두개의 노드를 가진다면 5개의 원본 샤드와 5개의 복제 샤드를 가지므로 총 10개의 샤드가 인덱스 마다 존재하는 것입니다. *5개의 복제 샤드는 하나의 복제본이라고 간주합니다.*

샤드와 레플리카 샤드의 개수는 인덱스 생성 시점에 인덱스 마다 정의됩니다. 인덱스를 만든 후에 복제본(레플리카)의 개수는 동적으로 변경될 수 있습니다. 샤드 또한 `_shrink`, `_split` API 를 사용하면 변경할 수 있습니다. 그러나 이는 일반적인 작업이 아닙니다. 최적의 방법은 정확한 샤드의 개수를 미리 계획하는 것입니다.

## 결론 (Conclusion)

지금까지 엘라스틱 서치에 대한 기본 개념을 살펴보았습니다. <span style="color:red"> **다음 시간에는 호스트에 두 개의 엘라스틱 인스턴스를 올려두고 인덱스 생성 시 샤드의 개수가 어떻게 변하는지 살펴보도록 하겠습니다.** </span> 오늘도 구독해주셔서 감사합니다.

이상으로 **코마**의 엘라스틱 서치 파트 1을 마치겠습니다.