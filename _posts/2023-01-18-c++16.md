---
layout: post
title:  "c++ 16일차"
---


포인터 관련 문제 
```c++
#include <stdio.h>

int Test(int a)
{
	a = 500;
}

int main()
{
	// 1번 문제
	short sArr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	int* pI = (int*)sArr; 
	//sArr은 short포인터 타입인데 int로 강제 캐스팅 해서 에러 방지

	int iData = *((short*)(pI + 2)); 
	//괄호 먼저 계산 int포인터로 2칸 증가 --> 4가 된다.
	//short sArr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; 여기의 1, 2, 3 이것들은
	//각각 2byte이다. 따라서 int로 계산하면 4가 된다.
	//여기서 주소값으로 접근 하는데 원래 int이기 떄문에 4byte 접근을 해야 하지만
	//short로 캐스팅 하면 2byte즉 1칸이 증가 하므로 답은 5

	printf("1번 문제 정답 : d\n", iData); //5
	




	// 2번 문제
	char cArr[2] = { 1, 1 };
	//이것은 1byte에 1씩 들어있는 것
	short* pS = (short*)cArr;
	//short로 보면 1, 1이 들어있는 2byte짜리 한칸
	//short입장에서 시작지점으로부터 1칸 즉 char입장에서는 2칸 접근하여 주소가 가지고 있는
	//값에 접근한다.
	//메모리 구조는 ㅁㅁ여기에 각각 1씩 들어있는 2byte 정수라고 본다.
	//bit로 보면 8bit찍 16비트가 있는 것이다.
	//ㅁ ㅁ ㅁ ㅁ ㅁ ㅁ ㅁ 1 ㅁ ㅁ ㅁ ㅁ ㅁ ㅁ ㅁ 1 이렇게 끝에 1이 들어가 있다.
	//1byte로 표현할 수 있는 최대치는 255이다.(8칸이 전부 1로 채워졌을 경우)
	//255즉 8칸이 전부 1로 채워진 것에서 1자리 넘어가게 되면
	//1 0 0 0 0 0 0 0 0 이것이 된다. 이것은 256을 말한다.
	//따라서 ㅁ ㅁ ㅁ ㅁ ㅁ ㅁ ㅁ 1 ㅁ ㅁ ㅁ ㅁ ㅁ ㅁ ㅁ 1 이것이
	// 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 1 이것이 되고 이것은 256 + 1 이므로 257이다.
	iData = *pS;

	printf("1번 문제 정답 : d\n", iData); //257





	int a = 100;

	Test(a);
	//a라는 변수가 Test함수 호출 이후에 바뀌게 하려면 a에 주소를 넘기면 된다.
	//서로 전혀 다른 스택이지만 코드상으로 나를 호출했던 쪽의 변수에 접근하고 싶으면
	//주소를 알면 된다.
	//void Test(int* a), *a = 500; 이걸로 바꾸고 Test(&a)이걸로 바꾸면 된다.
	//a는 int변수의 주소 변수니까 접근하면 int가 있겠네 하고 접근하는 순간
	//넘겨준 주소로 내가 정수형으로 4byte만큼 접근을 하게 된다.
	//그리고 거기에 500을 기록하면 실제로 main함수에 있는 int a의 값이 변한다.

	printf("출력 : d\n", a); //100
	//Test함수에 있는 a는 지역변수
	//Test함수에서 a에 500을 넣어도 종료되면 없어지는 값


	scanf_s("% d", &a);
	//콘솔창으로부터 입력된 값을 읽어와서 내가 전달해준 주소로 접근을 해서
	//넣어주고 나면 scanf가 종료되고 돌아오면 a변수가 바뀌어 있다.
	//scanf는 내가 전	달해준 주소를 받아간다.


	return 0;
}
```


const 
```c++
int main()
{
	

	//const
	const int cint = 100;

	cint;
	//상수화 됨 (바뀔 수 없음)
	//r-value : 상수
	//l-value : 변수

	cint = 100;
	//const를 사용하여 앞으로 cint에 들어있는 값을 수정하는 것은 안된다고 문법적으로 막아주는것
	//불가능한 영역이 아니라 c++에 있는 문법이 그렇다는 것. const를 붙이면 
	//상수로 취급해 줄 것이기 때문에 문법적으로만 막아주는 것. 10 이런 상수들 처럼
	//진짜 절대 바뀔 수 없다는 것은 아님.
  //상수로 취급하도록 지원을 하는 

	pInt = (int*)&cint;
	*pInt = 300;
	//pInt의 값을 포인터로 강제접근하여 바꾼 것


	return 0;
}
```

const 포인터 
```c++
#include <stdio.h>



int main()
{
	
	const int i = 100;

	int a = 0;
	int* pInt = &a;
	 
	*pInt = 1; //---> a라는 변수 안에 있는 값이 바뀐 것
	pInt = nullptr; //---> int포인터는 더이상 a라는 변수의 주소를 가지고 있는게 아니다.
	//포인터 변수가 바뀐다는 것은 
	//위와 같이 가리키는 대상을 바꾸는 것 또는 가리키지 않는 것이다.




	
	//===========
	//const 포인터 -->가르키는 부분을 상수화(const가 수식하는 것은 *)
	//===========
	const int* pConstInt = &a; 
	//포인터 변수 그 자체가 상수화 된 것이 아니다.
	//다른 변수를 가리킬 수 있다.
	//현재 자신이 가리키고 있는 원본쪽을 수정할 수 없다.
	*pConstInt = 100; 
	//접근은 문제없지만 지금 pConstInt는 상수화 되어 있기 때문에 바꿀 수 없다

	int* p = &a;
	*p = 100;
	//이처럼 다른 변수는 a를 수정하는데 아무 문제가 없다.

	int b = 0;
	pConstInt = &b; //다른 변수를 가리켜도 오류가 발생하지 않는다.
	




	//===========
	//포인터 const -->변수가 상수화(const가 수식하는 것은 변수)
	//===========
	int* const pIntConst = &a;
	//변수 자체를 상수화 시킨것
	*pIntConst = 400;
	//a의 값을 바꿀 수 있다.
	pIntConst = &b;
	//포인터 변수 자체가 상수화 됐기 때문에 처음에 한번 입력받은 a의 변수가
	//곧 pIntConst라는 뜻이다. a변수의 주소값이 곧 pIntConst이다.
	//따라서 &b를 입력받을 수는 없다.




	
	const int* const pConstIntConst = nullptr; 
	//처음 가리킨 것만 가리킬 수 있고 그 부분을 바꿀 수 없다.
	//초기화 시 가리킨 대상만 가리킴, 가리키는 원본을 수정할 수 없음



	return 0;
}
```


const 포인터 예시 
```c++
#include <stdio.h>


void Output(const int* pI)
{
	int i = *pI;
	*pI = 100; //const 포인터로 가리키는 원본 값은 바꿀 수 없음
	
	//int* pInt = (int*)pI;
	//*pInt = 1000; 
	//이렇게 억지로 바꿀 수는 있음
}	

int main()
{
	
	a = 100;
	Output(&a); //const 포인터로 가리키는 원본 값은 바꿀 수 없음



	return 0;
}

//단축키
//Crtl + Shift + Space : 함수 선언이 뜬다.
//Output(&a); 이것의 괄호 안에 것을 해보면 void Output(const int* pI)이것이 뜬다.
//협업을 할 때, 데이터가 너무 커서 데이터를 읽기용으로 주소를 받아가려고 할 때 
//포인터 앞에 const를 꼭 붙여야 한다. 아니면 상대방이 오해를 할 수 있다.
```


void 
```c++
#include <stdio.h>


int main()
{
	
	
	void* pVoid = nullptr; 
	//주소로 갔을때 원본의 형태를 어떤식으로 볼지를 정하지 않은 포인터
	//원본으로 접근했을때 char int float 등으로 정하지 않은 것
	//정하지 않았기 때문에 어떤 변수의 주소든 다 받을 수 있다.
	//주소를 넣어줬을때 그 주소를 특정 데이터 타입으로 해석을 하지 않기 때문에
	//아무나 받을 수 있다. 그렇기 때문에 역참조가 불가능하다.
	float* pFloat = nullptr; //원본을 float로 보겠다는 뜻

	{
		int a = 0;
		float f = 0.f;
		double d = 0.;
		long long ll = 0;

		pVoid = &a;
		pVoid = &f;
		pVoid = &d;
		pVoid = &ll;


		*pVoid; 
		//역참조가 불가능하다.
		//역참조를 하려면 자기가 가리키고 있는 곳을 해석을 하는 자료형이 있어야 하는데
		//그래야 그 형태에 맞게 몇byte로 접근할 것인지 접근 단위 byte가 동일하더라도
		//거길 정수로 볼 것인지 실수로 해석할 것인지에 따라 적혀있는 type대로 봐야하는데
		//void는 뭐라고 정해서 해석하지 않기 때문이다.
		*pVoid + 1;
		//주소연산도 불가능하다.위와 같은 이유로.
	}

	//void
	//1. 원본의 자료형을 정하지 않음
	//2. 어떠한 타입의 변수의 주소든 다 저장 가능
	//3. 역참조 불가능
	//4. 주소 연산 불가능

	//원본 데이터가 어떻게 사용되고 있는지는 포인터와 무관하다.


	return 0;
}
```



문자 
```c++
#include <stdio.h>


//메모리 영역
//1. 스택
//2. 데이터
//3. 힙
//4. ROM(읽기 전용)


int main()
{
	
	//문자
	wchar_t wc = 49;//wc에 들어있는 값을 보면 49'1'이렇게 나오는데 49가 아스키코드로 1이다.
	short s = 49;

	char c = 1;
	c = '1';
	//이것은 다른 것.
	//문자 '1'을 c에 넣는다고 하는 것. c에 49가 들어가 있다.



	wc = 459; //---> 2byte라는 공간에 459가 들어간 것 (459를 표현하기 위해 2진수 데이터를 넣은것)
	"459"; 
	//""이것은 4에 해당하는 문자의 값 52, 5에 해당하는 문자의 값 53, 9에 해당하는 문자의 값 57
	//이것들이 메모리상에 각각 나열된 것이다. 52 53 57 을 문자로 바꾸면 459가 되는 것이다.
	//이것들은 한칸 한칸이 255안에 표현이 가능하므로 각각 1byte로 가능하다.
	//ㅁ ㅁ ㅁ 각각 칸은 1byte씩이고 52 53 57 을 넣고 문자로 해석해서 읽으면 "459"가 된다.

	//52 53 57 . . . 문자가 나열되고 끝이라는 것을 알리는 용도로 마지막에 0을 넣어줘야 한다.
	//그러니 52 53 57 0 이렇게 해야 "459"가 되는 것이다. 여기서 0이 null 문자이다.
	//"459" 여기에는 마지막에 null문자가 포함되어 있는 것이다.

	int i = 0;

	return 0;
}
```



문자열 1 
```c++
#include <stdio.h>


//메모리 영역
//1. 스택
//2. 데이터
//3. 힙
//4. ROM(읽기 전용)


int main()
{
	//문자
	//char(1), wchar(2) --> 저장하는 데이터의 표현방식은 정수를 따르지만 문자 전용 자료형.
	//wchar : 문자 하나를 2byte로 표현하겠다는 것
	
	char c = 'a';
	wchar_t wc = L'a'; //L을 써줘야 a를 2byte로 본다.

	char szChar[10] = "abcdef";
	wchar_t szWChar[10] = L"abcdef"; //L이 문자 하나하나가 2byte라는 것을 알려줌
	// L"abcdef" 이 문자열은 7개짜리 문자열이다. 마지막에 null문자가 포함되어 있다.
	//따라서 wchar_t szWChar[6] = L"abcdef"; 이렇게 하면 컴파일 에러가 난다.


	//char szChar[10] = "abcdef";이것이나 char szChar[10] = "abcdef"; 이것은
	//문자 전용 자료형인 애들에게만 가능하다.
	short arrShort[10] = L"abcdef";
	//short는 문자 전용 자료형이 아니라 에러가 발생한다.
	//위의 식은 2byte 정수형 배열에 첫번째 칸에는 97을 넣고 두번째 칸에는 98을 넣고
	//이런식으로 하라는 것이다.
	//배열 초기화 법으로 나타내자면 
	//short arrShort[10] = L"abcdef"; 이것은
	//short arrShort[10] = {97, 98, 99, 100, 101, 102}; 이렇게 된다.


	const wchar_t* pChar = L"abcdef";
	//위의 코드가 가능하다는 것은 L"abcdef";이것 즉, 문자열이 주소값이라는 것이다.
	//wchar_t이것은 2byte 자료형이고 문자열이 L을 통해 2byte wchar타입이 되었기 때문에 
	//위의 식이 가능하다.
	//문자열의 반환 타입을 const로 해야 한다.

	

	/*
	wchar_t szWChar[10] = L"abcdef"; 
	이것은 데이터들을 우리쪽 배열로 초기화 할때 그대로 옮긴 것이다.	

	const wchar_t* pChar = L"abcdef";
	이것은 다이렉트로 저 문자열의 시작 주소를 가리키고 있는 것이다.
	

	wchar_t szWChar[10] = L"abcdef";
	szWCar[1] = 'z';  --> 이것은 b를 z로 바꾼다는 것이다.

	const wchar_t* pChar = L"abcdef";
	pChar[1] = 'z'; --> 이것은 *(pChar + 1) = 'z'; 이것이다.
	이것은 말이 안 된다. 필요한게 있어서 그것을 가리키게 해놨는데 거기를 수정하라는 뜻이기 때문


	szWCar[0]; 이것은 복사해온 a를 말하는 것이다.

	pChar[0]; 이것은 주소 변수가 다이렉트로 가리킨 a를 말하는 것이다.
	*/
	



	return 0;
}
```
