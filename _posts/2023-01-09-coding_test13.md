---
layout: single
title:  "코딩 테스트 책 - 13차시"
categories : coding-test
tag : [이것이 취업을 위한 코딩 테스트다, python, 나동빈]
toc: true
toc_sticky: true
---

![header](https://capsule-render.vercel.app/api?type=waving&color=a2dcec&height=300&section=header&text=코딩 테스트 책 - 13차시&fontSize=40&animation=fadeIn&fontAlignY=38&fontColor=FFFFFF)&nbsp;  

## 그래프 이론

&nbsp;

### 서로소 집합

- 공통 원소가 없는 두 집합을 의미
  - {1, 2}와 집합 {3, 4}는 서로소 관계
  - 집합 {1,2}와 집합 {2,3}은 2라는 두 집합에 공통적인 요소가 있기에 서로소 관계가 아님
- 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조
- union과 find, 2개의 연산으로 조작이 가능
  - union : 2개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산
  - find : 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산
  - 스택과 큐가 각각 push, pop 연산으로 이루어졌던 것처럼, 서로서 집합 자료구조는 합집합과 찾기 연산으로 구성 됨

&nbsp;

### 서로소 집합 자료구조

- 서로소 집합 자료구조를 구현할때 트리 자료구조를 이용하여 집합을 표현

- 서로소 집합 정보가 주어졌을 때 트리 자료구조를 이용해서 집합을 표현하는 서로소 집합 계산 알고리즘 순서

  1. union 연산을 확인하여, 서로 연결된 두 노드 A, B를 확인
     - A와 B의 루트 노드 A', B'를 각각 찾음
     - A'를 B'의 부모 노드로 설정 (B'가 A'를 가리키도록 한다)
  2. 모든 union 연산을 처리할 때까지 1번 과정을 반복

- 기본적인 서로소 집합 알고리즘 예제

  ```python
  def find_parent(parent, x):
      if parent[x] != x:
          return find_parent(parent, parent[x])
      return x
  
  
  def union_parent(parent, a, b):
      a = find_parent(parent, a)
      b = find_parent(parent, b)
      if a < b:
          parent[b] = a
      else:
          parent[a] = b
  
  
  v, e = map(int, input().split())
  parent = [0] * (v + 1)
  
  for i in range(1, v + 1):
      parent[i] = i
  
  for i in range(e):
      a, b = map(int, input().split())
      union_parent(parent, a, b)
  
  print('각 원소가 속한 집합: ', end='')
  for i in range(1, v + 1):
      print(find_parent(parent, i), end=' ')
  
  print()
  
  print('부모 테이블: ', end='')
  for i in range(1, v + 1):
      print(parent[i], end=' ')
      
  # input
  
  6 4
  1 4
  2 3
  2 4
  5 6
  
  # output
  
  각 원소가 속한 집합: 1 1 1 1 5 5 # root node
  부모 테이블: 1 1 2 1 5 5
  ```

  - 시간복잡도 : O(VM)

- 경로 압축 기법 적용 예제

  ```python
  def find(node):
      # path compression 기법
      if parent[node] != node:
          parent[node] = find(parent[node])
      return parent[node]
  ```

  - find를 해당으로 변환 시키면 find를 호출한 이후에, 해당 노드의 루트 노드가 바로 부모 노드가 됨
  - 루트 노드에 더욱 빠르게 접근할 수 있다는 점에서 기존의 기본적인 알고리즘과 비교했을 때 시간 복잡도가 계선 됨

&nbsp;

### 서로소 집합을 활용한 사이클 판별

- 서로소 집합은 다양한 알고리즘에 사용될 수 있음, 특히 서로소 집합은 무방향 그래프 내에서의 사이클을 판별할 때 사용할 수 있다는 특징이 존재

- 사이클 판별 알고리즘 

  1. 각 간선을 확인하며 두 노드의 루트 노드를 확인
     - 루트 노드가 서로 다르다면 두 노드에 대하여 union 연산을 수행
     - 루트 노드가 서로 같다면 사이클이 발생한 것
  2. 그래프에 포함되어 있는 모든 간선에 대하여 1번 과정을 반복

- 서로소 집합을 활용한 사이클 판별 소스코드

  ```python
  def find_parent(parent, x):
    if parent[x] != x:
      parent[x] = find_parent(parent, parent[x])
    return parent[x]
  
  
  def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
  
    if a < b:
      parent[b] = a
    else:
      parent[a]  = b
      
  v, e = map(int, input().split())
  parent = [0] * (v + 1)
  
  
  for i in range(1, v+1):
    parent[i] = i
  
  cycle = False
  
  for i in range(e):
    a,b = map(int,input().split())
    
    if find_parent(parent,a) == find_parent(parent,b):
      cycle = True
      break
    else:
      union_parent(parent,a,b)
  
  if cycle:
    print('사이클 발생')
  else:
    print('사이클 발생하지 않았습니다.')
  ```

&nbsp;

### 신장 트리

- 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프를 의미

- **크루스칼 알고리즘**

  - 가능한 한 최소한의 비용으로 신장 트리를 찾아야 할 때 사용
  - 크루스칼 알고리즘 순서
    1. 간선 데이터를 비용에 따라 오름차순으로 정렬
    2. 간선을 하나씩 확인하며 현재의 간선이 사이클을 발생시키는지 확인
       - 사이클이 발생하지 않는 경우 최소 신장 트리에 포함시킴
       - 사이클이 발생하는 경우 최소 신장 트리에 포함시키지 않음
    3. 모든 간선에 대하여 2번의 과정을 반복

- 최소 신장트리는 일종의 트리 자료구조이므로, 최종적으로 신장트리에 포함되는 간선의 개수가 노드의 개수 - 1과 같다는 특징이 존재

- 크루스칼 알고리즘 소스코드

  ```python
  def find(parent, x):
    if parent[x] != x:
      parent[x] = find(parent, parent[x])
    return parent[x]
  
  
  def union(parent, a, b):
    a = find(parent, a)
    b = find(parent, b)
  
    if a < b:
      parent[b] = a
    else:
      parent[a] = b
  
  
  v, e = map(int, input().split())
  parent = [0] * (v + 1)
  
  edges = []
  result = 0
  
  for i in range(1,v+1):
    parent[i] = i
  
  for _ in range(e):
    a,b,cost = map(int,input().split())
    edges.append((cost,a,b))
  
  edges.sort()
  
  for edge in edges:
    cost, a, b =  edge
  
    if find(parent, a) != find(parent, b):
      union(parent,a,b)
      result += cost
  ```

  - 시간 복잡도 ![image-20230109170113348](/images/2023-01-09-coding_test13/image-20230109170113348.png)

&nbsp;

### 위상 정렬

- 정렬 알고리즘의 일종
- 방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열하는 것
- 위상 정렬 알고리즘 순서
  1. 진입차수가 0인 노드를 큐에 넣는다.
  2. 큐가 빌 때까지 다음의 과정을 반복한다.
     - 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거한다.
     - 새롭게 진입차수가 0이 된 노드를 큐에 넣는다.

- 위상정렬 소스코드

  ```python
  from collections import deque
  
  v, e = map(int, input().split())
  indegree = [0] * (v + 1)  # 진입차수
  
  graph = [[] for i in range(v + 1)]
  
  for _ in range(e):
      a, b = map(int, input().split())
      graph[a].append(b)
      indegree[b] += 1
  
  
  def topology_sort():
      result = []
      q = deque()
  
      for i in range(1, v + 1):
          if indegree[i] == 0:
              q.append(i)
  
      while q:
          now = q.popleft()
          result.append(now)
          for i in graph[now]:
              indegree[i] -= 1
              # 진입차수가 0이되는 노드를 큐에 삽입
              if indegree[i] == 0:
                  q.append(i)
  
      for i in result:
          print(i, end=' ')
  
  
  topology_sort()
  ```

  - 시간복잡도: O(V+E)
