---
layout: single
title:  "반도체 설계"
categories: Class4
tag: [이분 탐색, 가장 긴 증가하는 부분 수열]
toc: true
author_profile: false
sidebar: 
nav: "docs"
---

# 2352, 반도체 설계

## 최초 접근법

- a포트의 번호가 더 크다면 연결되는 b포트의 번호도 더 커야한다. 
- a포트의 번화와 b포트의 번호의 차이가 작을수록 더 연결 가능성이 높다!

1. |a-b|차이가 가장 작은 포트를 우선적으로 선택
2. 연결되는 포트가 오름차순이어야 연결 가능하다

위의 1, 2를 만족하면서 반복하여 가장 최대로 연결되는 경우를 출력한다. 

![KakaoTalk_20220721_200623139](../../images/2022-07-21-BDC_design/KakaoTalk_20220721_200623139.jpg)

예시로 위의 그림을 보면 더 이해하기 쉽다. 

하지만 이 방법은 시간초과가 발생할 가능성이 매우 높다. 

이 문제를 고민하던 중 동혁이형의 도움으로 LIS로 접근할 수 있었다. 

## 수정된 접근법

이 문제는 최대 증가 수열 문제이다. 왜냐하면 A포트의 번호가 크다면 B포트의 번호도 반드시 커야하기 때문이다. 

여기서 몇가지 의문점이 발생하였다. 

- 실제 연결과는 다르게 최대 증가수열로 업데이트 해도 괜찮은 이유는 무엇인가?

  이유는 연결가능한 포트의 수만 출력하면 되기 때문이다. 

- 그렇다면 이후의 연결에 영향을 미치지는 않는가?

지금부터는 아래 그림을 보면 이해할 수 있을 것이다. 

![KakaoTalk_20220721_201018511](../../images/2022-07-21-BDC_design/KakaoTalk_20220721_201018511.jpg)

이를 이해하고 나서 1트에 바로 성공할 수 있었다. 

## 코드

```python
import sys
from bisect import bisect_left

n = int(input())

port = list(map(int, sys.stdin.readline().split()))

q = [] # 최대 증가수열로 업데이트 해줄 리스트

for i in port:
    if len(q) == 0: # 처음 value 값 연결
        q.append(i)
    else:
        if i > q[-1]: # 가장 마지막 수 보다 크다면 그냥 추가해준다.
            q.append(i)
        else: # 가장 마지막 수 보다 작다면 이진 탐색한다.
            idx = bisect_left(q, i)
            q[idx] = i

print(len(q)) # 최대 증가 수열의 길이를 출력해준다.
```

## 설명

1. 최대 증가수열을 저장할 리스트 q를 만들고 첫 입력을 넣어준다. 
2. 이후 들어오는 수들을 bisect_left를 이용하여 정렬해준다. 
3. 만들어진 최대 증가 수열의 길이를 출력한다. 

## 요점 및 배운점

- LIS알고리즘을 배운지가 오래되어 잊고 있었다. 새로 공부할 수 있었으며 어떠한 문제들에 적용할 수 있는지 조금 알게 된것 같다. 

- bisect_left(list, x) 함수는 파라미터로 리스트와 삽입할 값을 받고 삽입 될 x의 index 값을 반환해준다. 

- bisect_left()를 이용하면 최대 증가 수열을 O(NlogN)의 시간복잡도로 구현할 수 있다. 이는 완전 탐색 (O(n^2))보다 빠르므로 반드시 알고 있자!!

  
