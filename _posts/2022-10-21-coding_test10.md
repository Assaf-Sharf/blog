---
layout: single
title:  "코딩 테스트 책 - 10차시"
categories : coding-test
tag : [이것이 취업을 위한 코딩 테스트다, python, 나동빈]
toc: true
toc_sticky: true

---

![header](https://capsule-render.vercel.app/api?type=waving&color=a2dcec&height=300&section=header&text=코딩 테스트 책 - 10차시&fontSize=40&animation=fadeIn&fontAlignY=38&fontColor=FFFFFF)&nbsp;

## 다이나믹 프로그래밍

&nbsp;

### 1로 만들기

- 정수 X가 주어질때 정수 X에 사용할 수 있는 연산은 다음과 같이 4가지

  a. X가 5로 나누어떨어지면, 5로 나눈다.

  b. X가 3으로 나누어 떨어지면, 3으로 나눈다.

  c. X가 2로 나누어 떨어지면, 2로 나눈다.

  d. X에서 1을 뺀다.

- 정수 X가 주어졌을때, 연산 4개를 적절히 사용해서 1을 만들어야한다. 이 연산을 사용하는 횟수의 최솟값을 출력해라.

  - X = 26일 경우

    ```markdown
    26 - 1 = 25
    25 /5 = 5
    5 / 5 = 1
    ```

    - 첫째 줄에 정수 X가 주어진다. (1 <= X <= 30,000)
  - 첫째 줄에 연산을 하는 횟수의 최솟값 출력한다.

&nbsp;

**풀이**

```python
x = int(input())
d = [0] * 30001

for i in range(2,x+1):
    
    # 현재의 수에서 1을 빼는 경우
    d[i] = d[i-1] +1
    
    # 현재의 수가 2로 나누어 떨어지는 경우
    if i % 2 == 0:
        d[i] = min(d[i], d[i//2]+1)

    # 현재의 수가 3로 나누어 떨어지는 경우
    if i % 3 == 0:
        d[i] = min(d[i], d[i//3]+1)
        
    # 현재의 수가 5로 나누어 떨어지는 경우
    if i % 3 == 0:
        d[i] = min(d[i], d[i//5]+1)
        
print(d[x])
```

- 다이나믹 프로그래밍의 주요한 두 조건
  1. 큰 문제를 작은 문제로 나눌 수 있다.
  2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일함

&nbsp;

### 개미 전사

```markdown
# 문제
개미전사는 부족한 식량을 충당하고자 메뚜기 마을의 식량창고를 몰래 공격하려고 한다. 메뚜기 마을에는 여러 개의 식량창고가 있는데 식량창고는 일직선으로 이어져 있다. 각 식량창고에는 정해진 수의 식량을 저장하고 있ㄷ으며 개미 전사는 식량창고를 선택적으로 약탈하여 식량을 빼앗을 예정이다. 이때 메뚜기 정찰병들은 일직선상에 존재하는 식량창고 중에서 서로 인접한 식량창고가 공격받으면 바로 알아챌 수 있다. 따라서 개미 전사가 정찰병에게 들키지 않고 식량창고를 약탈하기 위해서는 최소한 한 칸 이상 떨어진 식량창고를 약탈해야 한다. 예를 들어 식량창고 4개가 다음과 같이 존재한다고 가정하자.

{1, 3, 1, 5}
- 이때 개미 전사는 두 번째 식량창고와 네 번째 식량창고를 선택했을 때 최댓값인 총 8개의 식량을 빼앗을 수 있다. 개미 전사는 식량창고가 이렇게 일직선상일 때 최대한 많은 식량을 얻기를 원한다.
- 개미 전사를 위해 식량창고 N개에 대한 정보가 주어졌을 때 얻을 수 있는 식량의 최댓값을 구하는 프로그램을 작성하시오.


# 입력 예시
4
1 3 1 5

# 출력 예시
8
```

&nbsp;

**풀이**

```python
n = int(input())
array = list(map(int, input().split()))

d = [0] * 100

d[0] = array[0]
d[1] = max(array[0], array[1])

for i in range(2,n):
    d[i] = max(d[i-1], d[i-2] + array[i])


print(d[n-1])
```

- 이 문제에서 가장 중요한 점은 점화식을 잘 작성하는 것
  - 실제로 1칸을 뛰고 계산해야함으로 d에 공간을 만들고 i-1, i-2 두개만 고려해 그때의 최대값을 생각하면 됨


&nbsp;

### 바닥 공사

```markdown
# 문제
- 가로의 길이가 N, 세로의 길이가 2인 직사각형 형태의 얇은 바닥이 있다.
- 태일이는 이 얇은 바닥을 1 X 2의 덮개, 2 X 1의 덮개, 2 X 2의 덮개를 이용해 채우고자 한다.
- 이 때 바닥을 채우는 모든 경우의 수를 구하는 프로그램을 작성하시오.
- 예를 들어, 2X3 크기의 바닥을 채우는 경우의 수는 5가지이다.



# 입력 예시
3

# 출력 예시
5
```

&nbsp;

**풀이**

```python
# 정수 N을 입력 받기
n = int(input())

# 앞서 계산된 경우의 수를 저장하기 위한 DP 테이블 초기화
d = [0] * 1001

# 다이나믹 프로그래밍(Dynamic Programming) 진행 (보텀업)
d[1] = 1
d[2] = 3
for i in range(3, n + 1):
    d[i] = (d[i - 1] + 2 * d[i - 2]) % 796796

# 계산된 결과 출력
print(d[n])
```

- 경우의 수를 계산하는 방식으로 풀이가능
- 다 채웠을 경우 남은 수를 계산하는 방식으로 생각

&nbsp;

### 효율적인 화폐 구성

```markdown
# 문제

N가지 종류의 화폐가 있다. 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 하려고 한다. 이때 각 화폐는 몇 개라도 사용할 수 있으며, 사용한 화폐의 구성은 같지만 순서만 다른 것은 같은 경우로 구분한다. 예를 들어 2원, 3원 단위의 화폐가 있을 때는 15원을 만들기 위해 3원을 5개 사용하는 것이 가장 최소한의 화폐 개수이다.

# 입력
1. 첫째 줄에 N,M이 주어진다(1<= N <= 100, 1<= M <= 10,000)
2. 이후의 N개의 줄에는 각 화폐의 가치가 주어진다. 화폐의 가치는 10,000보다 작거나 같은 자연수이다.

# 출력
- 첫째 줄에 M원을 만들기 위한 최소한의 화폐 개수를 출력
- 불가능할 때는 -1을 출력

# 입력 예시
2 15
2
3
>> 5

3 4
3
5
7
>> -1
```

&nbsp;

**풀이**

```python
n, m = map(int, input().split())

array = []
for i in range(n):
    array.append(int(input()))


d = [10001] * (m + 1)
d[0] = 0


for i in range(n):
    for j in range(array[i], m+1):
        if d[j - array[i]] != 10001:
            d[j] = min(d[j], d[j - array[i]] + 1)
         
         
         
if d[m] == 10001:
    print(-1)
else:
    print(d[m])
```

- 상당히 생각하기 어려웠던 점화식 문제
- 중요한건 기존의 뒤에서부터 계산이 아닌, 앞에서 부터 계산