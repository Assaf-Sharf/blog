---
title: "[JS] JavaScript Concept - Beginner"

categories:
  - JS
tags:
  - [JS, Beginner]

toc: true
toc_sticky: true

date: 2023-05-04
last_modified_at: 2023-05-04
---

{% capture notice-2 %}

📋 This is my JavaScript note-taking!

1. [자바스크립트 초급 강좌](https://www.inflearn.com/course/%EC%99%95%EC%B4%88%EB%B3%B4-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8#curriculum)
2. [자바스크립트 중급 강좌](https://www.inflearn.com/course/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%A4%91%EA%B8%89)
   {% endcapture %}

<div class="notice--danger">{{ notice-2 | markdownify }}</div>

<br>

# 변수

## 변수: 어떤 정보에 이름을 붙여 저장하고 싶을 때 사용

```
name = "Mike";
age = 30;
```

- name 이라는 변수에는 Mike 라는 값이 들어가 있고, age 라는 변수에는 30 이라는 값이 들어가 있음
- Mike 와 같은 String 은 " " 안에 작성해야 함
- 변수는 문자와 숫자, $와 \_만 사용 가능
- 첫글자는 숫자가 될 수 없음
- 예약어 사용 불가

## 결과 출력 함수

- alert(): 메세지창을 띄움
- Console.log(): 메세지를 출력

## 변수 선언

- let:
  : - 재선언 불가 but 업데이트 가능

```
let grade = "F";
let grage = "A"; // error; 재선언 불가

let grade = "F";
grage = "A"; // working; 업데이트 가능
```

- const: 절대로 바뀌지 않는 상수를 선언할 때 사용
  : - π, 최대값, 생일 등 변하지 않는 값
  : - 대문자로 선언하는 게 좋음

```
const PI = 3.14;
const SPEED_LIMIT = 50;
const BIRTH_DAY = '2023-03-13';
```

> 자바스크립트에서 변수를 선언할 때는,
>
> 변하지 않는 값은 const,
>
> 변할 수 있는 값은 let으로 선언하기!
>
> Tip! 모든 변수를 일단 const로 선언한 후, 나중에 변경 될 여지가 있는 변수들만 let으로 바꾸기

<br>

# 자료형

## 문자형

문자형은 세가지 형식 ("Mike" 'Mike' `Mike`)으로 작성 가능

```
const name1 = "Mike";
const name2 = 'Mike';
const name3 = `Mike`;

// ` `(backtick) 사용법
const name = "Mike";
const message3 = `My name is ${name}`;
console.log(message3); //Output: "My name is Mike"

// 숫자형 뿐만 아니라 문자형도 더하기 가능
const name = "Mike";
const a = "나는 ";
const b = " 입니다.";

console.log(a + name + b); //Output: "나는 Mike 입니다."
```

## 숫자형

- 사칙 연산 가능 (+, -, \*, /, %)
- 1/0 -> "Infinity" 출력
- name/2 -> NaN (Not a Number)

## 불리언 (Boolean)

- true 참, false 거짓
- null: 존재하지 않는 값을 의미
- undefined: 값이 할당되지 않았음을 의미

## typeof 연산자: 변수의 자료형을 알아낼 수 있음

```
const name = "Mike";

console.log(typeof 3); //Output: "number"
console.log(typeof name); //Output: "string"
console.log(typeof true); //Output: "boolean"
console.log(typeof "xxx"); //Output: "string"
console.log(typeof null); //Output: "object"(객체형)
console.log(typeof undefined); //Output: "undefined"
```

- null은 객체가 아니지만 결과로 object(객체)를 출력함 -> 왜? 이건 자바스크립트 초기 버전의 오류인데, 하위 호환성을 위해 수정하지 않음

<br>

# 사용자와 상호작용할 수 있는 '대화상자'

## alert:

&rarr; 메세지를 보여줌 - 확인 버튼 누르면 창이 닫힘

## prompt:

&rarr; 사용자에게 메세지를 보여줌 - 사용자가 값을 입력할 수 있는 필드를 제공 - '취소'를 누르면 null 값을 반환 - 두번째 인수에 값을 넣어주면 default 값을 제공 가능

- 만일 메세지창에 아무것도 입력하지 않은 채 취소를 누르면, null 값을 출력함 (null = 존재하지 않는 값)

```
const name = prompt("이름을 입력하세요."); //사용자로부터 이름을 입력 받음
alert("환영합니다, " + name + "님"); //사용자로부터 입력 받은 이름을 포함하여 메세지창에 띄움

alert(`환영합니다, ${name}님 환영합니다.`); //backtick을 이용해 입력 가능

//prompt는 입력 받을 default 값을 미리 입력 가능 (입력 받을 값을 안내하거나 힌트를 줄 수 있음)
const name = prompt("예약일을 입력해주세요.", "2023-03-");
```

## confirm:

&rarr; 사용자에게 확인을 받기 위한 용도

- alert는 '확인' 버튼만 존재 but confirm은 '확인' '취소' 버튼 둘다 존재

```
const isAdult = confirm("당신은 성인입니까?");
console.log(isAdult); //성인이면 '확인'(true), 아니면 '취소'(false)
```

> 단점
>
> 1. 창이 떠있는 동안, 스크립트 일시 정지
>
> 2. 스타일링 불가능

<br>

# 형변환 Type Conversion

## 자동 형변환

"6" / "2" = 3 -> 여기서 6과 2는 모두 문자형이지만 자동 형변환을 통해 사칙연산이 이루어짐

- prompt로 입력 받은 값은 무조건 '문자형'

## 명시적 형변환

String(): 문자형으로 변환

```
console.log(
String(3),
String(true),
String(false),
String(null),
String(undefined)
) //Output: "3" "true" "false" "null" "undefined"
```

Number(): 숫자형으로 변환

```
console.log(
Number("1234"), //Output: 1234
Number("123asdkfjla"), //Output: NaN
Number(true), //Output: 1
Number(false) //Output: 0
)
```

Boolean(): 불린형으로 변환

- false:
  : - 숫자 0
  : - 빈 문자열 "
  : - null
  : - undefined
  : - NaN
- true:
  : - 위의 false 값의 예시들을 제외한 나머지 값은 모두 true 값을 반환!

```
console.log(
Boolean(1), //Output: true
Boolean(123), //Output: true
Boolean("javascript") //Output: true
)

console.log(
Boolean(0), //Output: false
Boolean(""), //Output: false
Boolean(null), //Output: false
Boolean(undefined), //Output: false
Boolean(NaN) //Output: false
)
```

> 주의사항
>
> Number(null) //Output: 0
>
> ## Number(undefined) //Output: NaN
>
> Boolean(0) // false (숫자 0)
>
> ## Boolean('0') // true (문자 0)
>
> Boolean('') // false (공백 없음)
>
> Boolean(' ') // true (공백이 입력되어 있는 경우)

<br>

# 기본 연산자 Operator

| 기본       | 연산자   |             |            |            |
| :--------- | :------- | :---------- | :--------- | :--------- |
| + : 더하기 | - : 빼기 | \* : 곱하기 | / : 나누기 | % : 나머지 |

## 나머지는 언제 활용할까?

- 홀수: x % 2 = 1
- 짝수: x % 2 = 0

## 거듭제곱

```
const num = 2**3;
console.log(num); //Output: 8
```

## 우선 순위: \* / >>> + -

## 연산자 줄여서 쓰기

- num = num + 5; 같음 num += 5;
- num = num - 5; 같음 num -= 5;
- num = num _ 5; 같음 num _= 5;
- num = num % 5; 같음 num %= 5;

```
let num = 10;
num = num + 5; // num += 5;

console.log(num); //Output: 15
```

## 증가 연산자 & 감소 연산자: 값을 '1'만큼 증가 OR 감소시킴

- num++; / ++num;
- num--; / --num;

```
let num = 10;
num++;
console.log(num); //Output: 11

let num = 10;

let result = num++; // +를 뒤에 적으면, 증가시키기 전의 값을 result에 입력
console.log(result); //Output: 10

let result = ++num; // +를 앞에 적으면, 증가시킨 후의 값을 result에 입력
console.log(result); //Output: 11
```

<br>

# 비교 연산자, 조건문 (if, else)

## 비교 연산자

| 기본     | 연산자   |                  |                  |                        |             |
| :------- | :------- | :--------------- | :--------------- | :--------------------- | :---------- |
| < : 크다 | > : 작다 | <= : 크거나 같다 | >= : 작거나 같다 | == (동등연산자) : 같다 | != : 다르다 |

- '=' 는 '할당'을 의미
  : ex) 'a = 3' 은 'a에 3의 값을 할당'을 의미함
- '==' 는 '값이 같음'을 의미
  : ex) 'a == 3' 은 'a와 3의 값이 같음'을 의미함

```
const a = 1;
const b = "1";

// 동등 연산자
console.log(a == b); //Output: true

// 일치 연산자 -> type 까지 비교해주는 일치 연산자를 쓰는 것이 좋음. 왜? 숫자 1과 문자 1이 같다는 결과를 반환하는 코드는 버그 발생 우려!
console.log(a === b); //Output: false 왜? 등호 3개는 type까지 비교하기 때문!
```

## 조건문 (if, else): 어떤 조건에 따라 그 이후의 코드가 실행되거나 실행되지 않음

if, else, else if

```
const age = 30;

if (age > 19) {
   console.log("환영합니다."); // if 괄호 안의 조건이 true 일 경우, 실행
} else if (age === 19) {
   console.log("수능 잘 치세요."); // else if 안의 조건이 true 일 경우, 실행
} else {
   console.log("안녕히 가세요."); // if 의 조건과 else if 의 조건이 모두 false 일 경우, 실행
}
```

<br>

# 논리 연산자 (AND, OR, NOT)

> - OR 는 첫번째 true 를 발견하는 즉시 평가를 멈춤
> - AND 는 첫번째 false 를 발견하는 즉시 평가를 멈춤

## OR || : 여러개 중 하나라도 true 면 true (즉, 모든 값이 false 일 때만 false 를 반환)

```
// 이름이 Tom 이거나, 성인이면 통과

const name = "Mike";
const age = 30;

if (name === "Tom" || age > 19) {
   console.log("통과");
}
```

## AND && : 모든 값이 true 면 true (즉, 하나라도 false 면 false 를 반환)

```
// 이름이 Mike 이고, 성인이면 통과

const name = "Mike";
const age = 30;

if (name === "Mike" && age > 19) {
   console.log("통과");
} else {
   console.log("돌아가");
}
```

## NOT ! : true 면 false, false 면 true

```
// 나이를 입력 받아 성인이 아니면 돌아가...

const age = prompt("나이가...?");
const isAdult = age > 19;

if (!isAdult) {
   console.log("돌아가...");
}
```

## 우선순위

```
// 남자이고, 이름이 Mike 이거나 성인이면 통과

const gender = "F";
const name = "Jane";
const isAdult = true;

if (gender === "M" && name === "Mike" || isAdult) {
   console.log("통과");
} else {
   console.log("돌아가");
}
```

- 이 코드는 (gender === "M" && name === "Mike" || isAdult), 이 코드 ((gender === "M" && name === "Mike") || isAdult) 와 동일한 의미임
  : &rarr; AND 가 먼저 평가되고, 그 이후에 OR 이 평가되므로, 이 코드는 true 값을 반환함
- 남자이고, 이름이 Mike 이거나 성인이면 통과 => 이 의도대로 코드를 실행하려면, 코드를 이렇게 (gender === "M" && (name === "Mike" || isAdult)) 묶어줘야 함
  : &rarr; OR 이 먼저 평가되고, 그 이후에 AND 가 평가되므로, 이 코드는 false 값을 반환함

<br>

# 반복문 Loop (for, while, do while)

반복문 Loop: 동일한 작업을 여러번 반복

## for Loop 반복문

```
for (초기 값; 조건; 코드 실행 후 작업) {
   //반복할 코드
}
/* i = 0
i 가 10 보다 작으므로
코드 실행
i 값 1 증가 */ //이 과정이 '조건이 false'가 될 때까지 반복 됨

// 1부터 10까지 로그

for (let i = 1; i <= 10; i++) {
   console.log(i);
}
/* Output:
1
2
3
4
5
6
7
8
9
10 */
```

## While Loop 반복문

```
let i = 0;

while (i < 10) {
   console.log(i);
   i++;
}
```

## Do While Loop 반복문

```
let i = 0;

do {
   console.log(i);
   i++;
} while (i < 10); // 조건을 체크하기 전에 적어도 1번은 실행하므로, 이 점이 while loop 와 다른 점이다
```

## break & continue

- break: 멈추고 빠져나옴
- continue: 멈추고 다음 반복으로 진행

```
// break

while (true) {
   let answer = confirm("계속 할까요?"); // 답변이 계속 '확인'으로 입력되는 한 코드는 계속 반복
   if (!answer) { // 답변이 '취소'가 될 경우, 코드 종료
      break;
   }
}

// continue -> 짝수만

for (let i = 0; i < 10; i++) {
   if (i % 2) {
      continue;
   }
   console.log(i);
}
```

> 명확한 횟수가 정해져 있으면 for loop,
>
> 그게 아니라면 while loop
>
> (do while loop는 거의 사용 안함)

<br>

# Switch문

```
// 아래의 switch 문과 if 문은 동일한 코드임

switch (평가) {
   case A :
   // A일때 코드
   case B :
   // B일때 코드
   ...
}

if (평가 == A) {
   // A일때 코드
} else if (평가 == B) {
   // B일때 코드
}
```

```
// 사과 100
// 바나나 200
// 키위 300
// 멜론 500
// 수박 500
// 사고 싶은 과일을 물어보고 가격 알려주기

let fruit = prompt("무슨 과일을 사고 싶나요?");

switch (fruit) {
   case "사과" :
      console.log("100원입니다.");
      break;
   case "바나나" :
      console.log("200원입니다.");
      break;
   case "키위" :
      console.log("300원입니다.");
      break;
   case "멜론" :
   case "수박" :
      console.log("500원입니다.");
      break;
   default :
      console.log("그런 과일은 없습니다.");
      break;
}
```

<br>

# [함수(function)의 기초] => 함수 선언문

- 함수의 목적: 중복을 줄이기 위함
- 긴 코드를 매번 입력 할 필요 없으므로 편함
- 함수 수정이 쉬우므로 유지 보수가 수월

## 함수 without 매개변수

```
// error 메세지를 보여주는 함수 작성
// 이 에러 메세지를 한 서비스에서 100군데에 사용하고 있다고 가정해봅시다.
// 매번 긴 코드를 입력할 필요 없이 showError();만 입력하면 어디서든 해당 함수 사용 가능
// 에러 문구를 수정해야 할 경우 해당 함수의 문구만 변경하면 됨
// 장점: (1)긴 코드를 매번 입력 할 필요 없으므로 편하고, (2)함수 수정이 쉬우므로 유지 보수가 수월

// 매개변수 없는 함수

function showError() {
   alert("에러가 발생했습니다. 다시 시도해주세요.");
}

showError(); // 함수 사용하기
```

## 함수 with 매개변수

```
// 매개변수 있는 함수 1)

function sayHello(name) {
   const msg = `Hello, ${name}`;
   console.log(msg);
}

sayHello("Mike"); // Output: "Hello, Mike"
sayHello("Tom"); // Output: "Hello, Tom"
sayHello("Seyeon"); // Output: "Hello, Seyeon"
// 이렇게 함수를 한번 만들어 놓으면, 매개변수를 바꾸어 가면서 여러 결과를 출력 가능

// 매개변수 있는 함수 2)

let msg = "Hello"; // 전역 변수 (global variable): 어디서나 접근 가능

function sayHello(name) {
   let msg = "Hello"; // 지역 변수 (local variable): 해당 함수 안에서만 사용 가능

   if (name) {
      msg += ", " + name; //msg = msg + `, ${name}`;
   }
   console.log(msg);
}

sayHello(); //Output: "Hello"
sayHello("Mike"); //Output: "Hello, Mike"
```

## 전역 변수와 지역 변수

- 전역 변수 (global variable): 어디서나 접근 가능
- 지역 변수 (local variable): 해당 함수 안에서만 사용 가능

```
let msg = "Welcome";
console.log(msg); //Output: "Welcome"

function sayHello(name) {
   let msg = "Hello";
   console.log(msg + " " + name);
}

sayHello("Mike"); //Output: "Hello Mike"
console.log(msg); //Output: "Welcome"

/* Output:
"Welcome"
"Hello Mike"
"Welcome" */ // 결과에서 알 수 있듯이 '전역 변수'와 '지역 변수'는 서로 영향을 주고 받지 않음.
```

```
let name = "Mike";

function sayHello(name) {
   console.log(name);
}

sayHello(); //Output: undefined(값이 할당되어 있지 않음)
// 전역 변수에 이미 값이 할당되어 있다고, 지역 변수에 값을 할당하지 않아도 되는 건 아님
// 왜? 전역 변수와 지역 변수는 서로 영향을 받지 않고 간섭하지 않기 때문
// 전체 서비스에서 공통으로 바라봐야 하는 변수를 제외하고는, 지역 변수를 쓰는 습관을 들이는게 좋음
// 전역 변수가 많아지면, 관리가 힘들어짐
sayHello("Jane"); //Output: "Jane"
```

함수에 '논리 연산자(AND OR NOT) 적용

```
function sayHello(name) {
   let newName = name || "friend";
   let msg = `Hello, ${newName}`;
   console.log(msg);
}

sayHello(); //Output: "Hello, friend"
seyHello("Jane"); //Output: "Hello, Jane"
```

함수에 default 값 적용

```
function sayHello(name = "friend") { // 이 default 값은 name 에 값이 없을 때만 할당됨
   let msg = `Hello, ${name}`;
   console.log(msg);
}

sayHello(); //Output: "Hello, friend"
seyHello("Jane"); //Output: "Hello, Jane"
```

return 으로 값 반환

```
function add(num1, num2) {
   return num1 + num2;
}

const result = add(2, 3);
console.log(result); //Output: 5
```

함수 (function)

​

> 1. 한번에 한 작업에 집중
> 2. 읽기 쉽고 어떤 동작인지 알 수 있게 네이밍
>    : - showError //에러를 보여줌
>    : - getName //이름을 얻어옴
>    : - createUserData //유저데이터 생성
>    : - checkLogin //로그인 여부 체크

<br>

# 함수 표현식, 화살표 함수(arrow function)

## 함수 선언문 vs 함수 표현식

<공통점>

- 함수를 사용하고 실행하는 방식도, 함수가 동작하는 방식도 동일함

<차이점>

1. 함수 선언문: 어디서든 호출 가능

```
function sayHello() {
   console.log("Hello");
}
sayHello(); // 작동 ㅇ

------------------------------------------------------------------------
sayHello(); // 함수 실행 코드의 위치를 바꿔도 작동 ㅇ

function sayHello() {
   console.log("Hello");
}
```

- 자바스크립트는 '위에서 아래로' '차례대로' '한 줄씩 읽으면서' 실행함
- 이렇게 순차적으로 실행되고 즉시 결과를 반환하는 프로그래밍 언어를 '인터프리터 언어(Interpreted Language)라고 함
- 그런데, 어떻게 이 코드는 실행 가능했던 걸까? 자바스크립트 내의 알고리즘 때문에 가능했음
- 자바스크립트는 실행 전 초기화 단계에서 코드의 함수 선언문을 찾아서 생성해둠
- 즉, 우리가 봤을 때는 함수보다 실행문이 위에 위치해 있지만, 사실 함수의 사용 가능 범위는 실제 위치보다 더 위쪽에 위치해 있는 거임 -> 이것을 호이스팅 (Hoisting) 이라고 함
- 근데 이게 실제 코드가 위로 올라간다는 의미는 아님

2. 함수 표현식

```
let sayHello = function() {
   console.log("Hello");
}

sayHello();
```

- 함수 표현식은 위에서 설명한 함수 선언문처럼 동작하지 않음
- 자바스크립트가 한 줄 씩 코드를 실행하도 해당 코드에 도달해서야 비로소 작동함
- 그러므로 함수 실행 코드가 무조건 함수 표현식 이후에 위치해야 함

## 화살표 함수 (arrow function)

```
// 함수 표현식
let add = function(num1, num2) {
   return num1 + num2;
}

// 화살표 함수
let add = (num1, num2) => { // function 을 없애고 화살표 추가
   return num1 + num2;
}
// 더 간단하게 바꾼다면,
let add = (num1, num2) => (
   num1 + num2; // return 문은 중괄호가 아닌 소괄호로 변경 가능
)
// 더더 간단하게 바꾼다면,
let add = (num1, num2) => num1 + num2; // return 문이 한줄이라면, 괄호도 생략 가능
```

> 함수 선언문 vs 함수 표현식
>
> 무엇을 사용해야 할까?
>
> 신경 쓰기 싫다면, 그냥 '함수 선언문' 사용하는게 맘 편함

<br>

# 객체(Object)

## Object - 접근, 추가, 삭제

```
// 객체 예시
const superman = {
   name: 'clark', // name 은 키(key), 'clark' 은 값(value)을 의미함
   age: 33,
}

// 1. 접근
superman.name //'clark'
superman['age'] //33

console.log(superman.name); //Output: 'clark'
console.log(superman['age']); //Output: 33

// 2. 추가
superman.gender = 'male';
superman['hairColor'] = 'black';
/* Output:
Object {
   name: 'clark',
   age: 33,
   gender: 'male',
   hairColor: 'black',
} */

// 3. 삭제
delete superman.hairColor;
/* Output:
Object {
   name: 'clark',
   age: 33,
   gender: 'male',
} */

------------------------------------------------------------------------

function makeObject(name, age) {
   return {
      name: name,
      age: age,
      hobby: 'football',
   };
}

const Mike = makeObject("Mike", 30);
console.log(Mike);
/* Output:
Object {
   name: 'Mike',
   age: 30,
   hobby: 'football',
} */
```

## Object - 단축 프로퍼티

```
const name = 'clark';
const age 33;

const superman = {
   name, // 는 name: name 와 같은 의미
   age, // 는 age: age 와 같은 의미
   gender: 'male',
}

------------------------------------------------------------------------

function makeObject(name, age) {
   return {
      name,
      age,
      hobby: 'football',
   };
}

const Mike = makeObject("Mike", 30);
console.log(Mike);
/* Output:
Object {
   name: 'Mike',
   age: 30,
   hobby: 'football',
} */
```

## Object - 프로퍼티 존재 여부 확인

```
const superman = {
   name: 'clark',
   age: 33,
}

superman.birthDay; //undefined

// 프로퍼티 존재 여부를 확인하기 위해 'in' 연산자 사용 가능
'birthDay' in superman; //false
'age' in superman; //true

------------------------------------------------------------------------

function makeObject(name, age) {
   return {
      name: name,
      age: age,
      hobby: 'football',
   };
}

const Mike = makeObject("Mike", 30);

console.log('age' in Mike); //true
console.log('birthday' in Mike); //false

------------------------------------------------------------------------

function isAdult(user) {
   if (!('age' in user) || user.age < 20) { // user에 age가 없거나 20살 미만이거나
      return false;
   }
   return true;
}

const Mike = {
   name: 'Mike',
   age: 30,
};

const Jane = {
   name: 'Jane',
};

console.log(isAdult(Mike)); //Output: true
console.log(isAdult(Jane));
//Output: false -> 결과 값이 false 가 나오기 위해서는,
//if 조건문에서 age가 user 안에 없는 경우도 추가해줘야 한다
```

## for ... in 반복문

```
for (let key in superman) {
   console.log(key)
   console.log(superman[key])
}

------------------------------------------------------------------------

const Mike = {
   name: 'Mike',
   age: 30,
};

for (x in Mike) {
   console.log(x); //Output: "name" "age"
   console.log(Mike[x]) //Output: "Mike" 30
}
```

<br>

# 객체(Object) - method, this

## Method: 객체 프로퍼티로 할당된 함수

<br>

# 배열(Array)

<br>

---

<br>

    🖋️ This is my self-taught blog! Feel free to let me know
    if there are some errors or wrong parts 😆

[Back to Top](#){: .btn .btn--primary }{: .align-right}
