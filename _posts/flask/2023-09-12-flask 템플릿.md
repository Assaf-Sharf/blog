---
title:  "Flask 템플릿"
excerpt: " Flask 공부"

categories:
  - Flask
tags:
  - [Python, Flask]

toc: true
toc_sticky: true

breadcrumbs: true
 
date: 2023-09-12
last_modified_at: 2023-09-12
---


# 템플릿 렌더링

css나 js같은경우 page마다 공통적으로 사용하는 경우가 많다. layout.html을 만들어서 중앙관리를 하고 다른 index.html이나 다른 html은 layout.html을 상속받는 형식으로 만든다.

layout.html은 jinja의 Template Designer Documentation만 보고 사용해보자.

이게 template engine 문법이다.

```
{% block head %}


{% endhead %}
```

페이지마다 title명을 바꾸고 싶을때를 위해 지정해놓자.

이제 index.html에서 상속받게 해보자.

head가 안들어오는 이유는? 상속받는 layout.html의 해당부분을 그대로 이용한다는 내용을 적어줘야한다. python에서 부모상속받듣이 그대로 쓰면 된다.

```
{% block head %}
    {{ super( )}}
{% endblock %}
```

이러면 index.html이지만 layout.html에 있는 css나 js들을 동일하게 load할수 있따.

indent를 맞춰주기 위해 -를 붙여줄수 있따.
-는 빈공백을 제거하겠다는 의미이다.

404 error : not founded page 떳을때 html이 중앙관리를 한다.
그걸동일하게 layout.html에서 받아서 작성해보자.

그러기 위해 404.html을 만들고
라우터를 조정해줘야한다.

- __init__.py에 들어가서 errorhandler를 추가해주면 된다.


## 정적파일 추가 및 디버그 환경 캐시제거

- style.css 파일생성
  - 연결
  - flask routes
- 정적파일 기본 캐시에 관해 (크롬 개발자 도구)
- flask config 수정 - 디버그 환경
  - SEND_FILE_MAX_AGE_DEFAULT - 디버깅 모드에서 캐시 제거
  - TEMPLATES_AUTO_RELOAD - 템플릿 리로드
- url_for를 통한 정적파일 서빙

### style.css 파일생성 및 static 폴더 연동

- flask routes 치면

![image](https://github.com/OC-JSPark/oc-jspark.github.io/assets/46878973/d5f69c60-e5fc-4252-b17b-ec9b3de35c6a)

  - 여기서 static 은 flask에서 자동으로 path잡아주는 곳이므로
해당 static 폴더를 만들어서 사용해보자.

  - static에 css폴더만들고 그안에 style.css 만들자.
만들고 나서는 layout.html에 연결시키자.

### 정적파일 기본 캐시에 관해 (크롬 개발자 도구)

![image](https://github.com/OC-JSPark/oc-jspark.github.io/assets/46878973/74c67e44-c409-4921-b9f3-9ec2c17f276f)

- max-age=43200 : 12h를 의미한다.기본적으로 12시간 캐싱을 플라스크에서 stati file에 대해서 기본적으로 제공한다.
그래서 동적으로 우리가 100px으로 줄인다면 바로안바뀐다. 캐시비움(ctrl+shift+r)을 해야 적용된다.
이러한 부분을 app.config에 디버그를 조회를 해서 분기처리를 해줄것이다.
개발환경에서만 캐시를 제거해주게끔!
그래서 init.py에가서 SEND_FILE_MAX_AGE_DEFAULT 를 설정해주자.

```
def create_app():
    print('run: create_app()')
    app = Flask(__name__)

    if app.config['DEBUG']: #true일때
        app.config['SEND_FILE_MAX_AGE_DEFAULT'] = 1 # 1s로 바꾸니 바로 갱신될것이다.

```

- TEMPLATES_AUTO_RELOAD - 템플릿 리로드
: FLASK_ENV=development 형태로 켜주게 되면 자동으로 on이 된다.

### url_for를 통한 정적파일 서빙

- static 경로를 바로 연결안해준다. 보통은 {{url_for('static', filename='css/style.css')}}


- 레퍼런스
[flask config수정-디버그환경](https://flask.palletsprojects.com/en/1.1.x/config/#SEND_FILE_MAX_AGE_DEFAULT)


## WTF을 이용한 CSRF 공격조치

- flask wtf 설치
- 의존성 패키지 기록
- flask config 시큐리티 설정
- flask wtf 이니셜라이즈
- flask form 틀 만들기
- login, register, logout 엔드포인트작성
- login.html
- register.html
- csrf_token 노출 시켜보기
- form 노출 시켜보기


### CSRF란?
CSRF(Cross Site Request Forgery), 사이트간 요청위조를 뜻함. 공격자는 희생자의 의지와 무관하게 공격자가 의도한 작업이 웹사이트에서 실행되게끔 유도하는 해킹방법.

- [HTTP](https://developer.mozilla.org/ko/docs/Web/HTTP)
- [HTTp 설명 보조](https://github.com/hidekuma/gogglekaap/wiki/G.1.-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B8%B0%EB%8A%A5-%EA%B5%AC%ED%98%84:-%EC%84%B8%EC%85%98%EC%9D%B4%EB%9E%80%3F)

```
<form action="http://웹사이트.com/api/user" method="put"> 
  <input type="hidden" name="password" value="123456" /> 
  <input type="submit" value="클릭하면 100만원"/>
</form>
```
  - 만약 로그인이 되어있다면 공격자가 api/user라는 엔드포인트의 method의 put으로 password필드를 같이 날리면 비밀번호인 value가 바뀌는걸 확인했다. 
  - 즉 유저가 해당 버튼 클릭시 유저의 password를 123456으로 업데이트하게 된다.
  - 서버는 비연결성프로토콜이기 때문에 클라이언트의 상태를 잘모르니깐 그대로 그 유저라 판단하고 리퀘스르를 처리해버린다.

![image](https://github.com/OC-JSPark/oc-jspark.github.io/assets/46878973/3c3f2482-f678-4dbc-9909-ab0bb2fafb65)

  - 공격자는 공격용 Web 페이지를 준비하고 사용자가 액세스하도록 유도한다.
  - 사용자가 공격용 Web 페이지에 액세스하면, 미리 준비되어 있던 잘못된 요청이 공격 대상 서버에 보내진다.
  - 공격 대상 서버의 Web 응용 프로그램은 잘못된 요청을 처리하고 사용자가 의도하지 않은 처리를 진행한다.

- CSRF 토큰 검증
CSRF방어가 필요한 요청(=쓰기/변경이 가능한 엔드포인트 및 메서드들이 리퀘스트가 발생할때마다) 마다 특정 토큰을 포함시켜서 요청하여, 서버에서 비교하는 방식
즉, 토큰이 다를경우 리퀘스트가 잘못됬다고 판단함!

- 레퍼런스
[CSRF](https://flask-wtf.readthedocs.io/en/1.1.x/csrf/)
[flask_WTF](https://flask-wtf.readthedocs.io/en/1.1.x/)
[flask_config](https://flask-wtf.readthedocs.io/en/1.1.x/config/)


- workflow
  - 참조 v1.0.3

```
pip install flask-wtf
conda list --export > packagelist.txt
```

  - WTF같은경우는 secret_key가 무조건 등록되어있어야 한다. 왜냐하면 csrf 자체가 암호화 되어있기 떄문에!
  - flask_config 에도 나와있다. 
  - 여기선 단순하게 init.py밑에 create_app에다가 app.config['SECRET_KEY'] = 'secretkey' 이부분만 넣어서 처리해보자.


  - 로그인구현전에 form을 만들어보자.
    - forms폴더를 생성 후 auth_form.py를 만든 후 로그인,레지스터에 대한 클래스르 만들어준다.

    - 그후 init.py에다가 로그인,로그아웃, 레지스터를 정의해주고 라우터 연결해두자.

  - 그다음 templates에 html을 만들자. 
    - login.html, register.html 
    - 일단 해당 html에 상속받게 명령어 넣자.


## Flask WTF로 로그인 회원가입 폼 레이아웃 작성

- 로그인, 회원가입 auth_form 상세 작성
  - 패스워드 확인 비교
- 폼 전송 후 데이터 노출
    - form.validate_on_submit()을 통한 메서드별 화면분기
  - 로그인 인입 데이터 노출해보기
  - 회원가입 인입 데이터 노출해보기
- 각 함수의 내부 TODO 작성하기
- login.html, register.html 폼 필드 뷰로 재현하기
- form.errors 확인해보기

- 레퍼런스
[WTF Forms](https://wtforms.readthedocs.io/en/2.3.x/)
[field-definitions](https://wtforms.readthedocs.io/en/2.3.x/fields/#field-definitions)
[flask WFTorms](https://flask.palletsprojects.com/en/1.1.x/patterns/wtforms/)

- 참고 v1.0.4
auth.form.py를 작성해보자.
field를 먼저 만들자.(공식문서참조)
로그인과 로그인할때 userId , password field, password 확인 field가 필요
field를 다 만든다음에 front에 띄어보자.
login.html 수정하자.  
그리고 register.html도 수정하자

그후 method날려서 request 오는지 확인해보자.

버튼을만들어주자.

```
<input type="submit" value="go">
```

이제 init.py가서 
login,register할떄  methods=['GET','POST'] 설정해주자.
그리고 init되는게 정상적으로 들어오는지 front에 출력해보자.



```
# POST,validate OK
        if form.validate_on_submit():
            ## TODO
            # 1) 유저조회
            # 2) 유저 이미 존재하는지 체크
            # 3) 패스워드 정합확인
            # 4) 로그인유지(세션)
            user_id = form.data.get('user_id')
            password = form.data.get('password') 
            return f'{user_id}, {password}'
        else:
            # TODO: Error
            pass 
```
form을 만들어보고 front에 노출시켜보고 validator 처리까지함.

## 블루프린트를 통한 라우팅 확장
라우트 처리가 많아지고 점차 관리가 힘들어질때, 블루프린트를 이용하면 확장에 용이해진다.


- base_route 작성하기
- auth_route 작성하기
- auth index 추가작성
- Front에 블루프린트 네임스페이스 반영하기
- template/auth 경로로 변경
- flask routes


- 참고 v1.0.5

- 레퍼런스
[Blueprint](https://flask.palletsprojects.com/en/1.1.x/blueprints/)

init.py의 index 라우트를 베이스로 만들어보자.
routes 폴더만든후 그안에 base_route.py를 만들자.
auth_route.py는 로그인관리하는 라우트.
그리고 blueprint를 이니셜라이즈 해준다.


```
from flask import Blueprint, render_template, abort
from jinja2 import TemplateNotFound

simple_page = Blueprint('simple_page', __name__,
                        template_folder='templates')

@simple_page.route('/', defaults={'page': 'index'})
@simple_page.route('/<page>')
def show(page):
    try:
        return render_template('pages/%s.html' % page)
    except TemplateNotFound:
        abort(404)
```

공식문서 참조해서 이해해보자.
그냥 import blueprint후에 simple_page에 이니셜라이즈해주는구나.
쓰는 방법은 @app.route했듯이 blueprint를 route해서 함수매핑해주고 로직짜주면 되는구나.
그 후 base_route.py를 init.py에서 연동시켜줘야 한다.

```
from googlekaap.routes import base_route
app.register_blueprint(base_route.bp)
```

bp = Blueprint(NAME, __name__, url_prefix='/auth') # blueprint아래에 작성되는 라우터는 모두 prefix를 auth를 갖게된다.공통관리가능.
그러면 라우터에 /auth부분들 모두 생략가능.


그후 템플릿안에 폴더도 관리해주자.
templates폴더안에 auth폴더 하나 만들어주자.여기다가 login과 register를 옮겨주자.
그리고 auth_route.py가서 

werkzeug.routing.BuildError
werkzeug.routing.BuildError: Could not build url for endpoint 'login'. Did you mean 'auth.login' instead?

이런에러 뜨는이유는? login.html에 보면 url_for에 namespace가 들어가줘야해서그래!
<form method="POST" action="{{ url_for('auth.register')}}">
각각 auth를 넣어줘라

지금 라우터가 되는건 똑같은데 파일관리를 조금더 효율적으로 바꾸었다.
route라는 폴더를 만들고 그안에 .py를 만들어서 확장가능하게 바꾸었다.
실제로 init.py들어가면 아주 꺠끗한상태가 됨.


## 플라스크 플래싱으로 폼 유효성 검사결과 노출


- Flask wtf form 에러를 flask flash로 전환처리
    - Flask wtf 에러 외에 에러와 통합할 필요성이 있기 때문(유저검증이나 패스워드 검증과 같은)
- _errors.html 작성
- include template
- form.errors는 삭제처리

- 레퍼런스
[플래싱](https://flask.palletsprojects.com/en/1.1.x/patterns/flashing/)

WTF의 장애를 이용하는것보단 플라스크의 메시지 플래싱을 이용해서 wft와 플라스크 자체의 커스텀할 밸리데이션부분을 통합해서 프론트에 노출시켜줄것이다.
플래싱은 가장 빠르게 에러를 프론트에 노출시키는 방법이다. 
flask를 임포트후에 error를 노출시킨다. error에 대한것을 reflash로 호출만해주면된다.

```
(auth.route.py)
@bp.route('/')
def index():
    return redirect(url_for(f'{NAME}.login'))

```

이렇게 만들면 /auth 로 접근시 login 페이지로 redirect해준다.

현재 flask wtf를 통해 에러가 나온다.왜?
auth_form.py에서 Equlto를 이용해서 password가 match인지 아닌지를 확인했기 떄문에 노출이 된다.
이 에러를 통합해보자.

일단, auth_route.py에서 else에서 TODO error를 만들어보자.

이제 error도 include해서 쓸거기 때문에 따로 하나 만들자
templates안에 _errors.html만들자. 
참고자료를 참조해서 그냥 넣자!!

```
(_errors.html)
{% for message in get_flashed_messages() %}
    {{ message}}
{% endfor %}

```

이러고 나서 login과 logout page에 모두 include해주자.

```
{% include "_errors.html" %}
```

이제는 login.html에 {{ form.errors }}는 삭제해줘도 된다.
이젠 wtf error가 나오는게 아니라 플라스크의 기본메시징으로 프론트에 표시된다.
에러노출시 가장편리하게 사용가능한 방법이다.




[맨 위로 이동하기](#){: .btn .btn--primary }{: .align-right}
 

