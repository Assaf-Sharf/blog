---
layout: single
title: BOJ-10811-python [다시풀기]
tags: BOJ
---

## 문제  
10811

## solution  
n개 바구니가 있다. m번 바구니의 순서를 역순으로 만들려고 한다.
첫째줄에 N M이 주어지고 i j 가 주어지는데 i번째 바구니부터 j번째 바구니의 순서를 역순으로 하면된다. 입력으로 주어진 순서대로 바꾸고 순서대로 공백으로 구분하여 출력하기.  
  
1부터 N까지 리스트를 만들고, 주어지는대로 바꾸어서 출력하면 될 것으로 보인다.  

## CODE  

```python
N,M = map(int,input().split())
result = [i for i in range(1,N+1)]
for tmp in range(M):
    i,j = map(int,input().split())
    tmp_change = list(reversed(result[i-1:j]))
    result = result[:i-1] + tmp_change + result[j:]
print(' '.join(map(str,result)))
```
파이썬은 이렇게 풀면 되겠는데. 뒤집는 부분을 직접 구현하다가 막혔다.  

```python
N,M = map(int,input().split())
result = [i for i in range(1,N+1)]
for tmp in range(M):
    i,j = map(int,input().split())
    for cnt in range((j-i)//2):
        result[i-1],result[j-1] = result[j-1],result[i-1]
print(' '.join(map(str,result)))
```
이런식의 풀이를 생각하고 있었는데, 문제 생기는 경우를 피할려면 reverse부분만 구현하는 식으로, 뒤집을 부분만 분리해서 전부 뒤집고 앞뒤로 더하는 방법이 깔끔하다는 생각은 든다.  
j-i 를 2로 나눈 몫을 이용해야 하는건지, j-i-1을 이용해야 하는건지  
쉬운 문제인데...  
  

```python
a[i-1:j]=a[i-1:j][::-1]

# a[i-1:j] 자체가 배열이므로 [::-1]해서 읽으면 된다.
# [i-1:j:-1] 이런식으로 하려니까 꼬였는데, step이 -1이라서 저렇게 쓰면 안되는것.
```
뒤집어야 되는 부분은 이렇게 처리하면 된다.  