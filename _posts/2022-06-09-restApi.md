
주요 프로토콜
OSI 7 Layers  

<7층  —- 응용계층 —   >

HTTP : 웹에서 HTML ,JSON 등의 정보를 주고받는 프로토콜 

HTTPS : http 에서 보안이 강화된 프로토콜

FTP : 파일 전송 프로토콜

SMTP : 메일 전송 프로토콜

SSH : CLI 환경의 원격 컴퓨터에 접속하기 위한 프로토콜

RDP : Windows 계열의 원격 컴퓨터에 접속하기 위한 프로토콜

WebSocket : 실시간 통신, Push 등을 지원하는 프로토콜

< 6층 —— 표현 계층 —— >  

< 5층 —— 세션 계층 —— > 

< 4층 ——  전송 계층 —— > 

TCP : http, ftp 통신의 등의 근간이 되는 인터넷 프로토콜 

UDP : 양방향의 tcp와는 다르게 단방향으로 작동하는 훨씬 더 단순하고 빠르지만 신뢰성이 낮은 인터넷 프로토콜

< 3층 —— 네트워크 계층 —— > 

< 2층 —— 데이터 링크 계층 —— > 

< 1층 —— 물리 계층 —— > 

# API(Application Programming Interface): 한 프로그램에서 다른 프로그램으로 데이터 주고받기 위한 방법

- 웹툰 보내주는 프로그램

메뉴판 있어야하고, .. 신과함께 바로 커스텀해서 날려보내주지 않음,, 궁예질 ㅇ불가능,, (그 방법..>바로 코드로 이루어짐)

```jsx

이 url로 get 요청을 하면~ 
app.get('.detail/:id',function(req,res){이부분부터 API
//근데 막 쳐들어가서 주문하지 못하니까. 요청을 해야한다. 위의 코드
db.collection('웹툰').findOne({_id: parseInt(요청.parsms.id}), function (에러,결과
0{console.log(결과);
res.render('detail.ejs', {data.ejs', {data: 결과});})이 코드 실행해주세요~!~!~!
{/*실행하면 디비에서 웹툰 뽑아서 보여줌*/}
```

## XMLHttpRequest

“Aw, Snap!” 크롬 브라우저 페이지 로드 문제임

ERR_NAME_NOT_RESOLVED 호스트이름 웹 주소가 존재하지 않는다.

ERR INTERNET DISCONNECTED

사용중인 기기가 인터넷에 연결되지 않았다.

ERR CONNECTION TIMED OUT ERR TIMED OUT

웹페이지에 연결하는데 시간이 너무 오래걸린다.

ERR CONNECTION RESET

웹페이지 연결을 방해하는 요소가 어딘가에 발생했따.

ERR NETWORK CHANGED

웹페이지를 로드하는 중에 기기의 네트워크 연결이 해제되었거나 ㅅ로운 네트워킁에 연결되었ㄷ.

ERR CONNECTION REFUSED

웹페이지에서 크롬 브라우저의 연결을 허용하지 않았따.

ERR CACHE MISS

웹페이지로부터 이전에 입력한 정보를 다시 한번 제출하도록 요청받앗다

ERR EMPTY RESPONSE

웹페이지에서 데이터를 전혀 전송하지 않았으며, 데이터를 전송할 서버가 다운되었을 수 있따.

ERR SSL PROTOCOL ERROR 

페이지에서 젅송된 데이터를 크롬브라우저가 해석하지 못했다

ERR BAD SSL CLIANT AUTH CERT

킄ㄹ라이언트 인증서에 오류가 발생하여 웹ㅍ페이지에 로그인할 수 없다.

[그림] HTTP Messages의 구조

요청(Requests)과 응답(Responses)은 다음과 같은 유사한 구조를 가집니다.

1. start line : start line에는 요청이나 응답의 상태를 나타냅니다. 항상 첫 번째 줄에 위치합니다. 응답에서는 status line이라고 부릅니다.
2. HTTP headers : 요청을 지정하거나, 메시지에 포함된 본문을 설명하는 헤더의 집합입니다.
3. empty line : 헤더와 본문을 구분하는 빈 줄이 있습니다.
4. body : 요청과 관련된 데이터나 응답과 관련된 데이터 또는 문서를 포함합니다. 요청과 응답의 유형에 따라 선택적으로 사용합니다.

이 중 start line과 HTTP headers를 묶어 요청이나 응답의 헤드(head)라고 하고, [payload](https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EB%A1%9C%EB%93%9C_(%EC%BB%B4%ED%93%A8%ED%8C%85))는 body라고 이야기합니

# fetch

```jsx
fetch('https://jsonplaceholder.typicode.com/posts/1'
.then((response) => response.json())
.then((json) => console.log(json)); //Promise {<pending>}
//Response
fetch ('https://jsonplaceholder.typocode.com/posts/1'
.then((response) => response.json())
.then((json) => console.log(json));
```

# JSON

JSON.stringify ({x: 5,y :6}) 일반적인 자바스크립트 코드를 제이슨 형식으로 바꾸어줌

⇒  (서버로 데이터를 보낼 때 )

JSON.stringify([new Number(3), new String(’false’), new Boolean(false)])

JSOn.stringify({x: [10, undefined, function(){}, Symbol(’ ’)] })

↔ 반대개념 JSON.parse  (서버에서 데이터를 가져올 때 많이 사용)

제이슨객체를 자스객체로 만들어준다.
