---
layout : single
title : SQL 조인 JOIN
categories:
  - Blog
tags:
  - Blog
---

> ### 조인

- 테이블 2개에 존재하는 각 컬럼의 데이터를 비교하여, 일치되는 데이터를 수평적 결합을 하는 형태



---

> ###### ANSI JOIN, ORACLE JOIN

~~~sql
-- 1)
SELECT employee_id, EMP_NAME, DEPARTMENT_ID
FROM EMPLOYEES
WHERE ROWNUM <= 10;

-- 2)
SELECT department_id, DEPARTMENT_NAME FROM DEPARTMENTS;

-- 모든 사원정보의 데이터를 출력하라
-- (EMPLOYEES 테이블 : 사원번호, 이름   DEPARTMENTS 테이블 : 부서이름)
-- 컬럼순서는 사원번호, 이름, 부서이름

-- ANSI 조인(표준) - INNER JOIN
SELECT EMPLOYEE_ID, EMP_NAME, DEPARTMENT_NAME
FROM EMPLOYEES INNER JOIN DEPARTMENTS
ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;

-- ORACLE 조인 - INNER JOIN
SELECT EMPLOYEE_ID, EMP_NAME, DEPARTMENT_NAME
FROM EMPLOYEES, DEPARTMENTS
WHERE EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;
~~~

~~~sql
-- 테이블 조인 3개

-- 오라클 INNER JOIN
SELECT *
FROM EMPLOYEES E, DEPARTMENTS D, JOB_HISTORY JH
WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID
AND D.DEPARTMENT_ID = JH.DEPARTMENT_ID;

-- ANSI INNER JOIN
SELECT *
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
                 ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
                 INNER JOIN JOB_HISTORY JH
                 ON D.DEPARTMENT_ID = JH.DEPARTMENT_ID;
~~~


---

> ###### OUTER JOIN

~~~sql
-- 부서가 담당했던 JOB_ID 를 출력하라
-- 컬럼은 DEPARTMENT_ID, DEPARTMENT_NAME, JOB_ID
-- DEPARTMENT_ID 컬럼은 테이블에 둘다 존재하므로, SELECT절에 사용시 테이블명.컬럼명 코드처리 해야함

-- JOB_HISTORY 테이블에 있는 부서 정보를 출력한 의미
-- ANSI INNER JOIN (일치되는 데이터를 수평적 결합)
SELECT DEPARTMENTS.DEPARTMENT_ID, DEPARTMENT_NAME, JOB_ID
FROM DEPARTMENTS INNER JOIN JOB_HISTORY
ON DEPARTMENTS.DEPARTMENT_ID = JOB_HISTORY.DEPARTMENT_ID;



-- JOB_HISTORY 테이블에 없는 부서가 조회되지 않았다
-- 모든 부서도 출력하자
-- 부서 테이블 중 JOB_HISTORY 테이블에 데이터가 존재하지 않는 부서도 포함해서 출력
-- OUTER JOIN (일치되지 않는 데이터까지 수평적 결합) - NULL로 표시됨
-- LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN

-- 1) LEFT OUTER JOIN : 좌측테이블의 일치하지 않는 데이터 조인
SELECT DEPARTMENTS.DEPARTMENT_ID, DEPARTMENT_NAME, JOB_ID
FROM DEPARTMENTS LEFT OUTER JOIN JOB_HISTORY
ON DEPARTMENTS.DEPARTMENT_ID = JOB_HISTORY.DEPARTMENT_ID;

-- 2) RIGHT OUTER JOIN : 우측테이블의 일치하지 않는 데이터 조인 - JOB_HISTORY에 일치되지 않는 데이터 없음
SELECT DEPARTMENTS.DEPARTMENT_ID, DEPARTMENT_NAME, JOB_ID
FROM DEPARTMENTS RIGHT OUTER JOIN JOB_HISTORY
ON DEPARTMENTS.DEPARTMENT_ID = JOB_HISTORY.DEPARTMENT_ID;

-- 3,4번 코드 똑같음
-- 3) 오라클 LEFT OUTER JOIN (+) : 조인조건에서 데이터가 없는 테이블의 컬럼에 사용
SELECT DEPARTMENTS.DEPARTMENT_ID, DEPARTMENT_NAME, JOB_ID
FROM JOB_HISTORY, DEPARTMENTS
WHERE DEPARTMENTS.DEPARTMENT_ID = JOB_HISTORY.DEPARTMENT_ID(+);

-- 4) 오라클 RIGHT OUTER JOIN (+) : 조인조건에서 데이터가 없는 테이블의 컬럼에 사용
SELECT DEPARTMENTS.DEPARTMENT_ID, DEPARTMENT_NAME, JOB_ID
FROM JOB_HISTORY, DEPARTMENTS
WHERE DEPARTMENTS.DEPARTMENT_ID = JOB_HISTORY.DEPARTMENT_ID(+);
~~~

---

> ###### FULL OUTER JOIN

~~~sql
-- ANSI : FULL OUTER JOIN(LEFT OUTER JOIN + RIGHT OUTER JOIN)

-- JOB_HISTORY 테이블의 부서코드 컬럼의 데이터가 DEPARTMENTS 테이블에 부분집합.
-- 즉 종속적인 관계로 인하여

-- 1)
SELECT DEPARTMENTS.DEPARTMENT_ID, DEPARTMENT_NAME, JOB_ID
FROM DEPARTMENTS FULL OUTER JOIN JOB_HISTORY -- JOB_HISTORY 일치하지 않는 데이터 없음
ON DEPARTMENTS.DEPARTMENT_ID = JOB_HISTORY.DEPARTMENT_ID;

-- 2)
SELECT DEPARTMENTS.DEPARTMENT_ID, DEPARTMENT_NAME, JOB_ID
FROM DEPARTMENTS LEFT OUTER JOIN JOB_HISTORY
ON DEPARTMENTS.DEPARTMENT_ID = JOB_HISTORY.DEPARTMENT_ID;

-- 오라클 FULL OUTER JOIN는 지원 안한다
-- 즉 조인조건에 (+), (+) 2개를 좌,우측에 사용하는 문법은 없다
SELECT DEPARTMENTS.DEPARTMENT_ID, DEPARTMENT_NAME, JOB_ID
FROM JOB_HISTORY, DEPARTMENTS
WHERE DEPARTMENTS.DEPARTMENT_ID(+) = JOB_HISTORY.DEPARTMENT_ID(+);
~~~

---

> ###### 카타시안 조인

~~~sql
-- 카타시안 조인(CATASIAN PRODUCT)은 WHERE 절에 조인 조건이 없는 조인을 말한다
-- 즉 FROM 절에 테이블을 명시했으나, 두 테이블 간 조인 조건이 없는 조인이다

-- 107 * 27 = 데이터 행 (2889)
SELECT A.EMPLOYEE_ID, A.EMP_NAME, B.DEPARTMENT_ID, B.DEPARTMENT_NAME
FROM EMPLOYEES A, DEPARTMENTS B;
-- WHERE절이 없는 형태
~~~

---

> ###### USING 사용시

~~~sql
-- USING 사용시 SELECT절에 컬럼 앞에 별칭 생략해야 한다
SELECT A.EMPLOYEE_ID, A.EMP_NAME, DEPARTMENT_ID, B.DEPARTMENT_NAME
FROM EMPLOYEES A -- 테이블 별칭 A
INNER JOIN DEPARTMENTS B -- 테이블 별칭 B
USING (DEPARTMENT_ID) -- ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DAPARTMENT_ID
WHERE A.HIRE_DATE >= TO_DATE('2003-01-01', 'YYYY-MM-DD');
-- 두 테이블간 조인조건에 사용되는 컬럼명이 동일한 경우가 많지만, USING 대신 ON 절을 사용하는 것이 일반적

-- SELECT절에 테이블명.컬럼명 -> 컬럼명.(테이블명 생략)

-- ON절을 사용시 SELECT절에 조건을 사용하는 중복된 컬럼명은 별칭을 사용해야한다
SELECT A.EMPLOYEE_ID, A.EMP_NAME, A.DEPARTMENT_ID, B.DEPARTMENT_NAME
FROM EMPLOYEES A -- 테이블 별칭 A
INNER JOIN DEPARTMENTS B -- 테이블 별칭 B
ON A.DEPARTMENT_ID = B.DEPARTMENT_ID;

-- 테이블 별칭 사용 안한 경우
SELECT EMPLOYEE_ID, EMP_NAME, DEPARTMENTS.DEPARTMENT_ID, DEPARTMENT_NAME
FROM EMPLOYEES -- 테이블 별칭 A
INNER JOIN DEPARTMENTS -- 테이블 별칭 B
ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;
~~~

