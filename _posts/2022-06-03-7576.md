---
layout: single
title:  "[백준]7576번: 토마토(Python)"
categories: baekjoon
tag: [python, class_3, algolithm, gold, bfs]
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

# 토마토

solved_ac[Class3] [토마토](https://www.acmicpc.net/problem/7569)

## 문제

철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자 모양 상자의 칸에 하나씩 넣어서 창고에 보관한다. 

![캡처](https://user-images.githubusercontent.com/95459089/171879576-4ed30b9f-16ad-431c-afb8-a120a9158cd6.PNG)

창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토의 인접한 곳은 왼쪽, 오른쪽, 앞, 뒤 네 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지, 그 최소 일수를 알고 싶어 한다.

토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.


## 입력

첫 줄에는 상자의 크기를 나타내는 두 정수 M,N이 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M,N ≤ 1,000 이다. 둘째 줄부터는 하나의 상자에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 상자에 담긴 토마토의 정보가 주어진다. 하나의 줄에는 상자 가로줄에 들어있는 토마토의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다.

토마토가 하나 이상 있는 경우만 입력으로 주어진다.

## 출력

여러분은 토마토가 모두 익을 때까지의 최소 날짜를 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.


## 예제 입력 1 

```
6 4
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 1
```

## 예제 출력 1 

```
8
```

## 예제 입력 2

```
6 4
0 -1 0 0 0 0
-1 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 1
```

## 예제 출력 2

```
6
```

## 예제 입력 3

```
6 4
1 -1 0 0 0 0
0 -1 0 0 0 0
0 0 0 0 -1 0
0 0 0 0 -1 1
```

## 예제 출력 3

```
6
```

## 예제 입력 4

```
5 5
-1 1 0 0 0
0 -1 -1 -1 0
0 -1 -1 -1 0
0 -1 -1 -1 0
0 0 0 0 0
```

## 예제 출력 4

```
14
```

## 예제 입력 5

```
6 4
2 2
1 -1
-1 1
```

## 예제 출력 5

```
0
```

# 문제 해석
하루가 지날 때마다 익어있는 토마토가 익지 않은 토마토들에게 영향을 끼친다. 1이 익은 토마토이며, 0이 익지 않은 토마토이다. 익은 토마토 상, 하, 좌, 우로 하루마다 영향을 끼쳐서 익게되고 계속해서 확산된다. 며칠이 지났을 때 다 익는지 구하고 아무리 많은 일 수가 지나도 익지 않으면 -1을 출력한다.

# 풀이
**[1260번 풀이]** 참고
## 첫 번째 풀이
[맞은 풀이]
- 익어있는 토마토들의 좌표를 찾는다. (1인 토마토를 찾는다는 얘기)
- 좌표를 queue에 삽입 해준다. (start 노드 넣어준다는 얘기)
- 반복문을 들어가서 queue가 빌 때까지 돌린다.
- queue에 들어가있는 좌표를 popleft한다.
- for문을 돌려서 상, 하, 좌, 우를 검사한다.
- 만약 검사하면서 0인 노드를 발견하였으면 원래 있던 토마토 자리의 숫자에 1을 더해주고 그 토마토의 좌표를 queue에 삽입해준다. 
여기서 말하는 좌표는 세로줄이 0번지부터 시작하면서 앞에 넣어주고 뒤에 넣어주는 숫자가 가로줄이다. 밑에 그림에서 익어있는 토마토의 좌표는 (3, 5)이다.
![KakaoTalk_20220604_002649834](https://user-images.githubusercontent.com/95459089/171884587-012e10c3-52eb-4d36-8e47-37496aa71a97.jpg)
[토마토가 익어가는 과정]
![KakaoTalk_20220604_002834914](https://user-images.githubusercontent.com/95459089/171884864-9fbe79f0-3734-42ef-823c-d30cfede612f.jpg)
[queue에 좌표 삽입 과정]


    **TIP** 

    앞에서 설명한 dfs bfs 문제와는 다르게 visit라는 방문 배열을 안썻다. 방문 배열을 쓰는 대신에 직접 토마토가 익은 자리에 1씩 더해 주었다.
    
    이게 무슨 말이냐면 토마토가 1인 지점에서 상, 하, 좌, 우를 검사해서 0인 지점에 현재 토마토에 쓰여져 있는 1에다가 1을 더 더해준다는 것이다.
- 이렇게 다 돌리고 나서도 0인 토마토가 나온다면 절대 안익는다는 것이니깐 -1을 출력해주고 그게 아니라면 토마토 그래프에서 가장 큰 숫자를 출력해서 -1을 빼준다. 왜냐면 처음 과정은 1일차로 생각하지 않기 때문이다.

```python
from collections import deque

m, n = map(int, input().split())
queue = deque()
graph = []

for i in range(n):
    graph.append(list(map(int,input().split())))

for i in range(n):
    for j in range(m):
        if graph[i][j] == 1:
            queue.append([i, j])
# 위의 for문에서 graph에 입력 받은 숫자들을 다 넣어주고 
# 익어있는 토마토인 1인 숫자를 찾아서 전부 queue에 넣어준다.

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]
# 상, 하, 좌, 우를 검색하기 위한 배열이다.

def bfs():
    while queue:
        x, y = queue.popleft()
        for i in range(4): 
            # 네 방향이여서 4번 
            nx = x + dx[i]
            ny = y + dy[i]
            if nx >= 0 and nx < n and ny >= 0 and ny < m and graph[nx][ny] == 0:
                graph[nx][ny] = graph[x][y] + 1
                # 인접 노드에 자신의 숫자 + 1 을 해서 새겨준다. 
                # 0이 아니니 익은것과 동일
                queue.append([nx, ny])
                # 익게 한 토마토의 좌표를 큐에 삽입

bfs()

res = 0

for i in graph:
    for j in i:
        if j == 0:
            # graph를 전부 검사했을때, 0이 하나라도 나오면 안익은 것
            print(-1)
            exit(0)
    res = max(res, max(i))
print(res - 1)
```