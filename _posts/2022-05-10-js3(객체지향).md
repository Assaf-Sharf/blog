# 1. 생성자와 new

- 객체란 서로 연관된 변수와 함수를 그룹핑한 그릇

  - var person = { }

  - ```js
    var person = {};
    person.name = 'egoing';
    person.introduce = function(){
    	return 'my name is'+this.name;
    }
    ```

  - 객체 내 변수를 property(속성), 함수를 method(메소드)라고 부름

  - 객체를 만드는 과정을 분산하지 않고 객체를 정의할 때 값을 셋팅하도록 변경

    - ```js
      var person = {
          'name' : 'egoing',
          'introduce' : function(){
              return 'My name is '+this.name;
          }
      
      ```

- 객체를 여러 개 정의할 떄 중복이 발생할 수 있음

  - ```js
    var person1 = {
        'name' : 'egoing',
        'introduce' : function(){
            return 'My name is '+this.name;
        }
    }
     
    var person2 = {
        'name' : 'leezhe',
        'introduce' : function(){
            return 'My name is '+this.name;
        }
    }
    ```

  - person1과 person2에서 method의 중복 발생

### new와 생성자

- ```js
  function Person(){}
  var p1 = new Person();
  p1.name = 'egoing';
  p1.introduce = function(){
      return 'My name is '+this.name; 
  }
   
  var p2 = new Person();
  p2.name = 'leezche';
  p2.introduce = function(){
      return 'My name is '+this.name; 
  }
  
  ```

- var p = new Person() 이라고 하면 person()를 객체 생성자라고 부름

- 그리고 p는 비어있는 객체가 됨

- 여기서 중복을 제거하기 위해, 

  - ```js
    function Person(name){
        this.name = name;
        this.introduce = function(){
            return 'My name is '+this.name; 
        }   
    }
    var p1 = new Person('egoing');
    document.write(p1.introduce()+"<br />");
     
    var p2 = new Person('leezche');
    document.write(p2.introduce());
    ```

  - 이렇게 생성자 내에서 객체의 property를 정의하고 중복을 제거할 수 있음



# 2. this

- this는 함수 내에서 함수 호출 맥락(context)를 의미한다. 맥락이라는 것은 상황에 따라서 달라진다는 의미인데 즉 함수를 어떻게 호출하느냐에 따라서 this가 가리키는 대상이 달라진다는 뜻이다. 함수와 객체의 관계가 느슨한 자바스크립트에서 this는 이 둘을 연결시켜주는 실질적인 연결점의 역할을 한다.

### 함수호출

- 함수에서 this는 window와 같다

- ```js
  function func(){
      if(window === this){
          document.write("window === this");
      }
  }
  func(); 
  
  // output : window === this
  ```

  - func() == window.func() 이므로 !



### 메소드의 호출

- 메소드의 this는 메소드가 소속된 객체의 이름과 같다

- ```js
  var o = {
      func : function(){
          if(o === this){
              document.write("o === this");
          }
      }
  }
  o.func();   
  
  //output : o === this
  ```

  - func의 this는 o 이다



### 생성자의 호출

```js
var funcThis = null; 
 
function Func(){
    funcThis = this;
}
var o1 = Func();
if(funcThis === window){
    document.write('window <br />');
}
 
var o2 = new Func();
if(funcThis === o2){
    document.write('o2 <br />');
}
```

- Func는 o1, o2에서 함께 사용되지만, funcThis = this에서 
  - o1은 함수로 사용되므로 window를 가르키며, 
  - o2에서는 생성자이므로 o2를 가르킨다.



### apply, call

- 리터럴 : 값을 만들 때 편리하게 해주는 기능
  - 함수 리터럴 : function sum(x,y){return x+y;}
    - 원래는,
    - var sum = new Function('x', 'y', 'return x+y;');
  - 객체 리터럴 : var o = { };
  - 배열 리터럴 : var a = [1, 2, 3];
    - 원래는,
    - var a = new Array(1, 2, 3)

- 함수의 메소드인 apply, call을 이용하면 this의 값을 제어할 수 있다. 

  - ```js
    var o = {}
    var p = {}
    function func(){
        switch(this){
            case o:
                document.write('o<br />');
                break;
            case p:
                document.write('p<br />');
                break;
            case window:
                document.write('window<br />');
                break;          
        }
    }
    func();
    func.apply(o);
    func.apply(p);
    
    //output : window, o, p
    ```

  - 함수(메소드)도 객체이기도 하지만, 호출하는 방법에 따라 관계가 달라지기도 함 



# 3. 상속

- 자신의 맥락에 맞게 부모의 로직을 수정하고 변경하여서 객체를 생성

- ```js
  function Person(name){
      this.name = name;
  }
  Person.prototype.name=null;
  Person.prototype.introduce = function(){
      return 'My name is '+this.name; 
  }
   // 객체 person() 생성
  
  function Programmer(name){
      this.name = name;
  }
  Programmer.prototype = new Person();
  //programmer의 특수한 속성인 'prototype'에 Person 생성자를 만듦
  // --> 그렇게 되면 Programmer에도 introduce 메소드가 생김
  var p1 = new Programmer('egoing');
  document.write(p1.introduce()+"<br />");
  ```

- 핵심 역할 : prototype! 
  - ex) `Programmer.prototype = new Person();` 으로 상속

### 상속 기능의 추가

```js
function Person(name){
    this.name = name;
}
Person.prototype.name=null;
Person.prototype.introduce = function(){
    return 'My name is '+this.name; 
}
 
function Programmer(name){
    this.name = name;
}
Programmer.prototype = new Person();
Programmer.prototype.coding = function(){
    return "hello world";
}
 // Programmer 객체에 coding 메소드를 추가

var p1 = new Programmer('egoing');
document.write(p1.introduce()+"<br />");
document.write(p1.coding()+"<br />");
```



# 4. 프로토타입(prototype)

```js
function Ultra(){}
Ultra.prototype.ultraProp = true;
 
function Super(){}
Super.prototype = new Ultra();
 
function Sub(){}
Sub.prototype = new Super();
 
var o = new Sub();
console.log(o.ultraProp);

//output : true
```

- prototype에 객체의 원형이 저장되어 있음
- new를 통해서 생성자를 호출하게 되면 js는 생성자 함수의 prototype에 저장되어 있는 객체를 꺼내서 return하게 됨
  - 따라서 상속을 하려면 객체 리터럴을 사용하면 안됨
- o.ultraProp 를 찾는 순서
  - 객체 o -> sub(){} -> Super(){} -> Ultra(){} 순으로 찾음 
- `Sub.prototype = new Super();` 처럼 "자식.prototype = new 부모 생성자" 형식으로 만들어야 함
  - Sub.prototype = Super.prototype 으로 하면 동작은 잘 되나,
  - Sub에서 변경한 내용이 Super에도 영향을 줌(자식이 부모에게 영향)



# 5. 표준 내장 개체의 확장

- 표준 내장 객체(Standard Built-in Object)는 자바스크립트가 기본적으로 가지고 있는 객체들을 의미
- 자바스크립트는 아래와 같은 내장 객체를 가지고 있다. 
  - Object
  - Function
  - Array
  - String
  - Boolean
  - Number
  - Math
  - Date
  - RegExp

### 배열을 확장

- ```js
  var arr = new Array('seoul','new york','ladarkh','pusan', 'Tsukuba');
  // arr 중 특정 값을 ramdom하게 추출 
  
  function getRandomValueFromArray(haystack){
      var index = Math.floor(haystack.length*Math.random());
      return haystack[index]; 
  }
  console.log(getRandomValueFromArray(arr));
  ```

  - 랜덤한 값은 Math.random() 을 사용
    - 0 ~ 1 사이의 소수를 제공

  - 소수를 정수를 만들기 위해 Math.floor(n)을 사용
    - 소수 n의 내림값 제공

- prototype에 rand 메소드를 정의하여 배열을 확장!

  - ```js
    Array.prototype.rand = function(){
        var index = Math.floor(this.length*Math.random());
        return this[index];
    }
    
    var arr = new Array('seoul','new york','ladarkh','pusan', 'Tsukuba');
    console.log(arr.rand());
    //output : arr 중 랜덤한 값
    ```

    - 여기서 this는 배열 객체인 arr이 됨

- 이처럼 공통된 속성이나 메소드가 있으면 임의로 정의해주면 됨



# 6. object

- Object 객체는 객체의 가장 기본적인 형태를 가지고 있는 객체
- object의 prototype은 모든 개체들의 prototype(원형)임
- Object.prototype.~ 는 모든 객체가 가지고 있음
  - ex) arr.toString()

### object의 확장

- contain 메소드를 통해 특정 value을 가지고 있는지 확인

  - ```js
    // Object.prototype.contain 을 통해 확장
    Object.prototype.contain = function(needle) {
        for(var name in this){
            if(this[name] === needle){
                return true;
            }
        }
        return false;
    }
    var o = {'name':'egoing', 'city':'seoul'}
    console.log(o.contain('egoing'));
    var a = ['egoing','leezche','grapittie'];
    console.log(a.contain('leezche'));
    
    // output : true, true
    ```

### object 확장의 위험

- 모든 객체에 영향을 줄 수 있음

  - var o 도 객체이기 때문에 contain 메소드가 포함됨

    - ```js
      console.log(o)
      //output : object{'name':'egoing', 'city':'seoul', contain: function}
      
      for(var name in o){
          console.log(name);
      }
      //output : name, city, contain
      
      for(var name in a){
          if(a.hasOwnProperty){
      		console.log(name);
          }
      //output : egoing, leezche, grapittie
      ```

    - a.hasOwnProperty(객체의 직접적으로 정의되어 있는지 확인)를 통해 일부 문제 해결가능 --> 상속과 직접정의된 속성을 구분 가능

      

# 7. 데이터 타입

- 원시 데이터 타입(기본 데이터 타입)
  - 숫자
  - 문자열
  - 불리언(true/false)
  - null
  - undefined
- 객체 데이터 타입(참조 데이터 타입)
  - 원시 데이터 타입이 아닌 모든 타입

### 레퍼객체

- 래퍼(wrapper) 객체란, 원시데이터 타입을 감싸는 객체

- 문자열은 원시 데이터 타입이나, 객체로 사용할 때 임시로 객체로 만든다.

- ```js
  var str = 'coding';
  console.log(str.length);        // 6
  console.log(str.charAt(0));     // "C"
  ```

  - str = new String('coding')을 임시로 생성 
  - 사용이 끝나면 원래 데이터 타입(원시 데이터 타입) 으로 변경

- 래페객체의 종류는,

  - 숫자 -> Number / 문자열 -> String / 불리언 -> Boolean



# 8. 참조

### 복제

- 변수에 담긴 값이 원시 데이터 타입(string, number, boolean, null, undefined) 일 때

```js
var a = 1;
var b = a;
b = 2;
console.log(a); // 1
```

![img](../images/2022-05-10-js3(객체지향)/2226.png)

### 참조

- 변수가 객체일 때 발생

```js
var a = {'id':1};
var b = a;
b.id = 2;
console.log(a.id);  // 2
```

- a, b에 담긴 값을 바꾸면 다른 변수의 값이 바뀜

![img](../images/2022-05-10-js3(객체지향)/2227.png)

- 새로운 객체를 만들어 할당하면 a와 b의 참조는 없어짐

  - ```js
    var a = {'id':1};
    var b = a;
    b = {'id':2}
    console.log(a.id);  // 1
    ```

    

### 함수와 참조

- 원시 데이터 타입을 인자로 넘겼을 때의 동작 모습

  - ```js
    var a = 1;
    function func(b){
        b = 2;
    }
    func(a);
    console.log(a); // 1
    ```

-  참조 데이터 타입을 인자로 넘겼을 때 동작하는 장면

  - 참조가 바뀔 때

    - ```js
      var a = {'id':1};
      function func(b){
          b = {'id':2};
      }
      func(a);
      console.log(a.id);  // 1
      ```

    - ```js
      // 위 코드는 아래와 같다
      var a = {'id':1}
      b = a
      b = {'id':2}
      console.log(a.id) // 1
      ```

  - 참조가 연결됐을 때

    - ```js
      var a = {'id':1};
      function func(b){
          b.id = 2;
      }
      func(a);
      console.log(a.id);  // 2
      ```

      

