---
layout: single
title:  "04 DFS, BFS, 백트래킹 개념정리"
---
**DFS, BFS 백트래킹 (p67 ~ 92)**

DFS, BFS, 백트래킹을 풀기 위해서는 그래프와 트리에 대해 알아야 된다.

그래프 (Graph)
- 그래프= 노드 (Node, Vertex) + 간선 (Edge)


-그래프의 방향성
1.방향 그래프: 방향성 O 
2. 무방향 그래프: 방향성 X (=양방향 그래프: 방향성이 없다는 건 어느 쪽으로도 갈 수 있다는 의미!)

-그래프의 순환성
1.순환 그래프 (Cyclic): 순환하는 부분이 한 군데만 있어도 순환 그래프
2.비순환 그래프 (Acyclic)

cf. 방향성 비순환 그래프 = DAG (Directed Acyclic Graph)
-git 같은 버전 관리 시스템 (Version Control System)의 브랜치는 주로 DAG로 이루어짐
why? commit 기록은 시간이 지나며 쌓임 > 시간은 한 방향으로만 흐름 + 다시 돌아갈 수  X > 사이클 X

-그래프의 연결 요소

트리 (Tree)
-순환성 X, 무방향 그래프 

-Leaf node, root

-노드 A에서 노드 B로 가는 경로는 반드시 존재 + 유일
-노드 개수 = 간선 개수 + 1

-이때! 계층이 있는 트리도 사용  
-> 루트 노드 1개 + 부모-자식 관계 존재 (상위 노드: 부모/ 하위 노드: 자식)

그래프를 코드로 나타내는 방법
1.인접 행렬 (Adjacency Matrix)
2.인접 리스트 (Adjacency List)

DFS (Depth First Search)
-’깊이 우선 탐색’
-그래프 탐색 알고리즘 중 하나
-어떤 노드에서 시작 > 답을 찾을 때까지 갈 수 있는 인접 노드가 존재한다면 그 노드로 탐색 반복 (계속해서 깊게 파고 내려가는 형태) > if. 더 이상 진행할 인접 노드 X > 올라와서 또 다시 다른 인접 노드로 탐색 진행

-스택/ 재귀함수로 구현 (일반적으로 더 편한 재귀 함수 사용)

BFS (Breadth First Search)
-’너비 우선 탐색’
-그래프 탐색 알고리즘 중 하나
-!DFS와 탐색 순서 차이 존재!
-현재 노드에서 모든 인접 노드 탐색 > 아래 계층으로 내려감 
-최단거리 구할 때 good
-큐로 구현 

DFS VS BFS
-DFS, BFS 모두 완전 탐색 알고리즘
-둘 다 최단거리 구할 수 있음  (but 최단거리 탐색을 해야 할 경우, BFS 사용)

시간복잡도
-인접 행렬/ 인접 리스트를 썼을 때 다름
-정점 개수: V / 간선 개수: E
-DFS, BFS 시간 복잡도는 
인접행렬: O(V^2)
인접리스트: O(V+E)

cf. 
인접행렬: 행렬의 모든 칸을 살펴서 V^2
인접리스트:
간선 개수가 적고 노드 개수가 더 많다면 O(V)에 근접
간선 개수가 매우 많다면 O(E)에 근접 
