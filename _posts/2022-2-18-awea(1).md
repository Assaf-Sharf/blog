---
layout: single
title: "알고리즘 - SWEA 숫자카드, 구간합 "
categories: 알고리즘
tag: [python, 문제, blog, github, 파이썬, 알고리즘, 공부, algorithm, 기본, 기초, 구간합, 숫자카드, 멀티캠퍼스, swea, sw acdemy]
toc: true
sidebar:
  nav: "docs"
---
## SWEA - LIST_1

[문제 출처 : SW Expert Academy](https://swexpertacademy.com/main/learn/course/subjectDetail.do?courseId=AVuPDN86AAXw5UW6&subjectId=AWOVFCzaqeUDFAWg&&#)

### 숫자카드

1. 인덱스 활용하여 카운트 리스트 만들고 활용
2. 요소 값 0 인 길이 10의 리스트 생성에서 숫자에 해당하는 인덱스 +1 씩 해주기


```python
# 테스트케이스 
T = int(input())

# T 만큼의 반복
for i in range(1, T+1):
    # 숫자의 갯수와 숫자입력
    n = int(input())
    nums = input()
    
    # 인덱스가 0~9 까지의 카운트리스트 만듦
    cnt_list = [0]*10
    
    # 인덱스 성질을 활용하여 cnt_list 값 채움 
    for num in nums:
        cnt_list[int(num)] += 1
    
    # 비교를 위한 변수 설정
    max_idx = 0  # 가장 많이 반복된 숫자값
    max_num = cnt_list[0]  # cnt_list 에서 가장 큰 값
  
    for j in range(1, len(cnt_list)):
        if cnt_list[j] >= max_num:
            max_num = cnt_list[j]
            max_idx=j
                   
    print(f'#{i} {max_idx} {max_num}')
```

     1
     5
     49679


    #1 9 2


### 구간합

1. 리스트 인덱싱 활용하여 각 구간합 구하기 sum(nums[i:i+m])
2. max, min 함수 활용


```python
# T 만큼 반복
for tc in range(1, int(input())+1):
    n, m = map(int, input().split()) # 정수(n) & 구간(m)의 갯수
    nums = list(map(int, input().split())) # 구간리스트 입력 (nums)
    
    range_sum =[] # 구간합 리스트
    # n-m+1 만큼 반복하며 구간합 (n-m=0이어도 1회 진행하므로 +1)
    for i in range(n-m+1):
        range_sum.append(sum(nums[i:i+m])) # i 기준 +m 까지의 구간합
    
    print(f'#{tc} {max(range_sum)-min(range_sum)}')
```

     1
     10 3
     1 2 3 4 5 6 7 8 9 10


    #3 18

