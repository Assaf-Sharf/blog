---
layout: single
title: "[TDD] TDD 개념 정리"
date: "2022-01-01 16:00:05"
categories: TDD
tag: [TDD, Junit, Test]
toc: true
author_profile: true
sidebar:
  nav: "docs"
---

## ✔ 서론

> `TDD`는 방대한 양을 가지고 있기 때문에 아래 설명만으로는 부족한 감이 있다  
> 이번 장에서는 전체적인 TDD의 흐름과 JUnit 5 사용 방법에 대한 부분을 간략히 정리한다

## [TDD가 왜 필요한가?](https://brunch.co.kr/@freeism/19)

**TDD의 필요성은 다른 분께서 정리를 해두신 내용을 발췌 하여 작성했습니다**

- 💣 **실패하는 테스트**를 만들고, 그 **테스트가 통과**하는 제품을 만들면 결국은 원하는 기능이 동작하게 되는 개발 방법론
- 👍 개발자가 의도한대로 로직이 동작하는지 명확하게 알 수 있고, **로직에 대해 보증**할 수 있다
- 🛡 사전에 다양한 케이스를 고려해봄으로써 문제가 될 수 있는 잠재적 오류들을 방어할 수 있다
- 🤭 아키텍처 및 로직이 깔끔해진다, **테스트가 어려운 코드는 좋은 코드가 아니다**
- 👀 다른 사람이 로직을 수정한 경우 로직의 변경에 대한 영향도(Side-Effect)가 명확하게 보인다

## TDD (Test-Driven-Development)

> 요구사항 정의 > 도메인 파악 및 구조 설계 > .. 순으로 가는 것 같다

- `테스트 주도 개발`이라는 의미
- 단순하게 표현하자면 `테스트 코드를 먼저 설계 및 구축 후` 테스트를 통과할 수 잇는 코드를 짜는 것
- 코드 작성 후 테스트를 진행하는 지금까지 사용 된 일반적인 방식과 다소 차이가 있다

### 애자일 개발 방식 중 하나

> 애자일 방법론은 추후 따로 포스팅을 할 예정이다

- 코드 설계시 원하는 `단계적 목표`를 설정하여 진행하고자 하는 것에 대한 `결정 방향의 갭`을 줄이고자 함
- 최초 목표에 맞춘 테스트를 구축하여 그에 맞게 코드를 설계하기 때문에 보다 적은 의견 충돌을 기대할 수 있음

## 테스트 코드의 작성 목적

- `코드의 안정성`을 높일 수 있다
- 기능 `추가` 및 `변경` 중 일어나는 `Side-Effect` 미연에 방지
- 해당 코드가 작성된 목적을 명확하게 표현할 수 있다
  - 코드에 불필요한 내용이 들어가는 것을 비교적 줄일 수 있다

## JUnit?

### Java 진영의 대표적인 Test Framework

- 단위 테스트(JUnit Test)를 위한 도구를 제공
  - 단위 테스트란?
    - 코드의 특정 모듈이 의도된 대로 동작하는지 테스트 하는 절차
    - 모든 함수와 메서드에 대한 각각의 `테스트 케이스`(Test Case)를 작성하는 것
  - 어노테이션(Annotation)을 기반으로 테스트를 지원
  - 단정문(Assert)으로 테스트 케이스의 기대값에 대해 수행 결과를 확인할 수 있음
  - Spring Boot 2.2버전부터 JUnit 5 버전 사용
  - `JUnit 5`는 크게 `Platform`, `Jupiter`, `Vintage`(JUnit 4 호환) 모듈로 구성

## JUnit Module?

<img width="620" alt="junit5" src="https://user-images.githubusercontent.com/53969142/145025982-33005e67-1652-4f18-80f9-deb7483dc6cc.png">

> 출처: https://medium.com/techwasti/junit5-tutorial-part-1-24471afdd68f

### JUnit5

> JUnit5 에서는 자바 메인 메서드 없이도 JUnit Platform 에서 테스트 코드를 실행하여  
> @Test 어노테이션이 선언된 테스트 코드를 실행시킬 수 있다

- JUnit5 : `모듈화` 되어 있는 구조.
- 모듈화 구조 : `JUnit Platform`을 기반으로 위에 구현체인 `Jupiter`와 `Vintage` 모듈을 올려놓은 구조
  - 상위 모듈 : JUnit Platform, 하위 모듈 : Jupiter, Vintage
- Java로 테스트 할 수 있는 단위 테스트 F/W

### JUnit Platform

- `JUnit 테스트 코드를 실행 시켜주는 런처 역할을 제공하는 모듈`
- 테스트를 `발견`하고 테스트 `계획`을 생성하는 `TestEngine Interface`를 가지고 있음
- 런처
  - 개발 툴
  - 자바 메서드에서 JUnit5 실행하는 것이 가능

### JUnit Jupiter

- `JUnit 5 TestEngine 구현체`
- JUnit 5기반 테스트 케이스 작성을 위한 `프로그래밍 모델, 확장 모델을 지원하는 모듈`
- Jupier 기반으로 작성된 테스트 코드를 Junit Platform에서 실행시키기 위한 `테스트 엔진`을 제공하는 모듈
- Spring Boot 의존성 없이 JUnit 의존성만으로 자바에서 JUnit5 사용 가능

### JUnit Vintage

- `JUnit 3.4 TestEngine 구현체`
- 기존 JUnit 3.4 버전 기반으로 작성된 테스트 코드를 Platform 에서 실행하기 위해 사용

## JUnit LifeCycle Annotaion

JUnit 5는 아래와 같은 테스트 라이프 사이클이 존재한다

| Annotation      | Desc                                                              |
| --------------- | ----------------------------------------------------------------- |
| **@Test**       | 테스트용 메서드를 표현하는 어노테이션                             |
| **@BeforeEach** | 각 테스트 메서드가 시작되기 전에 실행되어야 하는 메서드를 표현    |
| **@AfterEach**  | 각 테스트 메서드가 시작된 후 실행되어야 하는 메서드를 표현        |
| **@BeforeAll**  | 테스트 시작 전에 실행되어야 하는 메서드를 표현 (static 처리 필요) |
| **@AfterAll**   | 테스트 종료 후에 실행되어야 하는 메서드를 표현 (static 처리 필요) |

## JUnit Main Annotaion

### @SpringBootTest

- **통합 테스트 용도**
  - 여러 기능을 조합하여 전체 비즈니스 로직이 제대로 동작하는지 확인하는 것을 의미
  - `매번 무거운 작업이 수행이 된다`
- @SpringBootApplication을 찾아가 하위의 모든 Bean을 스캔하여 로드함
- 그 후 Test용 Application Context를 만들어 Bean을 추가하고, MockBean을 찾아 교체

### @ExtendWith

```java
@ExtendWith(SpringExtension.class)
```

- JUnit 4에서 **@RunWith**로 사용되던 어노테이션이 **@ExtendWith**로 변경됨
- **@ExtendWith**는 메인으로 실행될 Class를 지정할 수 있음
- **@SpringBootTest**는 기본적으로 **@ExtendWith**가 추가되어 있음

### @WebMvcTest(클래스명.class)

```java
@WebMvcTest(controllers = UserAPI.class)
```

- (클래스명.class)에 작성된 클래스만 실제로 로드하여 테스트를 진행할 경우 사용
- `매개 변수를 지정하지 않으면 @Controller, @RestController, @RestControllerAdvice 등 컨트롤러와 연관된 모든 Bean이 로드된다`
- 스프링의 모든 Bean을 로드하는 @SpringBootTest 대신 컨트롤러 관련 코드만 테스트할 경우 사용

### @Autowired about @Mockbean

```java
@AutoWired
private MockMvc mvc; //MockMvc는 실제 객체가 아닌 가상 객체
```

```java
String bNo = "1";
        mockMvc.perform(
            get("/api/board/{bNo}", bNo))
            .andDo(print())
            .andExpect(status().isOk());
```

- `Controller의 API를 테스트`하는 용도인 `MockMvc 객체`를 주입 받음
- perform() 메서드를 활용하여 컨트롤러의 동작을 확인할 수 있음
- .andExpect(), andDo(), andReturn() 등의 메서드를 같이 활용함

### @MockBean

```java
@MockBean
private BoardService boardService;
```

- 테스트할 클래스에서 주입 받고 있는 `가짜 객체`를 생성하는 어노테이션
- 🚀 `해당 객체는 실제 행위를 하지 않음`
  - 위 같은 이유로 인해 비즈니스 로직이 이어지지 않는 경우가 존재
- `given()`을 활용하여 가짜 객체의 동작에 대해 정의하여 사용할 수 있음

### @AutoConfigureMockMvc

- spring.test.mockmvc의 설정을 로드하면서 MockMvc의 의존성을 자동으로 주입.
- MockMvc 클래스는 REST API 테스트를 할 수 있는 클래스.

## 🌈 단위 테스트

```gradle
testImplementation 'org.springframework.boot:spring-boot-starter-test'
```

> 단위 테스트는 프로젝트에 필요한 모든 기능에 대한 테스트를 각각 진행하는 것을 의미.  
> 일반적으로 스프링 부트 -> spring-starter-test 디펜던시만으로 의존성을 모두 가질 수 있음.

### F.I.R.S.T 원칙

- **Fast**: 테스트 코드의 실행은 빠르게 진행 되어야함
- **Independent**: 독립적인 테스트가 가능해야함 (각각의 메서드는 각각 테스트가 가능)
- **Repeatable**: 테스트는 매번 같은 결과를 만들어야 함 (똑같은 Input & Output)
- **Self-Validating**: 테스트는 그 자체로 실행하여 결과를 확인할 수 있어야함
- **Timely**: 단위 테스트는 비즈니스 코드가 완성되기 전에 구성하고 테스트가 가능해야함

## 참고 자료

- [TDD JUnit 5](https://www.youtube.com/watch?v=SFVWo0Z5Ppo)
- [JUnit 5 공식 사이트](https://junit.org/junit5/docs/current/user-guide/)
- [JUnit 5 모듈 구조](https://wjjeong.tistory.com/53)
