---
layout: single
title: "programmers / brutal force / 소수찾기 "
toc: true
categories: study
tag : [algorithm]
---


[문제 링크](https://programmers.co.kr/learn/courses/30/lessons/42839?language=python3)

```python
from itertools import permutations

def is_prime_number(n):
    if n==0 or n==1:                              
        return False
    else:
        for i in range(2, int(n**0.5) + 1): 
            if n % i == 0:                        
                return False
        
        return True                               

def solution(numbers):
    answer = []
    for i in range(1, len(numbers)+1):              
        number = list(permutations(numbers, i))    
        for j in range(len(number)):    
            num = int("".join(map(str,number[j])))
            if is_prime_number(num):                
                answer.append(num)  
    
    answer = list(set(answer))  
    return len(answer)

```

소수찾기 함수)

소수찾기는 간단하게 2부터 시작하는 것이기 때문에 0또는 1일경우 거짓이고

소수의 특성상 그 제곱이하에서 2부터 하나씩 체크해서 나머지가 없는 수가 생길수 있다면,

그것은 소수가 아니기때문에 거짓을 반환한다. 

그리고 약수의 특성상 무조건 대상되는 수의 제곱근의 범위에 존재하기때문에 제곱근까지의 범위에 무조건 포함될수있도록 범위를 정수로 캐스팅(제곱근 범위)+1로 정해준다..

솔루션 함수)

모든 경우의 수를 추출하기위해 순열을 사용하면서, 뽑는 갯수의 전수를 찾기위해

i를 for문에 포함시킨다. 그다음 첫 예제중 나오는 경우의 수중 하나가 [1,7]이었으면  [1,7]

두개를 map 함수를 사용해서 str로 전환시켜서 join으로 붙이고, 그것을 다시 정수로 전환한다.


만약 거기서 소수로 되어있는 수가 존재한다면 정답 배열에 추가한다. 110과 011이 겹쳐서

소수가 하나가 더 추가된다면 중복을 삭제해줘야 한다. 따라서 set이 사용되었다.

정답배열은 완성되었고 그다음은 정답의 갯수를 구하는 것이 목적이기 때문에 len()을 사용하여 정답을 출력한다.


