/*
 *
 * Tinder APP 만들기. (Firebase 인증, 페이스북 로그인, 리얼타임 데이터베이스, ~)
 * aop-part3-chapter05(Tinder 앱)
 * 사용된 기술 : Firebase Auth, Realtime Database, Facebook Login(여기선 제외), Swipe Animation
 * 개인적인 중요도 : ★★★★ / 난이도 : ★★★★★(갠적으로 어려움) → 연습하자!!! 
*/

※ 틴더 앱 만드는 방법
 - 1. FireBase 프로젝트 생성 및 안드로이드 기본 설정
 - 2. Auth 인증 등록 및 회원가입/로그인 방법
 - 3. FireBase RealTime Database 설정 및 초기사용 방법
 - 4. Swipe Animation (Git) 사용법
 - 5. 리얼타임 데이터베이스에서 유저 정보 가져와서 Swipe Animation에 추가하기
 - 6. Like & DisLike animation 및 Matched List 표현
 - 7. 로그아웃 기능 구현

[1]. FireBase 프로젝트 생성 및 안드로이드 기본 설정
1) 파이어 베이스 접속(https://console.firebase.google.com/?hl=ko)
2) + 프로젝트 추가 클릭
3) 프로젝트 이름 추가 : tinder-app → 계속 → 계정선택 → 프로젝트 만들기

============================== 프로젝트 생성 완료 ==============================
4) 앱에 파이어베이스를 추가하기에서 안드로이드 클릭(동그라미 모양)
5) Android 패키지 이름 등록 → 프로젝트의 Manifest.xml 클릭 → package 복사 → 파이어베이스 사이트에 등록 → 앱 등록
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.aop_part3_chapter05_tinder">

6) 구성파일 다운로드 (google-services.json) → 안드로이드 패키지로 옮기기(프로젝트 구조 android → project 로 전환) → app 폴더 밑에 다운로드 파일 붙여넣기
7) Firebase Gradle 추가하기
 - build.gradle(Project)
 buildscript → dependencies → classpath 'com.google.gms:google-services:4.3.10' 추가하기

[EX화면]
 buildscript {
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath "com.android.tools.build:gradle:7.0.3"
        classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.20"
        classpath 'com.google.gms:google-services:4.3.10' //tinder firebase
        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

 - build.gradle(Module)
 plugins → id 'com.google.gms.google-services' 추가
[EX화면]
 plugins {
    id 'com.android.application'
    id 'kotlin-android'
    id 'com.google.gms.google-services' //tiner firebase 설정
 }
 
 dependencies → 아래 tiner 리스트 추가하기(애널리스트, 인증, 데이터베이스, 페이스북 로그인)

dependencies {

    implementation 'androidx.core:core-ktx:1.7.0'
    implementation 'androidx.appcompat:appcompat:1.4.0'
    implementation 'com.google.android.material:material:1.4.0'
    implementation 'androidx.constraintlayout:constraintlayout:2.1.2'
    testImplementation 'junit:junit:4.+'
    androidTestImplementation 'androidx.test.ext:junit:1.1.3'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.4.0'

    //tiner firebase 설정(여기 추가)
    implementation platform('com.google.firebase:firebase-bom:29.0.1')
    implementation 'com.google.firebase:firebase-analytics'
    implementation 'com.google.firebase:firebase-auth-ktx'
    implementation 'com.google.firebase:firebase-database-ktx'

    implementation 'com.facebook.android:facebook-login:8.2.0'

    //tiner swipe
    implementation "com.yuyakaido.android:card-stack-view:2.3.4"

}

8) 파이어베이스 콘솔로 이동
============================== 안드로이드 기본설정 완료 ==============================

[2]. Auth 인증 등록 및 회원가입/로그인 방법
1) 파이어베이스 콘솔화면 → Authentication → 시작하기 → 기본 제공업체 [이메일/비밀번호] → 이메일/비밀번호 사용만 설정 체크(이메일 링크 설정X) → 저장  
2) 안드로이드 MainActivity 작성
 private val auth : FirebaseAuth = Firebase Auth.getInstance() ← 전역변수로 추가

 auth.currentUser() 를 통해서 현재 로그인이 되어있는지 여부확인 가능. 로그인이 안되어 있으면 null 반환

[EX화면]
class MainActivity : AppCompatActivity() {

    private val auth : FirebaseAuth = FirebaseAuth.getInstance()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        println("==============")
        println(auth)
    }

    override fun onStart(){
        super.onStart()
        println("현재 로그인 계정 : ${auth.currentUser}")
        if(auth.currentUser == null){
            println("로그인이 안되어 있으니 Login Activity로 이동")
        }else {
            println("로그인이 되었으니 틴더페이지로 이동")
        }
    }
}

3) LoginActivity와 activity_login 작성
- activity_login 작성
email , password 등 위젯 추가(+로티 애니메이션)

- LoginActivity 작성

 (1) private val auth : FirebaseAuth = FirebaseAuth.getInstance() 추가

 (2) initButtons 추가

 (3) join 방법(auth.createUserWithEmailAndPassword(email, pasword) 사용)

 auth.createUserWithEmailAndPassword(email, pasword)
    .addOnCompleteListener(this) { task ->
        if(task.isSuccessful){
            println("로그인 성공")
        }else{
            println("로그인 실패
            ")
        }
    }

 (4) 로그인 방법(auth.signInWithEmailAndPassword(email, pasword) 사용)

 auth.signInWithEmailAndPassword(email, password)
    .addOnCompleteListener(this){ task ->
        if(task.isSuccessful){
            println("로그인 성공")
            //handleSuccessLogin()
        }else{
            Toast.makeText(this, "로그인 실패했습니다.", Toast.LENGTH_SHORT).show()
        }
    }

 (5) editText 버튼 활성화 조작 추가
 emailEditText.addTextChangedListener {
            val enable = emailEditText.text.isNotEmpty() && passwordEditText.text.isNotEmpty()
            loginButton.isEnabled = enable
            joinButton.isEnabled = enable
        }

 (6) handleSuccessLogin() 작성 [리얼데이터베이스 선작업 필요.. 바로 아래 참조]
 private fun handleSuccessLogin(){
    if(auth.currentUser == null){
        Toast.makeText(this, "로그인에 실패했습니다.", Toast.LENGTH_SHORT).show()
        return
    }

    val userId = auth.currentUser?.uid.orEmpty()
    val currentUserDB = Firebase.database.reference.child("Users").child(userId)
    val user = mutableMapOf<String, Any>()
    user["userId"] = userId
    currentUserDB.updateChildren(user)

    finish()

 }

[EX화면]
class LoginActivity : AppCompatActivity() {

    private val auth : FirebaseAuth = FirebaseAuth.getInstance()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContentView(R.layout.activity_login)

        initJoinButton()
        initLoginButton()
        initEmailAndPasswordEditText()

    }

    private fun initJoinButton(){
        val joinButton = findViewById<Button>(R.id.joinButton)
        joinButton.setOnClickListener {
            val email = getInputEmail()
            val password = getInputPassword()
            auth.createUserWithEmailAndPassword(email, password)
                .addOnCompleteListener(this) { task ->
                    if(task.isSuccessful){
                        Toast.makeText(this, "회원가입에 성공했습니다. 로그인 버튼을 눌러 로그인해주세요.", Toast.LENGTH_SHORT).show()
                    }else{
                        Toast.makeText(this, "이미 가입한 이메일이거나 회원가입에 실패했습니다.", Toast.LENGTH_SHORT).show()
                    }
                }
        }
    }

    private fun initLoginButton(){
        val loginButton = findViewById<Button>(R.id.loginButton)
        loginButton.setOnClickListener {
            val email = getInputEmail()
            val password = getInputPassword()

            auth.signInWithEmailAndPassword(email, password)
                .addOnCompleteListener(this){ task ->
                    if(task.isSuccessful){
                        println("로그인 성공")
                        //handleSuccessLogin()
                    }else{
                        Toast.makeText(this, "로그인 실패했습니다.", Toast.LENGTH_SHORT).show()
                    }
                }
        }
    }

    private fun handleSuccessLogin(){
        if(auth.currentUser == null){
            Toast.makeText(this, "로그인에 실패했습니다.", Toast.LENGTH_SHORT).show()
            return
        }

        val userId = auth.currentUser?.uid.orEmpty()

        //리얼타임 데이터베이스 가져오기
        val currentUserDB = Firebase.database.reference.child("Users").child(userId)
        val user = mutableMapOf<String, Any>()
        user["userId"] = userId
        currentUserDB.updateChildren(user)

        finish()

    }

    private fun initEmailAndPasswordEditText(){
        val emailEditText = findViewById<EditText>(R.id.EmailEditText)
        val passwordEditText = findViewById<EditText>(R.id.PasswordEditText)
        val loginButton = findViewById<Button>(R.id.loginButton)
        val joinButton = findViewById<Button>(R.id.joinButton)

        emailEditText.addTextChangedListener {
            val enable = emailEditText.text.isNotEmpty() && passwordEditText.text.isNotEmpty()
            loginButton.isEnabled = enable
            joinButton.isEnabled = enable
        }

        passwordEditText.addTextChangedListener {
            val enable = emailEditText.text.isNotEmpty() && passwordEditText.text.isNotEmpty()
            loginButton.isEnabled = enable
            joinButton.isEnabled = enable
        }

    }

    private fun getInputEmail() : String = findViewById<EditText>(R.id.EmailEditText).text.toString()
    private fun getInputPassword() : String = findViewById<EditText>(R.id.PasswordEditText).text.toString()
}


[3]. FireBase RealTime Database 설정 및 초기사용 방법
파이어베이스 콘솔화면 → 데이터베이스 만들기 → 위치(미국) 설정 → 테스트 모드에서 시작 → 리얼타임 데이터베이스 생성 완료

-DBKey.kt 작성 → 상수값들 저장해서 오타 안나게 하기 위함[굳이 사용없이 직접 입력해도 OK]
class DBKey {
    companion object{
        const val USERS = "Users"
        const val LIKED_BY = "likedBy"
        const val LIKE = "like"
        const val DIS_LIKE = "dislike"
        const val USER_ID = "userId"
        const val NAME = "name"
    }
}

-LikeActivity 작성
    //인증 전역변수
    private val auth : FirebaseAuth = FirebaseAuth.getInstance()
    //리얼타임 데이터베이스 전역변수
    private lateinit var userDB : DatabaseReference //리얼타임 데이터베이스 타입은 DatabaseReference

    userDB = Firebase.database.reference.child(USERS) //이 부분 리얼타임 데이터베이스중 최상단인 "Users" 가져오는 구문. 위에 로그인 부분에서 Users등록 부분 만들었음

    //로그인한 User의 DB 가져오기
    val currentUserDB = userDB.child(getCurrentUserID())

    //로그인한 User의 ID 가져오기
    private fun getCurrentUserID() : String{
        if(auth.currentUser == null){
            Toast.makeText(this, "로그인이 되어있지 않습니다.", Toast.LENGTH_SHORT).show()
            finish()
        }
        return auth.currentUser?.uid.orEmpty()
    }

    //DB를 가져올때 하는 작업. 이름이 없는 경우에만 showNameInfoPopup() 호출해서 이름 저장하기 위함
    currentUserDB.addListenerForSingleValueEvent(object : ValueEventListener {
        override fun onDataChange(snapshot: DataSnapshot) {
            if (snapshot.child(NAME).value == null) {
                showNameInfoPopup()
                return
            }
        }
        override fun onCancelled(error: DatabaseError) { }
    })

    //showNameInfoPopup() 작성
    private fun showNameInfoPopup(){
        val editText = EditText(this)

        AlertDialog.Builder(this)
            .setTitle("이름을 입력해주세요")
            .setView(editText)
            .setPositiveButton("저장"){_,_ ->
                if(editText.text.isEmpty()){
                    showNameInfoPopup()
                }else{
                    saveUserName(editText.text.toString())
                }
            }
            .setCancelable(false)
            .show()
    }

    //saveUserName() 작성
    private fun saveUserName(name : String){
        val userId = getCurrentUserID()
        val currentUserDB = userDB.child(getCurrentUserID())
        val user = mutableMapOf<String, Any>()
        user[USER_ID] = userId
        user[NAME] = name
        //리얼타임 디비에 유저 이름 등록해주는 걸로 업데이
        currentUserDB.updateChildren(user)
    }

============================== 계정로그인 후 이름정보까지 파이어베이스 등록 완료 ==============================   

[4]. Swipe Animation (Git) 사용법

GitHub 사이트 접속(https://github.com/yuyakaido/CardStackView) → Installation 부분 확인 → 상단 Releases 최신버전 확인 → v2.3.4
 → build.gradle(Module)에 추가 → 사이트에서 사용법 학습

dependencies {
    //implementation "com.yuyakaido.android:card-stack-view:${LatestVersion}"
    implementation "com.yuyakaido.android:card-stack-view:2.3.4"
}

1) activity_like.xml 작성

<androidx.constraintlayout.widget.ConstraintLayout android:layout_width="match_parent" android:layout_height="match_parent" ~>

    <TextView [센터정렬] android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="매칭할 카드가 없습니다."/>
    
    <com.yuyakaido.android.cardstackview.CardStackView
        android:layout_width="match_parent"
        android:layout_height="300dp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        android:id="@+id/cardStackView"
        />

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        android:text="LIKE"/>

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        android:text="DISLIKE"
        app:layout_constraintEnd_toEndOf="parent"/>
    <Button
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:id="@+id/matchListButton"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        android:text="매치 리스트 보기"
        app:layout_constraintBottom_toTopOf="@+id/signOutButton"
        />

    <Button
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:id="@+id/signOutButton"
        android:text="로그아웃 하기"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"/>

</androidx.constraintlayout.widget.ConstraintLayout>

2) item_card.xml 작성[CardView 사용]
<androidx.cardview.widget.CardView xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    app:cardCornerRadius="16dp"
    android:layout_margin="24dp"
    android:layout_height="match_parent">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:background="#EDEB34">

        <TextView
            android:gravity="center"
            android:textColor="@color/black"
            android:text="name"
            android:textSize="40sp"
            android:id="@+id/nameTextView"
            android:layout_width="match_parent"
            android:layout_height="match_parent"/>

    </LinearLayout>


</androidx.cardview.widget.CardView>

3) CardItem 데이터 클래스 만들기

data class CardItem ( val userId : String, var name : String )

4) CardItemAdapter 클래스 만들기(RecyclerView와 거의 유사함) ★★★★★(아주 중요함!! 자주사용 되니깐 외워두자!!)

class CardItemAdapter : ListAdapter<CardItem, CardItemAdapter.ViewHolder>(diffUtil) {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): CardItemAdapter.ViewHolder {
        //val inflater = LayoutInflater.from(parent.context)
        //return ViewHolder(inflater.inflate(R.layout.item_card, parent, false))
        return ViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.item_card, parent, false))
    }

    override fun onBindViewHolder(holder: CardItemAdapter.ViewHolder, position: Int) {
        holder.bind(currentList[position])
    }

    inner class ViewHolder(val view : View) : RecyclerView.ViewHolder(view){

        fun bind(cardItem : CardItem){
            view.findViewById<TextView>(R.id.nameTextView).text = cardItem.name
        }
    }

    companion object{
        val diffUtil = object : DiffUtil.ItemCallback<CardItem>(){
            override fun areItemsTheSame(oldItem: CardItem, newItem: CardItem): Boolean {
                return oldItem.userId == newItem.userId
            }

            override fun areContentsTheSame(oldItem: CardItem, newItem: CardItem): Boolean {
                return oldItem == newItem
            }

        }
    }
}

5) LikeActivity 추가 작성 ★★★★★
[위에서 작성한 기존 코드에서 추가로 작성]

class LikeActivity : AppCompatActivity(), CardStackListener {

    //CardItemAdapter 전역 변수 생성
    private val adapter = CardItemAdapter()
    
    //Adapter에 추가할 CardItem리스트 생성
    private val cardItems = mutableListOf<CardItem>()

    /*
        Adapter에 추가할 CardStackLayoutManager 추가. 일반적으로 LinearLayoutManager(this) 사용했었음
        요가서 listener에 있는 this에 에러가 뜬다면 위에 class : LikeActivity : AppCompatActivity()에 CardStackListener 상속추가 해주면 됨
        ex) class LikeActivity : AppCompatActivity(), CardStackListener { ~ }
        상속 추가해주고 implements 로 오버라이딩 해주면 됨. 여기서는 CardSwiped() 만 사용할 예
    */
    private val manager by lazy { CardStackLayoutManager(this, this) }

    override fun onCreate(savedInstanceState: Bundle?) {
        ~
        initCardStackView()
    }

    private fun initCardStackView(){
        val stackView = findViewById<CardStackView>(R.id.cardStackView)

        stackView.layoutManager = manager
        stackView.adapter = adapter
    }

    override fun onCardDragging(direction: Direction?, ratio: Float) {}

    //이 부분만 사용할 예정
    override fun onCardSwiped(direction: Direction?) {
        when(direction){
            Direction.Right -> {}//like()}
            Direction.Left -> {}//disLike()
            else -> { }
        }
    }

    override fun onCardRewound() {}

    override fun onCardCanceled() {}

    override fun onCardAppeared(view: View?, position: Int) {}

    override fun onCardDisappeared(view: View?, position: Int) {}

}

============================== 틴더 애니메이션 및 카드뷰 등록 완료 ==============================   

[5]. 리얼타임 데이터베이스에서 유저 정보 가져와서 Swipe Animation에 추가하기

//시작될때 CardView 리스트 가져와서 Adapter에 추가하기
private fun getUnSelectedUsers() {

    //아래 이벤트 리스터의 경우 데이터베이스 변경이 일어날 경우 호출하는 함
    userDB.addChildEventListener(object : ChildEventListener {

        override fun onChildAdded(snapshot: DataSnapshot, previousChildName: String?) {
            //내가 아니고 내가 좋아요를 선택하지 않았고, 디스라이크에 상대방이 없으면 표시하는것.
            if (snapshot.child(USER_ID).value != getCurrentUserID()
                && snapshot.child(LIKED_BY).child(LIKE).hasChild(getCurrentUserID()).not()
                && snapshot.child(LIKED_BY).child(DIS_LIKE).hasChild(getCurrentUserID()).not()
            ) {

                val userId = snapshot.child(USER_ID).value.toString()
                var name = "undecided"
                if (snapshot.child(NAME).value != null) {
                    name = snapshot.child(NAME).value.toString()
                }

                cardItems.add(CardItem(userId, name))
                adapter.submitList(cardItems)
                adapter.notifyDataSetChanged()
            }
        }

        //데이터가 변경될때 name이 추가가 되면 onCholdChanged를 통해 다시 뷰를 변경해주는 작업
        override fun onChildChanged(snapshot: DataSnapshot, previousChildName: String?) {
            cardItems.find { it.userId == snapshot.key }?.let {
                it.name = snapshot.child(NAME).value.toString()
            }
            adapter.submitList(cardItems)
            adapter.notifyDataSetChanged()
        }

        override fun onChildRemoved(snapshot: DataSnapshot) { }
        override fun onChildMoved(snapshot: DataSnapshot, previousChildName: String?) { }
        override fun onCancelled(error: DatabaseError) { }
    })
}

//유저정보 가져오기 및 갱신 [이 부분 추가(saveUserName, onCreate)] → 기존 코드에 추가 작성(호출하는 부분만) getUnSelectedUsers()

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_like)

    userDB = Firebase.database.reference.child(USERS)

    val currentUserDB = userDB.child(getCurrentUserID())

    //DB를 가져오는 작업. 딱 한번만 수행함.
    currentUserDB.addListenerForSingleValueEvent(object : ValueEventListener {
        override fun onDataChange(snapshot: DataSnapshot) {
            if (snapshot.child(NAME).value == null) {
                showNameInfoPopup()
                return
            }

            //유저정보 가져오기 및 갱신 + 여기 추가
            getUnSelectedUsers()
        }
        override fun onCancelled(error: DatabaseError) { }
    })

    initCardStackView()
}

private fun saveUserName(name : String){
    val userId = getCurrentUserID()
    val currentUserDB = userDB.child(getCurrentUserID())
    val user = mutableMapOf<String, Any>()
    user[USER_ID] = userId
    user[NAME] = name
    //리얼타임 디비에 유저 이름 등록해주는 걸로 업데이
    currentUserDB.updateChildren(user)

    //여기 추가
    getUnSelectedUsers()
}

============================== 카드 뷰에 리얼타임 데이터베이스 유저정보들 가져와서 추가하기 ============================== 

[6]. Like & DisLike animation 및 Matched List 표현

//Like 작성
private fun like(){
    val card = cardItems[manager.topPosition - 1]
    cardItems.removeFirst()
    
    userDB.child(card.userId)
        .child(LIKED_BY)
        .child(LIKE)
        .child(getCurrentUserID())
        .setValue(true)
    
    saveMatchIfOtherUserLikeMe(card.userId)
    Toast.makeText(this, "${card.name}님을 Like 하였습니다.", Toast.LENGTH_SHORT).show()
}

//DisLike 작성
private fun disLike(){
    val card = cardItems[manager.topPosition - 1]
    cardItems.removeFirst()
    
    userDB.child(card.userId)
        .child(LIKED_BY)
        .child(DIS_LIKE)
        .child(getCurrentUserID())
        .setValue(true)
    Toast.makeText(this, "${card.name}님을 dislike 하였습니다.", Toast.LENGTH_SHORT).show()
}

//saveMatchIfOtherUserLikeMe 작성(여기부터 모르겠다.. )
private fun saveMatchIfOtherUserLikeMe(otherUserId : String){
    val otherUserDB = userDB.child(getCurrentUserID()).child(LIKED_BY).child(LIKE).child(otherUserId)
    otherUserDB.addListenerForSingleValueEvent(object : ValueEventListener{
        override fun onDataChange(snapshot: DataSnapshot) {
            if(snapshot.value == true){
                userDB.child(getCurrentUserID())
                    .child(LIKED_BY)
                    .child("match")
                    .child(otherUserId)
                    .setValue(true)

                userDB.child(otherUserId)
                    .child(LIKED_BY)
                    .child("match")
                    .child(getCurrentUserID())
                    .setValue(true)
            }
        }
        override fun onCancelled(error: DatabaseError) { }
    })
}



============================== 매치된 유저 화면 보여주는 리사이클러뷰 만들기 ==============================   

1) activity_match.xml 작성
<androidx.constraintlayout.widget.ConstraintLayout android:layout_width="match_parent" android:layout_height="match_parent"
    xmlns:app="http://schemas.android.com/apk/res-auto">

    <androidx.recyclerview.widget.RecyclerView
        android:layout_width="0dp"
        android:layout_height="0dp"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintStart_toStartOf="parent"
        app:layout_constraintEnd_toEndOf="parent"
        app:layout_constraintBottom_toBottomOf="parent"
        android:id="@+id/matchedUserRecyclerView"/>

</androidx.constraintlayout.widget.ConstraintLayout>

2) item_matched_user.xml 작성
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:padding="10dp" android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:textSize="30sp"
        android:id="@+id/userNameTextView"/>

</LinearLayout>

3) MatchedUserAdapter 작성
class MatchedUserAdapter : ListAdapter<CardItem, MatchedUserAdapter.ViewHolder>(diffUtil) {

    inner class ViewHolder(var view : View) : RecyclerView.ViewHolder(view){
        fun bind(cardItem : CardItem){
            view.findViewById<TextView>(R.id.userNameTextView).text = cardItem.name
        }
    }

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        return ViewHolder(LayoutInflater.from(parent.context).inflate(R.layout.item_matched_user, parent, false))
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.bind(currentList[position])
    }
    
    companion object{
        var diffUtil = object : DiffUtil.ItemCallback<CardItem>(){
            override fun areItemsTheSame(oldItem: CardItem, newItem: CardItem): Boolean {
                return oldItem.userId == newItem.userId
            }

            override fun areContentsTheSame(oldItem: CardItem, newItem: CardItem): Boolean {
                return oldItem == newItem
            }

        }
    }
}

4) MatchedUserActivity 작성
class MatchedUserActivity : AppCompatActivity() {

    private val auth : FirebaseAuth = FirebaseAuth.getInstance()
    private lateinit var userDB : DatabaseReference

    private val adapter = MatchedUserAdapter()
    private val cardItems = mutableListOf<CardItem>()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_match)

        //UserDB 가져오기
        userDB = Firebase.database.reference.child("Users")

        initMatchedUserRecyclerView()
        getMatchUsers()
    }

    private fun initMatchedUserRecyclerView(){
        val recyclerView = findViewById<RecyclerView>(R.id.matchedUserRecyclerView)
        recyclerView.layoutManager = LinearLayoutManager(this)
        recyclerView.adapter = adapter
    }

    private fun getMatchUsers(){
        val matchedDB = userDB.child(getCurrentUserID()).child("likedBy").child("match")

        matchedDB.addChildEventListener(object: ChildEventListener {
            override fun onChildAdded(snapshot: DataSnapshot, previousChildName: String?) {
                if(snapshot.key?.isNotEmpty() == true){
                    getUserByKey(snapshot.key.orEmpty())
                }
            }
            override fun onChildChanged(snapshot: DataSnapshot, previousChildName: String?) {}
            override fun onChildRemoved(snapshot: DataSnapshot) {}
            override fun onChildMoved(snapshot: DataSnapshot, previousChildName: String?) {}
            override fun onCancelled(error: DatabaseError) {}
        })
    }

    private fun getUserByKey(userId : String){
        userDB.child(userId).addListenerForSingleValueEvent(object : ValueEventListener {
            override fun onDataChange(snapshot: DataSnapshot) {
                cardItems.add(CardItem(userId, snapshot.child("name").value.toString()))
                adapter.submitList(cardItems)
            }

            override fun onCancelled(error: DatabaseError) {}

        })
    }

    private fun getCurrentUserID() : String{
        if(auth.currentUser == null){
            Toast.makeText(this, "로그인이 되어있지 않습니다.", Toast.LENGTH_SHORT).show()
            finish()
        }
        return auth.currentUser?.uid.orEmpty()
    }
}


[7]. LikeActivity에 버튼 활성화(로그아웃, 매치리스트)

activity_like.xml 에 위젯 추가
<Button
    android:id="@+id/matchListButton"
    android:layout_width="0dp"
    android:layout_height="wrap_content"
    android:text="매치 리스트 보기"
    app:layout_constraintBottom_toTopOf="@+id/signOutButton"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintStart_toStartOf="parent" />

<Button
    android:id="@+id/signOutButton"
    android:layout_width="0dp"
    android:layout_height="wrap_content"
    android:text="로그아웃 하기"
    app:layout_constraintBottom_toBottomOf="parent"
    app:layout_constraintEnd_toEndOf="parent"
    app:layout_constraintStart_toStartOf="parent" />

LikeActivity에 버튼 기능 추가

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_like)

    userDB = Firebase.database.reference.child(USERS)

    val currentUserDB = userDB.child(getCurrentUserID())

    //DB를 가져오는 작업. 딱 한번만 수행함.
    currentUserDB.addListenerForSingleValueEvent(object : ValueEventListener {
        override fun onDataChange(snapshot: DataSnapshot) {
            if (snapshot.child(NAME).value == null) {
                showNameInfoPopup()
                return
            }

            //유저정보 가져오기 및 갱신
            getUnSelectedUsers()
        }
        override fun onCancelled(error: DatabaseError) { }
    })

    initCardStackView()
    initSignOutButton() //추가
    initMatchedListButton() //추가
}

private fun initSignOutButton(){
    val signOutButton = findViewById<Button>(R.id.signOutButton)
    signOutButton.setOnClickListener {
        auth.signOut()
        startActivity(Intent(this, MainActivity::class.java))
        finish()
    }
}

private fun initMatchedListButton(){
    val matchedListButton = findViewById<Button>(R.id.matchListButton)
    matchedListButton.setOnClickListener {
        startActivity(Intent(this, MatchedUserActivity::class.java))
    }
}



============================== 틴더 앱 만들기 종료 ==============================   

※ 너무 어렵다.. 아직.. 특히 리얼타임 데이터베이스 이해하기 너무 어려움.. 연습하자





