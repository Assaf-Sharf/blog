---
published: true
title: "[Algorithm] 완전탐색 - DFS/BFS"

categories: Algorithm
tag: [codingtest, algorithm, dfs/bfs]

toc: true
toc_sticky: true

sidebar:
    nav: "docs"
    nav: "counts"

date: 2023-12-29
---
**그래프 탐색 알고리즘 DFS/BFS**

**탐색(search)** | 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정

대표적인 그래프 탐색 알고리즘으로는 **DFS**와 **BFS**가 있다. 

DFS/BFS는 코딩 테스트에서 매우 자주 등장하는 유형이므로 반드시 숙지해야 한다.

DFS/BFS를 배우기 전에 반드시 스택과 큐는 반드시 알아두어야 할 자료구조이다.

<br>
<br>

# Stack

- 먼저 들어 온 데이터가 나중에 나가는 형식의 자료구조 (선입후출) (**FILO**)
- 입구와 출구가 동일한 형태로 스택을 시각화할 수 있다.
- ex) 쌓아올린 박스

**스택 구현 예제**

파이썬에서는 `append()`와 `pop()`의 시간복잡도가 상수. 즉 O(1)이기 때문에

리스트로 스택을 구현하면 된다.

```python
stack = []

# 삽입(5) - 삽입(2) - 삽입(3) - 삽입(7) - 삭제() - 삽입(1) - 삽입(4) - 삭제()
stack.append(5)
stack.append(2)
stack.append(3)
stack.append(7)
stack.pop()
stack.append(1)
stack.append(4)
stack.pop()

print(stack[::-1]) # 최상당 원소부터 출력
print(stack) # 최하단 원소부터 출력

# output
>>> [1, 3, 2, 5]
>>> [5, 2, 3, 1]
```

<br>
<br>

# 큐

- 먼저 들어온 데이터가 먼저 나가는 형식의 자료구조 (선입선출) (**FIFO**)
- 입구와 출구가 모두 뚫려 있는 터널과 같은 형태
- ex) 은행 창구, 터널 등

**큐 구현 예제**

파이썬에서는 큐를 구현할 때 deque를 사용하여 구현한다.

list자료형으로 기능적으로는 큐를 구현할 수 있지만 시간복잡도가 더 높아서 비효율적으로 동작한다.

```python
from collections import deque

queue = deque()

# 삽입(5) - 삽입(2) - 삽입(3) - 삽입(7) - 삭제() - 삽입(1) - 삽입(4) - 삭제()
queue.append(5)
queue.append(2)
queue.append(3)
queue.append(7)
queue.popleft()
queue.append(1)
queue.append(4)
queue.popleft()

print(queue) # 먼저 들어온 순서대로 출력
queue.reverse() # 역순으로 바꾸기
print(queue) # 나중에 들어온 원소부터 출력

# output
>>> deque([3, 7, 1, 4])
>>> deque([4, 1, 7, 3])
```
<br>
<br>

# 재귀 함수

**재귀 함수(Recursive Function)** | 자기 자신을 다시 호출하는 함수를 의미

DFS를 실질적으로 구현하고자 할 때 자주 사용하는 방법 중 하나이므로 이해가 필요하다.

```python
def recursive_func():
    print('재귀 함수 호출')
    recursive_func()

recursive_func()
```

> 파이썬에서는 재귀를 호출하는 과정에서의 깊이 제한이 있기 때문에 별다른 설정을 하지 않고 함수를 재귀적으로 호출하게 되면 오류가 발생한다.

```python
def recursive_func():
    if i == 100:
        return
    print(i, '번째 재귀함수에서', i+1, '번째 재귀함수 호출')
    recursive_function(i+1)
    print(i, '번째 재귀함수 종료')

recursive_func(1)
```

재귀 함수를 문제 풀이에서 사용할 때는 **재귀 함수의 종료 조건을 반드시 명시**해야 한다.

**재귀함수 구현 예제(팩토리얼)**

`n! = 1 x 2 x 3 x ... x (n-1) x n`

```python
# 반복적으로 구현한 n!
def factorial_iterative(n):
    result = 1
    # 1부터 n까지 차례대로 곱하기
    for i in range(1, n+1):
        result += i
    return result

# 재귀적으로 구현한 n!
def factorial_recursive(n):
    if n <= 1: # n이 1이하인 경우 1 반환 -> 0!과 1!의 값은 1
        return 1 
    # n! = n * (n-1)!
    return n * factorial_recursive(n-1)

print('반복적으로 구현:', factorial_iterative(5))
print('재귀적으로 구현:', factorial_recursive(5))

# output
>>> 반복적으로 구현: 120
>>> 재귀적으로 구현: 120
```