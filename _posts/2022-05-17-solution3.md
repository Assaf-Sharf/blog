---
layout: single
title: "백준 1260 / dfs/bfs "
toc: true
categories: study
tag : [algorithm]
---


[문제 링크](https://www.acmicpc.net/problem/1260)
```python
from collections import deque
from sys import stdin

m = list(map(int,stdin.readline().split()))
cnt=0
n=[]
o = m[1]
p = m[2]

while cnt<o:
  c=(list(map(int,stdin.readline().split())))
  n.append(c)
  cnt +=1


visited = [False]*o
def dfs(n,v,visited):
	print(v, end='')
	visited[v]=True
    for i in n[v]:
        if not visited[i]:
            dfs(n,i, visited)


visited2= [False]*o

def bfs(n,start,visited2):
    queue = deque([start])
    visited2[start]=True
    while queue:
        v=queue.popleft()
        print(v,end='')
        for i in n[v]:
            if not visited2[i]:
                queue.append(i)
                visited2[i]= True
dfs(n,p,visited)
print()
bfs(n,p,visited2)





```
일단 실패한 코드 .
4 5 1
1 2
1 3
1 4
2 4
3 4
실패한 이유를 잘 모르겠다.


<% tp.date.now("YYYY-MM-DD HH:mm") %>
```python
from sys import stdin
from collections import deque

a= stdin.readline()


def dfs(v):
    print(v, end=' ')
    visit[v] = 1
    for i in range(1, n + 1):
        if visit[i] == 0 and s[v][i] == 1:
            dfs(i)

def bfs(v):
    queue = deque[v]
    visit[v] = 0
    while(queue):
        v = queue.popleft()
        print(v, end=' ')
        del queue[0]
        for i in range(1, n + 1):
            if visit[i] == 1 and s[v][i] == 1:
                queue.append(i)
                visit[i] = 0

n, m, v = map(int, a.split())
s = [[0] * (n + 1) for i in range(n + 1)]
visit = [0 for i in range(n + 1)]
for i in range(m):
    x, y = map(int, a.split())
    s[x][y] = 1
    s[y][x] = 1
    
dfs(v)
print()
bfs(v)
```

파이썬은 다중할당이 가능하다. 분기하는것보다 다중할당을 하는이유는 참조때문이다.

사실 느낀점중의 하나는, dfs나 bfs나 예제를 좀봤는데, T/F 표시나 0/1표시가 많았는데, 다른것으로 실험해봐도 큰차이는 없었다.

하지만 이렇게 사용하는 이유에 대해서 어느정도는 궁금하긴하다.

뭐 여튼 그래서 알게된것은 한번 순회할떄, 방문한곳의 표시를 나타내주는 리스트를 만들어내는 것과, 노드별로 관계를 만들어 두는 리스트를 만들어 두는것이 중요하다는 이야기다.