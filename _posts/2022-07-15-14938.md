---
layout: single
title:  "[백준]14938번: 서강그라운드"
categories: baekjoon
tag: [python, class_4, algolithm, gold, floyd-warshall, dp]
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

# 서강그라운드

solved_ac[Class4] [서강그라운드](https://www.acmicpc.net/problem/14938)

## 문제

예은이는 요즘 가장 인기가 있는 게임 서강그라운드를 즐기고 있다. 서강그라운드는 여러 지역중 하나의 지역에 낙하산을 타고 낙하하여, 그 지역에 떨어져 있는 아이템들을 이용해 서바이벌을 하는 게임이다. 서강그라운드에서 1등을 하면 보상으로 치킨을 주는데, 예은이는 단 한번도 치킨을 먹을 수가 없었다. 자신이 치킨을 못 먹는 이유는 실력 때문이 아니라 아이템 운이 없어서라고 생각한 예은이는 낙하산에서 떨어질 때 각 지역에 아이템 들이 몇 개 있는지 알려주는 프로그램을 개발을 하였지만 어디로 낙하해야 자신의 수색 범위 내에서 가장 많은 아이템을 얻을 수 있는지 알 수 없었다.

각 지역은 일정한 길이 l (1 ≤ l ≤ 15)의 길로 다른 지역과 연결되어 있고 이 길은 양방향 통행이 가능하다. 예은이는 낙하한 지역을 중심으로 거리가 수색 범위 m (1 ≤ m ≤ 15) 이내의 모든 지역의 아이템을 습득 가능하다고 할 때, 예은이가 얻을 수 있는 아이템의 최대 개수를 알려주자.

![image](https://user-images.githubusercontent.com/95459089/179193906-126c78bc-a471-4eaa-93fe-f901dcc2f616.png)

주어진 필드가 위의 그림과 같고, 예은이의 수색범위가 4라고 하자. ( 원 밖의 숫자는 지역 번호, 안의 숫자는 아이템 수, 선 위의 숫자는 거리를 의미한다) 예은이가 2번 지역에 떨어지게 되면 1번,2번(자기 지역), 3번, 5번 지역에 도달할 수 있다. (4번 지역의 경우 가는 거리가 3 + 5 = 8 > 4(수색범위) 이므로 4번 지역의 아이템을 얻을 수 없다.) 이렇게 되면 예은이는 23개의 아이템을 얻을 수 있고, 이는 위의 필드에서 예은이가 얻을 수 있는 아이템의 최대 개수이다.

## 입력

첫째 줄에는 지역의 개수 n (1 ≤ n ≤ 100)과 예은이의 수색범위 m (1 ≤ m ≤ 15), 길의 개수 r (1 ≤ r ≤ 100)이 주어진다.

둘째 줄에는 n개의 숫자가 차례대로  각 구역에 있는 아이템의 수 t (1 ≤ t ≤ 30)를 알려준다.

세 번째 줄부터 r+2번째 줄 까지 길 양 끝에 존재하는 지역의 번호 a, b, 그리고 길의 길이 l (1 ≤ l ≤ 15)가 주어진다.

## 출력

예은이가 얻을 수 있는 최대 아이템 개수를 출력한다.

## 예제 입력 1 

```
5 5 4
5 7 8 2 3
1 4 5
5 2 4
3 2 3
1 2 3
```

## 예제 출력 1 

```
23
```


# 문제 해석

본 문제는 바로 전 풀었던 그래프에 가중치가 있으면서 한 노드가 갈 수 있는 최단 경로가 아닌 여러 노드가 갈 수 있는 최단 경로들을 2차원 배열로 풀어낸 플로이드 워셜 알고리즘을 이용하는 문제이다. [[백준]11404번: 플로이드](https://donghyeok1.github.io/baekjoon/11404/)해당 알고리즘에 대해 자세히 기술해 놨으니 확인해보도록 하자.


# 풀이

- 플로이드 워셜 알고리즘의 기본 코드를 알고 있다면 쉽게 풀 수 있지만 여기서 추가해야할 코드들이 있다.
1. 양방향 통행이 가능하다.
2. 최단 거리를 구해서 끝이 아닌 각 최단거리를 이용해 입력 받은 수색 가능한 거리와 비교하여 수색 가능하다면 해당 노드에 있는 아이템의 개수를 더해주어 max 값을 출력해 내는 형식이다.

- 양방향 통행은 입력을 받을 때 a, b, c로 입력을 받고 graph[a][b] = c와 graph[b][a] = c를 같이 넣어준다면 양방향으로 가능하게 만들어주는 것이다.
- 아이템의 갯수를 따로 item_list라는 리스트에 입력을 받아 놓고 index로 접근을 한다.
- 만약 수색 가능 범위가 4라면 루프를 돌면서 1번 노드가 갈 수 있는 최단 경로 중 4를 넘지 않는 범위들만 골라서 그 곳의 아이템을 더해준다.
- 각 노드마다 가져갈 수 있는 아이템들을 비교하여 max 값을 출력해준다.

```python
import sys

n, m, r = map(int, sys.stdin.readline().split())

INF = float('inf')

item_list = list(map(int, sys.stdin.readline().split()))


graph = [[INF] * (n + 1) for _ in range(n + 1)]

for k in range(r):
    a, b, c = map(int, sys.stdin.readline().split()) 
    graph[a][b] = c
    graph[b][a] = c

for i in range(1, n + 1):
    for j in range(1, n + 1):
        if i == j:
            graph[i][j] = 0
            
for k in range(1, n + 1):
    for i in range(1, n + 1):
        for j in range(1, n + 1):
            graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])
max_sum = 0           
for i in range(1, n + 1):
    sum = 0
    for j in range(1, n + 1):
        if graph[i][j] == float('inf'):
            continue
        if graph[i][j] <= m:
            sum += item_list[j - 1]
    max_sum = max(max_sum, sum)

print(max_sum)
```

# 고찰

바로 전 문제에서 플로이드 워셜 문제를 완벽하게 공부를 해놓았기 때문에 문제를 푸는데 전혀 어려움이 없었다. 그리고 전 포스팅에서 INF 값을 숫자가 아닌 float('inf')로 주는 것을 활용해 봤는데 간편하고 오류가 뜨지 않아서 좋았다.