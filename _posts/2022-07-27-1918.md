---
layout: single
title:  "[백준]1918번: 후위 표기식"
categories: baekjoon
tag: [python, algolithm, gold, stack, BOJ]
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

# 후위 표기식

[후위 표기식](https://www.acmicpc.net/problem/1918)

## 문제

수식은 일반적으로 3가지 표기법으로 표현할 수 있다. 연산자가 피연산자 가운데 위치하는 중위 표기법(일반적으로 우리가 쓰는 방법이다), 연산자가 피연산자 앞에 위치하는 전위 표기법(prefix notation), 연산자가 피연산자 뒤에 위치하는 후위 표기법(postfix notation)이 그것이다. 예를 들어 중위 표기법으로 표현된 a+b는 전위 표기법으로는 +ab이고, 후위 표기법으로는 ab+가 된다.

이 문제에서 우리가 다룰 표기법은 후위 표기법이다. 후위 표기법은 위에서 말한 법과 같이 연산자가 피연산자 뒤에 위치하는 방법이다. 이 방법의 장점은 다음과 같다. 우리가 흔히 쓰는 중위 표기식 같은 경우에는 덧셈과 곱셈의 우선순위에 차이가 있어 왼쪽부터 차례로 계산할 수 없지만 후위 표기식을 사용하면 순서를 적절히 조절하여 순서를 정해줄 수 있다. 또한 같은 방법으로 괄호 등도 필요 없게 된다. 예를 들어 a+b*c를 후위 표기식으로 바꾸면 abc*+가 된다.

중위 표기식을 후위 표기식으로 바꾸는 방법을 간단히 설명하면 이렇다. 우선 주어진 중위 표기식을 연산자의 우선순위에 따라 괄호로 묶어준다. 그런 다음에 괄호 안의 연산자를 괄호의 오른쪽으로 옮겨주면 된다.

예를 들어 a+b*c는 (a+(b*c))의 식과 같게 된다. 그 다음에 안에 있는 괄호의 연산자 *를 괄호 밖으로 꺼내게 되면 (a+bc*)가 된다. 마지막으로 또 +를 괄호의 오른쪽으로 고치면 abc*+가 되게 된다.

다른 예를 들어 그림으로 표현하면 A+B*C-D/E를 완전하게 괄호로 묶고 연산자를 이동시킬 장소를 표시하면 다음과 같이 된다.

<p align="center">
<img style="margin:50px 0 10px 0" src="https://upload.acmicpc.net/5aad2feb-d9fc-430a-954d-73a06ba0215f/-/preview/" alt/>
  <p align = "center">
  결과: ABC*+DE/-
  </p>
</p> 

이러한 사실을 알고 중위 표기식이 주어졌을 때 후위 표기식으로 고치는 프로그램을 작성하시오


## 입력

첫째 줄에 중위 표기식이 주어진다. 단 이 수식의 피연산자는 알파벳 대문자로 이루어지며 수식에서 한 번씩만 등장한다. 그리고 -A+B와 같이 -가 가장 앞에 오거나 AB와 같이 *가 생략되는 등의 수식은 주어지지 않는다. 표기식은 알파벳 대문자와 +, -, *, /, (, )로만 이루어져 있으며, 길이는 100을 넘지 않는다. 

## 출력

첫째 줄에 후위 표기식으로 바뀐 식을 출력하시오

## 예제 입력 1 

```
A*(B+C)
```

## 예제 출력 1 

```
ABC+*
```

## 예제 입력 2

```
A+B
```

## 예제 출력 2 

```
AB+
```

## 예제 입력 3

```
A+B*C
```

## 예제 출력 3 

```
ABC*+
```

## 예제 입력 4

```
A+B*C-D/E
```

## 예제 출력 4 

```
ABC*+DE/-
```

# 문제 해석

- 중위 연산을 후위 연산으로 고치는 방식이다. 우선적으로 계산이 되는 연산자를 두 수 뒤에 붙여넣는 식이다. 예를 들어 A * B * C = AB*C* 로 표기가 된다.
- A * B * C = AB*C*
- A + B * C = ABC*+
- A + B * C * D = ABCD**+
- A + B + C = AB+C+
- A + B * C + D * E = ABC*+DE*+ 

- 위의 예시들을 본다면 * 연산자가 나왔을 때 만약 그 전에 연산자도 * 였으면 바로 연산자가 튀어나온다. 
- 예를 들어 A * B 다음에 *가 나온다면 AB*가 나오게 되고 다음 알파벳이 나온다.
- 그리고 +는 이전에 아무 연산이 없는 경우가 아니라면 끊고 그 전까지 출력한다.
- "(" 이 괄호가 나왔을 때에는 ")" 닫히는 경우만 생각해주면 된다. 
- ")"으로 괄호를 닫았을 때 "(" 이 괄호가 나오기 전까지 전부 출력해주면 된다.

# 풀이

- 입력 받은 문자열 s의 크기 만큼 루프

    - *나 /가 나오면?
        - stack이 비어있지 않고, 가장 최근 연산자가 *나 /일때 루프
            - ex) A*B*C = AB*C*
            - ans += stack.pop()
            - 주의 : 전 연산자가 계속 *라면 계속해서 pop해야함
        - 현재 나온 연산자 *나 /를 stack.append()

    - +나 -가 나오면?
        - stack이 비어있지 않고, 가장 최근 연산자가 "("있기 전까지 루프
            - ex) A*B+C+D+E
            - ex) AB*C+D+E+
            - ans += stack.pop()
        - 현재 나온 연산자 +나 -를 stack.append()

    - "("가 나오면?
        - stack.append()

    - ")"가 나오면?
        - stack이 비어있지 않고, 가장 최근 연산자가 "("있기 전까지 루프
            - ans += stack.pop()
        - stack.pop()
        - "(" 연산자를 발견하면 빼줘야한다.

    - 알파벳이 나온다면?
        - ans += s[i]

- stack이 안비어있다면
    - 빌때까지 루프
        - ans += s[i] 

```python
import sys

s = sys.stdin.readline().rstrip()
stack = []
ans = ""

for i in range(len(s)):
    if s[i] == "(":
        stack.append(s[i])
    elif s[i] == "*" or s[i] == "/":
        while stack and(stack[-1] == "*" or stack[-1] == "/"):
            ans += stack.pop()
        stack.append(s[i])
    elif s[i] == "+" or s[i] == "-":
        while stack and stack[-1] != "(":
            ans += stack.pop()
        stack.append(s[i])
    elif s[i] == ")":
        while stack and stack[-1] != "(":
            ans += stack.pop()
        stack.pop()
    else:
        ans += s[i]
while stack:
    ans += stack.pop()
print(ans)
```

# 고찰

- 차분히 생각해보면 쉬운 문제인데, 기본 조건들을 섬세하게 살피지 않고 후위 표기법을 잘 안다는 자신감에 풀게 되어서 계속해서 오류가 나왔다.
- 예외 처리가 엄청 많다고 생각을 했는데, 막상 다시 차분하게 생각해 봤을때 두가지 정도의 예외만 처리해주면 손쉽게 답이 나오는 구조였다.