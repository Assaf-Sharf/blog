---
title: Linux 내부 구조 정리 - (3)
categories: 
   - Linux
tags:
   - Linux 내부 구조
   - Linux 1.3
author_profile: true #작성자 프로필 출력여부
read_time: true # read_time을 출력할지 여부 1min read 같은것!

toc: true #Table Of Contents 목차 보여줌
toc_label: "My Table of Contents" # toc 이름 정의
<!-- toc_icon: "cog" #font Awesome아이콘으로 toc 아이콘 설정 -->
toc_sticky: true # 스크롤 내릴때 같이 내려가는 목차

date: 2020-01-20T17:00:00 # 최초 생성일
last_modified_at: 2020-01-20T17:00:00 # 마지막 변경일

---

<!-- intro -->
{% include intro %}

# 1.3 프로세스를 정복하는 자가 Linux를 정복하리라


## 1.3.1 fork와 exec는 프로세스의 분신과 변신
{% capture flow %}
 1. 시스템 콘솔에서 로그인 할 때 **login: 프롬프트**에 유저명을 기다린다.  
이때, 유저명 입력 처리를 `mingetty` 프로세스가 담당한다.  
2. 로그인 성공시 `bash` 프로세스가 가동되어 **커맨드 프롬프트**가 표시된다.  
3. 커맨드 프롬프트에 **ls 커맨드**를 실행하면 `ls` 프로세스가 가동되어 현재 디렉토리의 파일명을 표시한다.
{% endcapture %}

{% include notice--info title="Linux Console 시작화면 흐름" content=flow %}

 이 일련의 동작에는 프로세스 생성에 대한 깊은 이해를 할 수 있는 열쇠가 숨겨져 있다.  

테스트용 Linux 서버를 런레벨 3으로 가동한 뒤 `mingetty` 프로세스를 확인해보자.  
시스템 흐름에서 **1번 흐름**이다.
``` bash
# ps -ef | grep "mingetty[y]"
root 1692 1 0 19:21 tty1 00:00:00 /sbin/mingetty /dev/tty1  
root 1694 1 0 19:21 tty2 00:00:00 /sbin/mingetty /dev/tty2  
root 1696 1 0 19:21 tty3 00:00:00 /sbin/mingetty /dev/tty3  
root 1700 1 0 19:21 tty4 00:00:00 /sbin/mingetty /dev/tty4  
root 1702 1 0 19:21 tty5 00:00:00 /sbin/mingetty /dev/tty5  
root 1704 1 0 19:21 tty6 00:00:00 /sbin/mingetty /dev/tty6  
```

grep 커맨드 중 [y] 는 `grep` 프로세스 자신을 결과에 출력하지 않는 것이다.  
**mingetty 프로세스** 6개를 확인할 수 있고, 이는 **6개의 가상 콘솔 login: 프롬프트**이다.
여기서 유저명을 입력해서 **유저명 입력 프롬프트** → **비밀번호 입력 프롬프트**까지 진행한 뒤 다시 한번 **mingetty 프로세스들**을 확인해 보자.
``` bash
# ps -ef | grep "mingetty[y]"
root 1694 1 0 19:21 tty2 00:00:00 /sbin/mingetty /dev/tty2  
root 1696 1 0 19:21 tty3 00:00:00 /sbin/mingetty /dev/tty3  
root 1700 1 0 19:21 tty4 00:00:00 /sbin/mingetty /dev/tty4  
root 1702 1 0 19:21 tty5 00:00:00 /sbin/mingetty /dev/tty5  
root 1704 1 0 19:21 tty6 00:00:00 /sbin/mingetty /dev/tty6  
```

출력된 결과를 보면 프로세스 수가 하나 줄었고, 사라진 프로세스 찾기 위해  사라졌던 프로세서 ID(1692)로 검색하면 **login 프로세스**로 표시되는 것을 볼 수 있다.  
**1번 흐름과 2번 흐름 사이**이다.
``` bash
# ps -ef | grep "169[2]"
root 1692 1 0 19:21 tty1 00:00:00 /bin/login --
```
**mingetty 프로세스**가 `exec() 시스템 콜`을 이용하여 **login 프로세스**가 되었다.  
표로 `fork`, `exec`를 정리해보겠다.  

|status  |exec|fork |
|---|----|----|
|**실행 전**  |pid = X<br>프로그램 = A |pid = X<br>프로그램 = A |
|**실행 후**  |pid = X<br>프로그램 = B |pid = X<br>프로그램 = A <br>--------<br>pid = Y<br>프로그램 = A |
|**설명**  |프로세스가 변한다.<br> 부가 정보 [^1]는 남겨두고 프로세스가 실행되는 프로그램 코드만 새로운 코드로 바뀐다.|프로세스(동일한 프로그램)가 두 개로 나뉜다.|

[^1] : 프로세서를 특정하기 위한 프로세스 ID, FCB(File Control Block), 파일, 파일 디스크림터(파일을 관리하기 위해 운영체제가 필요로 하는 파일의 정보를 가지고 있는 것)

{% capture exec_fail %}
``` c
454 execl (loginprog, loginprog, autologin? "-f" : "--", logname, NULL);
455 error ("%s": can't exec %s: %s", tty, loginprog, strerror (errno));
456 sleep (5);
457 exit (EXIT_FAILURE);
```
execl 이 실패할 경우 455행 코드가 실행 된다.  
/bin/login을 실행하게 되므로 보통은 455행 이후의 코드가 실행될 일은 없다.
{% endcapture %}

{% include notice--info title="mingetty.c" content=exec_fail %}

이후 login 프로세스는 패스워드 입력을 받아 유저 인증을 한다.  
로그인한 유저의 bash를 가동한다.  
다시 한번 같은 프로세스 ID로 검색해보자.  
밑의 출력 결과를 보면, **login 프로세스**는 그대로이고, **bash 프로세스**가 검색 결과에 포함되어있다.

``` bash
# ps -ef | grep "169[2]"
root 1692	1	0	19:21	?	00:00:00 login -- root
root 1818	1692	0	19:21	tty1	00:00:00 -bash
```

이것은 자식 프로세스로서 bash 프로세스가 가동됨을 알 수있다.  
출력은 앞에서 부터 `유저 ID`, `프로세스 ID`, `부모 프로세스 ID` 이다.  
기존 login 프로세스의 부모 프로세스는 **init 프로세스**이다.  

일반적으로 **부모 프로세스가 자식 프로세스를 만드는 것**은 `fork`라고 한다.  
다만, 위의 경우는 **login 프로세스가 bash를 포크한 것이 아니라**, **부모 login 프로세스가 자식 login 프로세스를 fork 한 뒤 자식 프로세스가 exec를 통해 bash 프로세스로 생성**된 것이다.  
이런 테크닉은 `fork-exec`라고 부른다.  

`fork`는 pid = fork(); 코드를 통해 만들어지는데, 해당 fork() 코드를 기준으로 새로운 프로세스가 하나 생성되며, 부모 프로세스의 pid에는 자신의 프로세스 ID, 자식 프로세스의 pid에는 0이 삽입된다.  
이후, if 문을 통해 부모, 자식 프로세스 간 서로 다른 코드를 작성함으로서 자식 프로세스는 다른 프로세스로 `exec` 할 수 있는 것이다.

<big>fork() 함수 수행시, **전처리(#include) 부터 시작하는 것이 아니라 fork 함수 행부터 자식 프로세스가 실행**된다.  
fork 실패 시 pid에는 음수가 들어간다.  
if 문에서 음수에는 오류 상황 예외 처리를 해주면 된다.</big>
{: .notice--warning}

프로세스가 끝날 때 흐름을 살펴보자.
* 부모 프로세스  
부모 프로세스인 login은 함수 `wait`에서 자식 프로세스가 종료할 때까지 슬립 상태로 계속 기다린다.  
`wait`은  자식 프로세스가 종료되어 CHLD 시그널을 받을 때까지 슬립 상태로 기다리기 위한 함수이다.  
밑의 코드를 살펴보면, 슬립 상태를 나타내는 S의 기호가 붙어있음을 알 수 있다.  

``` bash
# ps aux | grep "logi[n]"
root 1692 0.0. 0.2 77004 2532 ? Ss 19:21 00:00 login-- root
```

* 자식 프로세스  
`bash` 커맨드 프롬프트에서 exit를 입력해서 로그아웃한다.  
이때, `bash` 프로세스는 exit() 시스템 콜에 의해 종료되어 부모 프로세스 login에게 **CHLD 시그널**을 송신한다.  
**CHLD 시그널**을 받은 login은 함수 `wait`에서 벗어나서 종료된다.  
CHLD 시그널을 송신한 프로세스는 **좀비 프로세스**상태가 된다.  
이때, 프로세스 상태를 확인하면 Z라고 표시된다.  
부모 프로세스 측에서 **CHLD 시그널**을 무시하게 설정되있다면, 자식 프로세스는 계속 **좀비 프로세스**로 남게된다.  


wait 함수를 통해 모든 자식 프로세스를 종료시키나면, 부모 프로세스도 종료된다.  
이때, **CHLD 시그널**은 **init 프로세스**에게 보내진다.  
init 프로세스는 login 프로세스가 종료된 것을 알고, 다시 한번 mingetty 프로세스를 가동한다.(`fork-exec`)  

<big>마지막으로, `fork-exec`에 대한 트러블이 존재하는데, fork-exec에서 새로운 프로세스를 생성할 때 처음 fork한 순간 자식 프로세스의 프로세스 명은 부모 프로세스와 동일하다.  
그 뒤에 exec에 의해 프로세스 명이 바뀌는 것인데, 이 사이에 특정 프로세스의 프로세스 수를 감시(체크)하는 경우, `fork-exec`에 의해 순간적으로 프로세스 수가 증가 할 수 있다.  
 **"이 이름의 프로세스 명은 반드시 하나만 존재해야 한다. "** 라고  등록한 경우 감시 간격의 절묘한 타이밍으로 문제가 발생하고, 문제 원인을 찾기 어려울 수 있다.</big>
 {: .notice--warning}

## 1.3.2 작업 제어의 이것저것


