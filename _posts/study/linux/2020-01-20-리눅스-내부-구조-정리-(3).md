---
title: Linux 내부 구조 정리 - (3)
categories: 
   - Linux
tags:
   - Linux 내부 구조
   - Linux 1.3
author_profile: true #작성자 프로필 출력여부
read_time: true # read_time을 출력할지 여부 1min read 같은것!

toc: true #Table Of Contents 목차 보여줌
toc_label: "My Table of Contents" # toc 이름 정의
<!-- toc_icon: "cog" #font Awesome아이콘으로 toc 아이콘 설정 -->
toc_sticky: true # 스크롤 내릴때 같이 내려가는 목차

date: 2020-01-20T17:00:00 # 최초 생성일
last_modified_at: 2020-01-20T17:00:00 # 마지막 변경일

---

<!-- intro -->
{% include intro %}

# 1.3 프로세스를 정복하는 자가 Linux를 정복하리라


## 1.3.1 fork와 exec는 프로세스의 분신과 변신
{% capture flow %}
 시스템 콘솔에서 로그인 할 때 **login: 프롬프트**에 유저명을 기다린다.  
이때, 유저명 입력 처리를 `mingetty` 프로세스가 담당한다.  
로그인 성공시 `bash` 프로세스가 가동되어 **커맨드 프롬프트**가 표시된다.  
그 후 커맨드 프롬프트에 **ls 커맨드**를 실행하면 `ls` 프로세스가 가동되어 현재 디렉토리의 파일명을 표시한다.
{% endcapture %}

{% include notice--info title="Linux Console 시작화면 흐름" content=flow %}

 이 일련의 동작에는 프로세스 생성에 대한 깊은 이해를 할 수 있는 열쇠가 숨겨져 있다.  

테스트용 Linux 서버를 런레벨 3으로 가동한 뒤 `mingetty` 프로세스를 확인해보자.  
``` bash
# ps -ef | grep "mingetty[y]"
root 1692 1 0 19:21 tty1 00:00:00 /sbin/mingetty /dev/tty1  
root 1694 1 0 19:21 tty2 00:00:00 /sbin/mingetty /dev/tty2  
root 1696 1 0 19:21 tty3 00:00:00 /sbin/mingetty /dev/tty3  
root 1700 1 0 19:21 tty4 00:00:00 /sbin/mingetty /dev/tty4  
root 1702 1 0 19:21 tty5 00:00:00 /sbin/mingetty /dev/tty5  
root 1704 1 0 19:21 tty6 00:00:00 /sbin/mingetty /dev/tty6  
```

grep 커맨드 중 [y] 는 `grep` 프로세스 자신을 결과에 출력하지 않는 것이다.  
**mingetty 프로세스** 6개를 확인할 수 있고, 이는 **6개의 가상 콘솔 login: 프롬프트**이다.
여기서 유저명을 입력해서 **유저명 입력 프롬프트** → **비밀번호 입력 프롬프트**까지 진행한 뒤 다시 한번 **mingetty 프로세스들**을 확인해 보자.
``` bash
# ps -ef | grep "mingetty[y]"
root 1694 1 0 19:21 tty2 00:00:00 /sbin/mingetty /dev/tty2  
root 1696 1 0 19:21 tty3 00:00:00 /sbin/mingetty /dev/tty3  
root 1700 1 0 19:21 tty4 00:00:00 /sbin/mingetty /dev/tty4  
root 1702 1 0 19:21 tty5 00:00:00 /sbin/mingetty /dev/tty5  
root 1704 1 0 19:21 tty6 00:00:00 /sbin/mingetty /dev/tty6  
```

출력된 결과를 보면 프로세스 수가 하나 줄었고, 사라진 프로세스 찾기 위해  사라졌던 프로세서 ID(1692)로 검색하면 **login 프로세스**로 표시되는 것을 볼 수 있다.
``` bash
# ps -ef | grep "169[2]"
root 1692 1 0 19:21 tty1 00:00:00 /bin/login --
```
**mingetty 프로세스**가 `exec() 시스템 콜`을 이용하여 **login 프로세스**가 되었다.  

표로 `fork`, `exec`를 정리해보겠다.
|exec|fork  |
|--|--|
|**실행 전**<br>pid = X<br>프로그램 = A  |**실행 전**pid = X<br>프로그램 = A  |
|**실행 후**<br>pid = X<br>프로그램 = B  |**실행 후**<br>pid = X<br>프로그램 = A <br>---<br>pid = Y<br>프로그램 = A |
|프로세스가 변한다.<br> 부가 정보[^1]는 남겨두고 프로세스가 실행되는 프로그램 코드만 새로운 코드로 바뀐다.|프로세스(동일한 프로그램)가 두 개로 나뉜다.|

[^1] : 프로세서를 특정하기 위한 프로세스 ID, FCB(File Control Block), 파일, 파일 디스크림터(파일을 관리하기 위해 운영체제가 필요로 하는 파일의 정보를 가지고 있는 것)

{% capture exec_fail %}
``` c
454 execl (loginprog, loginprog, autologin? "-f" : "--", logname, NULL);
455 error ("%s": can't exec %s: %s", tty, loginprog, strerror (errno));
456 sleep (5);
457 exit (EXIT_FAILURE);
```
execl 이 실패할 경우 455행 코드가 실행 된다.  
/bin/login을 실행하게 되므로 보통은 455행 이후의 코드가 실행될 일은 없다.
{% endcapture %}

{% include notice--info title="mingetty.c" content=exec_fail %}

이후 login 프로세스는 패스워드 입력을 받아 유저 인증을 한다.  
로그인한 유저의 bash를 가동한다.  
다시 한번 같은 프로세스 ID로 검색해보자.  
밑의 출력 결과를 보면, **login 프로세스**는 그대로이고, **bash 프로세스**가 검색 결과에 포함되어있다.

``` bash
# ps -ef | grep "169[2]"
root 1692	1		0	19:21	?		00:00:00 login -- root
root 1818	1692	0	19:21	tty1	00:00:00 -bash
```

이것은 자식 프로세스로서 bash 프로세스가 가동됨을 알 수있다.  
출력은 앞에서 부터 `유저 ID`, `프로세스 ID`, `부모 프로세스 ID` 이다.

일반적으로 **부모 프로세스가 자식 프로세스를 만드는 것**은 `fork`라고 한다.  
다만, 위의 경우는 **login 프로세스가 bash를 포크한 것이 아니라**, **부모 login 프로세스가 자식 login 프로세스를 fork 한 뒤 자식 프로세스가 exec를 통해 bash 프로세스로 생성**된 것이다.  
이런 테크닉은 `fork-exec`라고 부른다.  

`fork`는 pid = fork(); 코드를 통해 만들어지는데, 해당 fork() 코드를 기준으로 새로운 프로세스가 하나 생성되며, 부모 프로세스의 pid에는 자신의 프로세스 ID, 자식 프로세스의 pid에는 0이 삽입된다.  
이후, if 문을 통해 부모, 자식 프로세스 간 서로 다른 코드를 작성함으로서 자식 프로세스는 다른 프로세스로 `exec` 할 수 있는 것이다.

fork() 함수 수행시, **전처리(#include) 부터 시작하는 것이 아니라 fork 함수 행부터 자식 프로세스가 실행**된다.  
fork 실패 시 pid에는 음수가 들어간다.  
if 문에서 음수에는 오류 상황 예외 처리를 해주면 된다.
{: .notice--warning}

프로세스가 끝날 때 흐름을 살펴보자.
wait

이제 bash 프로세스에서 exit를 입력해 로그아웃한다.  
이때, bash 프로레스는 exit() 시스템 콜에 의해 종료되어 부모 프로세스인 login에 CHID 시그널을 송신한다.  


