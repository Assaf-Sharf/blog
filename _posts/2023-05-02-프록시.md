---

layout: single
title: "[JPA 프로그래밍] 8. 프록시와 연관관계 관리"
toc: true
toc_sticky: true
toc_label: " "

---

## 프록시

### 프록시란

> ❓ 테이블을 조회해서 객체를 가져올 때 연관관계 객체는 안 가져 오고 싶으면 어떻게 해야 할까?
> 

<img width="450" alt="image" src="https://user-images.githubusercontent.com/114092152/235614361-15fddd1a-9ff7-4a37-b6b7-02e6a7df1940.png">


- `em.find()` : 데이터베이스를 통해서 실제 엔티티 객체조회
- `em.getRefetence()` : 데이터베이스 조회를 미루는 가짜(**프록시**) 엔티티 객체 조회

```java
Member m1 = em.find(Member.class, member1.getId());
Member m2 = em.getReference(Member.class, member2.getId());

System.out.println((m1 instanceof Member));
System.out.println((m2 instanceof Member));
```

- getReference() 메서드를 사용하면 진짜 객체가 아닌 하이버네이트 내부 로직으로 프록시 엔티티 객체 반환
- 내부 구조 틀은 같지만 내용이 비어있음

<img width="450" alt="image" src="https://user-images.githubusercontent.com/114092152/235614437-c2371649-f81c-4bc8-bbfe-7ba680f2d93c.png">

### 특징

<img width="450" alt="image" src="https://user-images.githubusercontent.com/114092152/235614463-da4fe626-1991-4ed5-92cc-fbde89518c25.png">

- 실제 클래스를 상속받아서 만들어짐
- 실제 클래스와 겉모양이 같음
- 사용하는 입장에서는 진짜 객체인지 구분할 필요가 X (이론적으로)
- 프록시 객체는 실제 객체의 참조(target)를 보관
- 프록시 객체를 호출(getName()) 하면 프록시 객체는 실제 객체의 메서드 호출

- 프록시는 처음 사용할 때 한 번만 초기화
- 프록시 객체를 초기화할 때 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화되면 프록시 객체를 통해 실제 엔티티에 접근 가능
- 프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크 시 주의해야 함( == 비교 실패, 대신 instance of 사용)

```java
m1.getClass() == m2.getClass() //false
m1 instanceof Member // true
m2 instanceof Member // true
```

- 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티 반환

```java
Member m1 = em.find(Member.class, member1.getId());
System.out.println("m1 = "+ m1.getClass());//Member

Member reference = em.getReference(Member.class, member1.getId());
System.out.println("reference = " reference.getClass()); //Member

m1 == reference //true
```

→ 이미 Member가 1차 캐시에도 올라와 있지만 프록시 반환할 필요 X

- 반대로 getReference()로 프록시객체를 가지고 있으면 실제로 find()를 했을 때도 프록시 객체를 반환
- 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생

```java
Member refMember = em.getReference(Member.class, member.getId());
System.out.println("refMember = "+ refMember.getClass()); // Proxy

em.detach(refMember);  // em.clear

refMember.getUsername();
```

### 프록시 객체의 초기화

## 즉시 로딩과 지연 로딩

## 연속성 전이(CASCADE)와 고아 객체