---
layout: single
title: "[백준 10844번] [🥈1] 쉬운 계단 수 (python)"
categories: Baekjoon
tag: [python, Algorithm, Baekjoon, Dynamic Programming]
toc: true
---

**[백준 사이트 링크](<https://www.acmicpc.net/problem/10844>)**
{: .notice--primary}

### 문제

45656이란 수를 보자.

이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.

N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.

### 입력

첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.

### 출력

첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.

### 예제 입력 1

```
1
```

### 예제 출력 1

```
9
```

### 예제 입력 2

```
2
```

### 예제 출력 2

```
17
```

---


### 풀이

다음과 같은 점화식을 세울 수 있다.

- dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1] (1 <= j <= 8)
- dp[i][0] = dp[i-1][1]
- dp[i][9] = dp[i-1][8]

### 코드

#### ver(1) 

```python
import sys
input = sys.stdin.readline

# 입력값 받기
n = int(input())

# 0 ~ 9까지의 수를 각 자리에 사용하는 경우의 수를 저장할 2차원 리스트 생성
# i는 자리수, j는 0 ~ 9까지의 수
dp = [[0 for _ in range(10)] for _ in range(n+1)]

# 초기값 설정 (1자리 수일 때 각 숫자를 사용하는 경우의 수는 1)
for i in range(1,10):
    dp[1][i] = 1

# 나머지 자리수에 대해서 경우의 수 구하기
MOD = 1000000000
for i in range(2,n+1):   # i는 자리수
    for j in range(10):  # j는 현재 자리에 올 수 있는 숫자
        if j == 0:      # 현재 자리에 0이 올 경우
            dp[i][j] = dp[i-1][j+1]   # 바로 다음 자리에 1이 오는 경우의 수
        elif j == 9:    # 현재 자리에 9가 올 경우
            dp[i][j] = dp[i-1][j-1]   # 바로 다음 자리에 8이 오는 경우의 수
        else:           # 현재 자리에 0 ~ 8까지의 수가 올 경우
            dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1] # 바로 다음 자리에 j-1 혹은 j+1이 오는 경우의 수 합

# n자리 수일 때 각 숫자를 사용하는 경우의 수를 모두 합한 후 1,000,000,000으로 나눈 나머지 출력
print(sum(dp[n])% MOD)
```
