---
layout: single
title: "[백준 1449번] [🥈3] 수리공 항승 (python)"
categories: Baekjoon
tag: [python, Algorithm, Baekjoon, Greedy, Sorting]
toc: true
---

**[백준 사이트 링크](<https://www.acmicpc.net/problem/1449>)**
{: .notice--primary}

### 문제

항승이는 품질이 심각하게 나쁜 수도 파이프 회사의 수리공이다. 항승이는 세준 지하철 공사에서 물이 샌다는 소식을 듣고 수리를 하러 갔다.

파이프에서 물이 새는 곳은 신기하게도 가장 왼쪽에서 정수만큼 떨어진 거리만 물이 샌다.

항승이는 길이가 L인 테이프를 무한개 가지고 있다.

항승이는 테이프를 이용해서 물을 막으려고 한다. 항승이는 항상 물을 막을 때, 적어도 그 위치의 좌우 0.5만큼 간격을 줘야 물이 다시는 안 샌다고 생각한다.

물이 새는 곳의 위치와, 항승이가 가지고 있는 테이프의 길이 L이 주어졌을 때, 항승이가 필요한 테이프의 최소 개수를 구하는 프로그램을 작성하시오. 테이프를 자를 수 없고, 테이프를 겹쳐서 붙이는 것도 가능하다.


### 입력

첫째 줄에 물이 새는 곳의 개수 N과 테이프의 길이 L이 주어진다. 둘째 줄에는 물이 새는 곳의 위치가 주어진다. N과 L은 1,000보다 작거나 같은 자연수이고, 물이 새는 곳의 위치는 1,000보다 작거나 같은 자연수이다.

### 출력

첫째 줄에 항승이가 필요한 테이프의 개수를 출력한다.

### 예제 입력 1

```
4 2
1 2 100 101
```

### 예제 출력 1

```
2
```

### 예제 입력 2

```
4 3
1 2 3 4
```

### 예제 출력 2

```
2
```

### 예제 입력 3

```
3 1
3 2 1
```

### 예제 출력 3

```
3
```

---


### 문제를 풀면서 막혔던 부분

주어진 구멍의 위치를 정렬한 뒤, 가장 작은 값 - 0.5를 시작 위치로 설정하고, 시작 위치에 테이프를 붙인 것으로 시작한다. 그리고 구멍을 하나씩 확인하며, 해당 구멍이 이미 테이프로 막혀있는 구멍인지 확인한 뒤, 막혀있지 않은 구멍이라면 테이프를 붙인다. 이 때, 시작 위치와 끝 위치를 다시 설정하고, 테이프 개수를 증가시킨다. 마지막으로 필요한 최소한의 테이프 개수를 출력한다.

### 코드

##### ver(1) 

```python
n,l = map(int,input().split())  # n: 테이프로 막아야 하는 구멍의 개수, l: 테이프의 길이
arr = list(map(int,input().split()))  # 구멍의 위치

arr.sort()  # 구멍의 위치를 정렬하여 시작 위치를 가장 작은 값으로 설정

start = arr[0]-0.5  # 시작 위치는 가장 작은 값 - 0.5로 설정
end = start + l  # 끝 위치는 시작 위치 + 테이프의 길이로 설정
cnt = 1  # 테이프의 개수를 세기 위한 변수, 시작 위치에 테이프를 붙이는 것을 고려하여 1로 초기화

for i in range(0, len(arr)):  # 구멍의 위치를 하나씩 확인하며 테이프를 붙이는 과정
  if start< arr[i] < end:  # 이미 테이프로 막혀있는 구멍인 경우, 다음 구멍으로 이동
    continue
  else:  # 테이프로 막혀있지 않은 구멍인 경우
    cnt+=1  # 테이프 개수 증가
    start = arr[i]-0.5  # 시작 위치를 현재 구멍 위치 - 0.5로 설정
    end = start + l  # 끝 위치를 시작 위치 + 테이프의 길이로 설정

print(cnt)  # 최소한의 테이프 개수 출력

```