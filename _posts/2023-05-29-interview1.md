---
layout: single
title:  "[Interview] 면접 질문 정리"
categories: Business
tag: [web, server, DB, JPA, spring boot]
toc: true
toc_sticky: true
author_profile: false
sidebar:
    nav: "docs"
---

<br>

# 서론

고등학교 시절부터 코딩만 했지, 컴퓨터 지식이나 왜 이런 코드를 사용하는지, 코드가 어떻게 돌아가는지 등 전혀 알지 못했다.<br>
이제는 확실히 이쪽 분야로 진로를 정했기 때문에 앞으로의 미래와 우선 직면해 있는 면접을 준비하기 위해 CS 및 현재 사용하고 있는 코드, 프레임워크 등 찾아보면서 많은 공부를 했다.<br>
막상 면접이라 생각하고 공부한것들을 생각해 보니, 머리에 지식은 어느정도 들어있는데, 질문에 대한 답변이 쉽게 나오지 않아서, 정리할 겸 이 글을 작성한다.

## Http Method

Http Method에는 GET, POST, PUT, DELETE가 있습니다.<br>
GET은 클라이언트가 서버로부터 리소스를 요청하기 위해 사용하는 method이며, URL 형식으로 서버측에 리소스를 요청합니다.<br>
서버에 전달하고 싶은 데이터는 query parameter를 통해 전달.<br>
POST는 리소스를 생성/업데이트 하기 위해 서버에 데이터를 보내는 데 사용하는 method입니다.
GET방식은 URL의 쿼리 파라미터를 데이터를 전달하지만, POST방식은 메시지 바디를 통해 데이터를 전달합니다.

<br>

## Http 상태 코드

1xx는 요청이 수신되어 처리중, 2xx는 요청 정상 처리, 3xx는 요청 완료를 위해 추가 작업이 필요, 4xx는 클라이언트 오류, 5dxx는 서버 오류로 나뉩니다.<br>
가장 많이 사용하는 코드는 200, 404, 503등이 존재<br>
200은 요청이 성공적으로 완료되었음을 알리며, 404는 요청받은 리소스를 찾을 수 없을 때, 503은 서버가 일시적인 과부하 또는 작업으로 요청을 처리할 수 없을 때 사용.

<br>

## 프로세스와 스레드의 차이

프로세스는 컴퓨터에서 실행중인 프로그램 즉, 메모리 상에서 실행중인 작업을 의미하며, 스레드는 프로세스 안에서 실행되는 여러 흐름 단위를 말합니다.<br>
프로세스는 별도의 주소 공간과 자원을 할당받아 사용하지만, 스레드는 다른 스레드와 공간, 자원을 공유하면서 사용한다는 차이가 있습니다.

### 멀티 프로세스

하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 것

### 멀티 스레드

하나의 응용프로그램을 여러 개의 스레드로 구성하고, 각 스레드가 하나의 작업을 처리하도록 하는 것

### 멀티 프로세스 대신 멀티 스레드를 사용하는 이유

우선 프로세스는 각각 독립된 메모리 영역을 할당 해주기 때문에, 멀티 스레드를 사용함으로서 프로세스를 생성할때 자원을 할당하는 시스템 콜이 감소하여 자원의 효율적 관리가 가능하다.<br>
또한, Context Switching 과정에서 캐시 메모리 초기화 등 무거운 작업이 진행되는데, 멀티 스레드는 Context Switching 시 Stack 영역만 처리하면 되기 때문에 비교적 가볍다.
<br>
그리고, 프로세스는 각각 독립된 메모리 영역을 할당 받아, 프로세스 사이에 공유하는 메모리가 없어, Stack 영역을 제외한 메모리를 공유하는 스레드보다 통신 비용이 비싸다.

### Context Switching

동작중이던 프로세스가 대기하면서, 해당 프로세스의 상태를 보관하고, 대기하고 있던 다음 순번의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 과정.<br>
CPU가 이전 프로세스 상태를 PCB에 보관하고, 다른 프로세스가 실행될 때, PCB에서 프로세스의 정보를 읽어 레지스터에 적재하는 과정.

### PCB

프로세스가 여러개 일 경우 CPU는 각 프로세스가 누구인지 알아야 관리가 가능한데, 이때 프로세스들의 특징을 가지고 있는 것이 `Process MetaData`이다.<br>
`PCB(Process Control Block)`는 이 메타 데이터들을 저장해 놓는 곳이다.

<br>

## RDB와 NoSQL의 차이

관계형 DB는 정해진 스키마가 존재하고, NoSQL은 정해진 스키마가 없다는 것이 가장 큰 차이점.<br>
NoSQL은 정해진 스키마가 없기 때문에 관계형 DB처럼 여러 테이블에 나누어 담지 않고, 관련 데이터를 동일한 '컬렉션'에 넣는다.<br>
NoSQL은 스키마가 없어서 유연하다는 장점이 있지만, 데이터 중복에 대한 문제가 발생한다는 단점이 존재합니다.

<br>

## DB에서 인덱스를 사용 시 장점

DB 인덱스를 잘 사용하는 것은 데이터를 검색하는 시점에 큰 성능 차이가 존재합니다.<br>
만약, 대용량 데이터를 담고 있는 DB에서 인덱스가 없을 경우 테이블 전체를 읽어야 하기에 데이터 조회 시간이 오래걸린다.<br>
인덱스는 DB 데이터의 주소를 의미하며, 원하는 데이터를 빠르게 찾을 수 있다는 장점이 존재.

### 인덱스 단점

데이터 변경이 자주 일어나는 경우, Index를 재작성해야 하므로 성능에 영향을 준다.

<br>

## GC

GC는 프로그래머가 동적으로 할당한 메모리 영역 중 더 이상 사용하지 않는 메모리 영역을 찾아서 해제하는 기능.<br>
자바 메모리는 Young, Old, Permanet 세 영역으로 나뉘는데, 중요한 건 Young, Old 영역이다.<br>
Young 영역은 생성된지 얼마 안된 객체들을 저장하는 장소고, Old 영역은 생성된지 오래된 객체들을 저장하는 장소로, Young 영역은 다시 eden과, survivor 두 영역으로 나뉜다.<br>
Young 영역에서는 Minor GC, Old 영역에서는 Full GC가 발생.

### Minor GC

- 자바 객체가 생성되면 eden 영역에 저장되는데, eden 영역이 가득 차게 되면 Minor GC가 발생.
- 이때 참조되는 객체들은 Survivor 영역으로 이동하게 되고, 나머지 객체들은 eden Space가 clear될 때 반환.
- Survivor 영역은 다시 Survivor1, Survivor2로 나뉘게 되는데, Minor GC가 발생하면 eden, Survivor1에서 참조되는 객체들을 Survivor2로 복사하고, age를 1씩 증가시킨다.
- 나머지 객체들은 eden space, s1이 clear될 때 반환.
- 이런 과정이 반복되고, Survivor 영역에서 오래된 객체 즉, 일정 age를 넘은 객체는 Old 영역으로 이동하게 된다.
- Minor GC는 자주 일어나기 때문에, 시간이 짧은 알고리즘이 적합하다.

### Full GC

- Old 영역에서 발생하는 GC를 Full GC라고 하며, 사용되는 알고리즘을 `Mark & Compact`라고 한다.
- `Mark & Compact` 알고리즘은 객체들의 참조 여부를 확인하면서 참조되지 않는 객체들을 표시한다.
- 표시된 객체들을 제거하고, 메모리를 반환해준다.
- 퍼포먼스 향상을 위해 남은 객체들을 묶어서 새로운 메모리 할당 시 빠르게 진행할 수 있도록 한다.

### GC 튜닝

Minor GC는 빠르게 진행되기 때문에 문제가 없지만, Full GC의 경우 시간이 좀 더 걸려 `stop-the-world` 즉, GC를 실행하기 위해 자바 애플리케이션이 멈춰버리기 때문에 문제가 될 수 있다.<br>
따라서, 원활한 서비스를 위해서는 `stop-the-world`의 시간을 줄이는 것이 관건이다.

#### 방법

- Full GC가 일어나는 횟수가 많아서 Old 영역을 늘려주면, Full GC가 일어나는 횟수는 줄어들지만, Full GC 수행 시간이 늘어나게 된다.
- Full GC가 적게 일어나면서, 시간을 줄이려면 Old 영역을 줄이고, 여러 개의 인스턴스를 동시에 띄워서 로드 밸런싱을 해주면 된다.
- 하나의 서버 인스턴스가 멈춰있는 동안 로드 밸런싱이 되는 다른 서버가 응답하고 있기 때문에 Full GC로 인하여 애플리케이션이 멈춰서 받는 영향을 최소화 할 수 있다.