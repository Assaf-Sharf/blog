---
---
layout: single
title:  "문자열 압축Lv2"
categories : java

tag : [Lv2, 프로그래머스]

![문제1](../../images/2022-05-29-pre/문제1.png)

![문제2](../../images/2022-05-29-pre/문제2.png)

    import java.util.ArrayList;
    import java.util.Collections;
    
    class Solution {
        public int solution(String s) {
            int answer = 0;  
    	//문자열 길이가 홀수, 짝수 무관하게 반절까지만 하면 된다.
        int maxnum = (s.length()==1) ? 1 : s.length()/2;
        ArrayList<Integer> common_factor = new ArrayList<Integer>();
                
        for(int i=1; i<=maxnum; i++)
        {
            common_factor.add(i);
        }    
        //여기까지는 정상적으로 동작되는거 확인했다.
     
        //각각의 단위로 짤랐을 때 문자열의 길이를 저장할 어레이 리스트
        ArrayList<Integer> num = new ArrayList<Integer>();
    
         for(int j : common_factor)
         {
             //전체 문자열의 길이
             int max = s.length();
             
             //줄어들 문자열의 길이
             int minus = 0;
             
             //일정하게 나누이절 부분의 개수
             int quo = s.length() / j;
             
             //나뉜 부분이 반복되는 횟수
             int cont_num = 1;
             
             //연속된 여부 판별
             boolean consec = false;    
             
             String former ="";
             String latter ="";
    
            if(quo > 1)
            {        
                 for(int k = 0; k<(quo-1) * j; k=k+j)
                 {
                     former = s.substring(k, k+j);                 
                     latter = s.substring(k+j, k+2*j);
    
                     //자른 문자열의 뒤가 앞의 것과 같은 경우
                     if(latter.equals(former))
                     {
                        cont_num +=1;
    
                        //latter가 맨 마지막인지 물어보는 if문
                        if(k+2*j == quo * j)
                        {
                           //반복횟수 표시에 따른 증가된 문자열 길이
                           int incre = 0;
                           while(cont_num !=0)
                           {
                               cont_num = cont_num/10;
                               incre +=1;
                           }
                           minus -=(j-incre); 
                        } 
                        else
                        {
                           minus -=j; 
                        }
                        consec = true;
                     }
    
                     //자른 문자열의 뒤가 앞의 것과 다르나
                     //이전의 문자열과 그 앞의 것이 연속될 경우
    
                     else if(consec)
                     {
                         int incre = 0;
                           while(cont_num !=0)
                           {
                               cont_num = cont_num/10;
                               incre +=1;
                           }
                         cont_num =1;
                         minus += incre;
                         consec = false;
                     }                  
                 }  
            }
             num.add(max + minus);
         }       
        answer = Collections.min(num);
        return answer;
    }
}
