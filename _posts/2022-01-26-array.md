---
layout: single
title:  "배열관련 문제 "
categories: Array
tag: [c++,python,Algorithm,LeetCode,Array,moveZeros,Find pivot index,Minimum size subarray sum,Merge sorted Array,Find peak element,Merge intervals ,Shortest Unsorted continuout subArray ,Find duplicate number ,Two sum,Rotate Image 2D array ,search 2D matrix]
toc: true
author_profile: false
sidebar:
  nav : "docs"
search: true
---

### Intro

풀어볼 문제는 총 11한 문제입니다. 링크 달았으니까 참고 자세한 문제 설명은 참고하시면 될것같습니다.

이번 포스트에서는 총 11한 문제에 대한 저의 코드와 생각들을 정리합니다. 

내용이 길어질수있으니 문제 목록을 참고하셔서 필요한 부분만 보는것을 추천합니다. 


### 배열 정리 

읽기를 할때 가장 효율이 좋은 자료 구조인 것 같습니다. 
첫 주소를 알고 있으므로 index만 안다면 한 단계로 읽을수있다는 장점이 있습니다. 

삽입을 할 때 또한 마지막 요소에 삽입하는 경우 한 단계로 삽입할수있습니다. 
하지만 요소를 앞 또는 중간에 삽입 , 검색, 삭제 하는 경우 최대 N의 시간이 걸릴수있습니다. 


배열 문제를 풀때는 index를 다루는 것에 익숙해질 필요가 있었습니다. 


### 풀어볼 문제 링크 LeetCode

[1번_moveZeros](https://leetcode.com/problems/move-zeroes/)
{: .notice--danger}


[2번_Find_pivot_index](https://leetcode.com/problems/find-pivot-index/)
{: .notice--danger}


[3번_Minimum_size_subarray_sum](https://leetcode.com/problems/minimum-size-subarray-sum/)
{: .notice--danger}

[4번_Merge_sorted_Array](https://leetcode.com/problems/merge-sorted-array/)
{: .notice--danger}

[5번_Find_peak_array](https://leetcode.com/problems/find-peak-element/)
{: .notice--danger}

[6번_Merge_Intervals](https://leetcode.com/problems/merge-intervals/)
{: .notice--danger}

[7번_Shortest_Unsorted_continuout_subArray](https://leetcode.com/problems/shortest-unsorted-continuous-subarray/)
{: .notice--danger}

[8번_Find_duplicate_number](https://leetcode.com/problems/find-the-duplicate-number/)
{: .notice--danger}

[9번_Two_sum](https://leetcode.com/problems/two-sum/)
{: .notice--danger}

[10번_Rotate_Image_2D_array](https://leetcode.com/problems/rotate-image/)
{: .notice--danger}

[11번_search_2D_matrix](https://leetcode.com/problems/search-a-2d-matrix/)
{: .notice--danger}



###  1 번 moveZeros


다른 배열을 copy해서 처리 하면 더 쉽게 풀리지만, 문제에서 Space Complex가 상수로 해결 하라는 조건이 있습니다. 

그래서 입력된 배열을 그대로 출력 공간을 사용해야합니다. 

0을 만날때 마다 배열에서 삭제 /삽입하는 것은 배열에서 효율적이지 않습니다. 

문제의 핵심은 0을 가리키는 index1, 0이 아닌 요소 가리키는 index2 두개의 index설정하는 것입니다. 


* c ++ 코드
```c++

class Solution {
public:
    void moveZeroes(vector<int>& nums) 
    {
        //0을 가리키는 index       
        int idx = 0;

        for (int i = 0; i < nums.size(); i++)
        {
            if (nums[i] != 0)
            {
                swap(nums[idx], nums[i]);
                idx++;
            }
        }
    }
};

```

--------------------------------------------------------------------



### 2번 Find pivot index 

pivot 기준으로 왼쪽 합과 오른쪽 합이 같이지는 index를 반환하는 문제입니다. 

우리가 문제에서 찾아내야하는 것은 pivot index입니다. 배열 처음 부터 pivot index인지 볼것이기 때문에 
pivot index기준 왼쪽 합과 오른쪽의 합을 알아야합니다. 

pivot index는 배열 처음 부터 시작하므로 

//초기화 조건 
left_sum =0;
right_sum = 배열의 총합으로 초기화 할 수 있습니다.

* c++ 코드
```c++
class Solution {
public:
    int pivotIndex(vector<int>& nums) 
    {
        //배열의 총합을 구한다
        int total = accumulate(nums.begin(), nums.end(), 0);
        
        //초기화 
        int left_sum = 0;
        int right_sum = total;
        int prev = 0;
        
        for (int i = 0; i < nums.size(); i++)
        {
            right_sum -= nums[i];
            left_sum += prev;

            if (left_sum == right_sum)
            {
                return i; //pivot index 
            }
            prev = nums[i];
        }

        //pivot index없는 경우 
        return -1;
    }
};

```

* python 코드
```python
class Solution(object):
    def pivotIndex(self, nums):

        """
        :type nums: List[int]
        :rtype: int
        """
        total_sum = sum(nums)

        right_sum = total_sum
        left_sum = 0

        for idx, num in enumerate(nums):
            right_sum -= num
            if left_sum == right_sum:
                return idx
            left_sum += num

        return -1
```

-------------------------------------------------------------------------

### 3번  Minimum Size Subarray Sum

연속된 배열의 합 == target 중에서 길이가 가장 짧은 길이를 구하는 문제입니다. 

연속된 subArray의 합을 구하는 것이므로 진행 방향은 첫 요소 부터 진행하다가 
조건이 안맞으면 다음 요소 즉 두번째 요소부터 진행하는 방식으로 진행합니다. 두 번째 요소부터 시작할때 다시 더 헤줄 필요없이 첫번째 요소의 element만 빼주면 두 번째 element부터 더한것을 유지 할 수 있습니다.

그리고 값이 target과 같아지거나 커지면 그때의 길이를 min함수로 업데이트합니다. 


* c++ 코드 

```c++
int minSubArrayLen(int target, vector<int>& nums)
{
	int left = 0;
	int right = 0;
	int sum = 0;
	int len = INT_MAX;

	while (right < nums.size())
	{
		sum += nums[right];
		
		while (sum >= target) //right고정 될때 left 가 조절되어야하기 때문이다 
		{
			len = min(len, right - left + 1);
			sum -= nums[left];
			left++;
		}
		right++;
	}

  //len이 초기값과 같다면 0 반환한다 
	return (len==INT_MAX) ? 0 : len;
}
```

--------------------------------------------------------------------------------------------


### 4번 Merge Sorted Array

두 개의 배열이 주어졌을때 하나의 정렬된 배열로 합치는 문제입니다. 

arr1 = {1,3,5,0,0,0}
arr2 = {2,4,8}

arr1에 정렬한 결과물을 넣어야 합니다. 새로운 배열 생성 하면 안됩니다. 

Time : O(n+m)
Space : O(1)     -> arr1을 반환하기 때문입니다 

##### Hint
**0이 아닌 요소 index부터 비교를 시작해서 값이 큰 값 먼저 arr1배열 끝에 삽입합니다.**


만약 merge sort를 직접 구현 하고 배열을 합친다면 
Time : O(nlogn)의 복잡도로 구현 할 수 있습니다.


* c++ 코드 

```c++
class Solution
{
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n)
    {


        int arr1_size = m - 1;    //숫자 끝 부분 
        int arr2_size = n - 1;    
        int idx = m + n - 1;      //arr1의 끝 부분 
        while (arr2_size >= 0)
        {
            if (arr1_size >= 0 && nums1[arr1_size] >= nums2[arr2_size])
            {
                nums1[idx] = nums1[arr1_size];
                idx--;
                arr1_size--;

            }
            else
            {
                nums1[idx] = nums2[arr2_size];
                arr2_size--;
                idx--;
            }
        }
    }
};
```

* python 코드 

```python 
class Solution(object):
    def merge(self, nums1, m, nums2, n):
        """
        :type nums1: List[int]
        :type m: int
        :type nums2: List[int]
        :type n: int
        :rtype: None Do not return anything, modify nums1 in-place instead.

        """
        idx = m + n - 1
        l_1 = m - 1
        l_2 = n - 1

        while l_2 >= 0 and l_1 >= 0:
            if nums2[l_2] > nums1[l_1]:
                nums1[idx] = nums2[l_2]
                l_2 -= 1

            else:
                nums1[idx] = nums1[l_1]
                l_1 -= 1
            idx -= 1
```

----------------------------------------------------------------------------------------------


### 5번 Find Peak Element


문제에서 O(log N)으로 해결해야한다는 조건이 있습니다. 

O(log N)이면 binary search를 생각해 볼수있습니다. 

전체적으로 정렬이 되어있지 않지만 찾으려는 peek element 기준으로

1. left_element < peek element < right element 와 같이 정렬이 유지 되고 있음을 알 수 있습니다. 

2. 찾으려는 값은 peek element입니다



그래서 binary serarch 구현과 비슷하게 코드를 구성 하면 아래와 같습니다. 



* c++ 코드 

```c++
class Solution {
public:
    int findPeakElement(vector<int>& nums) 
    {
        //배열 크기가 1보다 작으면 0을 반환
        if (nums.size() <= 1)
        {
            return 0;
        }

        //index초기화 합니다
        int left = 0;
        int right = nums.size() - 1;

        //가운데 기준으로 peek element 찾는다 -> binary search 
        while (left < right)
        {
            int pivot = (left + right) / 2;
            if (nums[pivot] < nums[pivot + 1])
            {
                left = pivot + 1;
            }
            else
            {
                right = pivot; //right도 포함해야한다 
            }
        }
        return left;
    }
};
```


--------------------------------------------------------------------------------------------------------


### 6번 Merge Intervals

문제 이름대로 구간을 범위에 맞추어서 합치는 문제입니다. 


intervals where intervals[i] = [starti, endi]

구간은 위와 같이 start,end 순으로 입력이 됩니다 

구간을 합치려면 end_first ,start_second 두개를 비교해서 구간을 합쳐야 한다는것을 알수있습니다. 

이렇게 진행을 하면 모든 요소를 다 비교를 해주어야 하기 때문에 O(n^2)이 걸립니다. 

하지만 start중심으로 정렬을 한다면 O(NlogN+M)으로 해결 할수있을것입니다. 
왜냐하면 일일이 다 살펴 볼 필요없이 진행 할 수 있기 때문입니다. 


* c++ 코드 

```c++
class Solution {
public:
	vector<vector<int>> merge(vector<vector<int>>& intervals)
	{
    //start 기준으로 정렬 
		sort(intervals.begin(), intervals.end());
		int idx = 0;
		for (int i = 1; i < intervals.size(); i++)
		{

	
				if (intervals[idx][1] >= intervals[i][0])
				{
          //조건이 맞으면 구간을 합친다
					intervals[idx][1] = max(intervals[i][1], intervals[idx][1]);

				}
				else
				{
					idx++;
					intervals[idx] = intervals[i];
				}
			
		}
		
    //합쳐서 줄어든 만큼 pop하는 코드 
		while (intervals.size() != idx+1)
		{
			intervals.pop_back();
		}


		return intervals;
	}
};
```


* python 코드 

```python 
class Solution(object):
    def merge(self, intervals):
        """
        :type intervals: List[List[int]]
        :rtype: List[List[int]]
        """

        #첫요소 기준으로 정렬하는 코드 
        intervals.sort(key=lambda x:x[0])
        
        idx =0
        for i in range(1,len(intervals)):
            if intervals[idx][1]>=intervals[i][0]:
                intervals[idx][1]=max(intervals[idx][1],intervals[i][1])

            else:
                idx+=1
                intervals[idx]=intervals[i]

        while(len(intervals)!=idx+1):
            intervals.pop()

        return intervals

```


------------------------------------------------------------------------------------------------------


### 7번 Shortest Unsorted Continuous Subarray

이번 문제 같은 경우는 정렬을 이용해서 문제를 해결하셔도 되지만 
TIME 은 O(NlogN)이 걸릴것입니다. 만약 TIME 을 O(N)으로 해결하고 싶다면 그래프를 그려보고 경향성을 따져 보아야합니다. 

LeetCode에 있는 Solution중 stack을 이용해서 푼 방법이 있는데 그 풀이 방식이 경향성을 따지고 푼 방식입니다. 
하지만 저의 코드는 stack을 이용하는 대신 반복문을 이용해서 문제를 해결했습니다. 

* c++ 코드 

```c++

class Solution {
public:
	int findUnsortedSubarray(vector<int>& nums) 
	{
		if (nums.size() < 2)
		{
			return 0;
		}

		int end = 0;
		int prev = nums[0];

		//꺽이는 시작점 찾기 O(n)
		for (int i = 0; i < nums.size(); i++)
		{
			if (nums[i] < prev)
			{
				end = i;
			}
			else
			{
				prev = nums[i];
			}
		}

		int start = nums.size() - 1;
		prev = nums[start];

		//꺽이는 끝지점 찾기 O(n) 
		for (int i = nums.size() - 1; i >= 0; i--)
		{
			if (nums[i] > prev)
			{
				start = i;
			}
			else
			{
				prev = nums[i];
			}
		}

		if (end != 0)
		{
			return end - start + 1;
		}
		return 0;

	}
};
```


------------------------------------------------------------------------------------------------------


### 8번 Find Dupicate


중복된 숫자를 찾는 문제입니다. Hash Map을 이요해서 풀면 쉽게 문제를 해결 할 수 있습니다.

하지만 SPACE를 O(N)으로 해결 해야한다면 Hash Map을 사용 할 수 없게 됩니다. 이런 경우에는 +/- 성질을 이용해서 문제를 풀면 좋습니다. 

입력으로 오는 배열의 값에 -1을 곱해줍니다. 만약 중복된 값이 있다면 음수는 양수가 될것입니다. 그러면 중복된 값을 찾게 된것이니 반환해주면 됩니다. Hash Map을 이용한 풀이와 사용하지 않은 풀이 코드는 아래와 같습니다. 


* c++ Hash Map 사용한 코드
```c++
class Solution {
public:
	int findDuplicate(vector<int>& nums) 
	{
        //
		if (nums.size() == 0)
		{
			return 0;
		}
		unordered_map<int, int> map;

		for (int i = 0; i < nums.size(); i++)
		{
			
			if (map.find(nums[i]) != map.end())
			{
				return nums[i];
			}
			map[nums[i]]++;
		}

	}
};
```

* c++ Hash Map 사용하지 않은 코드 

```c++
class Solution {
public:
    int findDuplicate(vector<int>& nums) 
    {
        for(int i=0;i<nums.size();i++)
        {
            
            int temp = nums[i];
            if(temp<0)
            {
                temp*=-1;
            }
            int tmep_pos = temp -1;
            
            nums[tmep_pos] = nums[tmep_pos]*-1;
            
            
            
            if(nums[tmep_pos]>0)
            {
                return tmep_pos+1;
            }
        }
        return -1;
        
    }
};

```

------------------------------------------------------------------------------------------------------

### 9번 Two Sum 

이번 문제는 two pointer를 이용해서 푸는 문제입니다. 배열에 대한 감을 잡기 좋은 문제입니다. two sum 뿐만아니라 3,4,..N sum 문제 또한 LeetCode에 있으니까 필요하신 분은 찾아서 풀어보는것을 추천합니다. 


**풀이 방법**
1. 정렬을 이용해서 푸는 방법

    * 정렬을 하고 양쪽의 two pointer를 잡아서 target을 찾을수있습니다. 

2.  hash map을 이용해서 푸는 방법

    * Hash map key : target - arr[n]
      Hash map value: index 

    * 해당 값을 찾으면 반환 한다



정렬을 이용해서 문제를 푸신다면 , 한 가지 주의 할 점은 바뀐 index가 아니라 입력한 배열 index 그대로 유지를 해야한다는 점입니다. 
정렬 하기 전에 입력 배열의 index를 따로 저장을 하고 two sum 풀이를 이어나가야 합니다.


Hash map을 이용한 풀이에서 핵심은 target - arr[n]을 key값으로 넣는 것 입니다. 만약 key값이 hash map에 있다면 그 값이 우리가 찾는 값입니다.  

* c++ 코드 정렬 사용 

```c++
class Solution {
public:
	vector<int> twoSum(vector<int>& nums, int target) 
	{
		//정렬 되었을때 index 유지 하기 위함이다
		vector<pair<int, int>> temp;    //first -> nums 요소 second -> index 

		for (int i = 0; i < nums.size(); i++)
		{
			temp.emplace_back(make_pair(nums[i],i));

		}

		//first인 nums[i]기준으로 정렬 
		sort(temp.begin(), temp.end());


		int idx = 0;
		int idx2 = nums.size() - 1;

		int start = 0, end = 0;

		while (idx < idx2)
		{
            //nums 배열의 요소로 비교 
			if (temp[idx].first + temp[idx2].first == target)
			{
				//정렬하기 전의 index를 유지한다
				start = temp[idx].second;
				end = temp[idx2].second;
				break;
			}

			if (temp[idx].first + temp[idx2].first > target)
			{
				idx2--;
			}
			else
			{
				idx++;
			}
		}


		return {start,end};

	}
};

```

* c++ 코드 Hash map 사용 

```c++
class Solution 
{
public:
    vector<int> twoSum(vector<int>& nums, int target) 
    {
        
        // Hash map 사용 
        unordered_map<int,int> hash;    //key : target-num[i]  value: index 

        vector<int> result;
        for(int i=0;i<nums.size();i++)
        {
            if(hash.find(nums[i])!=hash.end())
            {
                result.emplace_back(hash[nums[i]]);     //hash 의 index     
                result.emplace_back(i);                 // 중복된 값을 찾았을때의 index 
                
                return result;
            }
            hash.emplace(target-nums[i],i);
        }
        return result;
    }
    
};
```


------------------------------------------------------------------------------------------------------


### 10번 Rotate Image 2D array 


이번 문제는 2차원 배열에 대한 감을 찾기 좋은 문제입니다. 

n*n 2차원 행렬을 90도 회전한 모습을 출력하는 문제입니다. 
*단, 또다른 2차원 행렬의 공간을 만들어서는 안됩니다. 입력으로 들어온 matrix를 그대로 return 해야합니다.* 

4개의 지점이 같이 움직인다고 생각하면 이해하기 쉬울것입니다. 

n*n img matrix 

a b         c a
        -> 
c d         d b

int temp = img[b]
img[b] = img[a]
img[a] = img[d]
img[d] = img[c]
img[c] = temp


* c++ 코드 
```c++

void Rotate_img(vector<vector<int>>& arr)
{
    //n-1
	int len = arr[0].size()-1;
    
    //반절의 길이만큼 반복
	for (int row = 0; row < arr.size() / 2; row++)
	{
		for (int col = 0; col < (arr.size() + 1) / 2; col++)
		{

            
			int temp = arr[len - col][row];

			arr[len - col][row] = arr[len - row][len - col];
			arr[len - row][len - col] = arr[col][len - row];
			arr[col][len - row] = arr[row][col];
			arr[row][col] = temp;

		
		}
	}
}

```

------------------------------------------------------------------------------------------------------

### 11번 Search a 2D Matrix I 


문제 설명을 간단히 해보면 

M*N 행렬이 다음과 같다고 하면 

| 1    | 3    | 5    | 7    |
| ---- | ---- | ---- | ---- |
| 10   | 11   | 16   | 20   |
| 23   | 30   | 34   | 60   |


1. 각 행은 정렬되어있다 

    * 1 3 5 7 , 10 11 16 20 등 각 행은 정렬되어있다 

2. 각 행의 첫 요소는 이전 행의 마지막 숫자보다 크다 

    * 10은 7보다 크고 23은 20보다 크다 



이런 행렬일때 target값이 행렬안에 있는지 없는지 T/F 로 출력하면 되는 문제입니다. 


저는 처음에 2번의 규칙을 활용해서 문제를 풀었습니다. 만약 target이 행의 마지막 요소보다 작다면 그 행에서 target을 찾으면 됩니다. 

아래는 직관적으로 문제를 푼 코드 입니다. 

* c++ 코드 직관적인 풀이 version 

```c++
class Solution {
public:
	bool searchMatrix(vector<vector<int>>& matrix, int target)
	{
		//base case
		if (matrix.size() == 0 || matrix[0].size() == 0)
		{
			return false;
		}

		int end = matrix[0].size()-1;   //각 행의 크기 

		for (int i = 0; i < matrix.size(); i++)
		{
            //각 행의 마지막 요소가 target보다 같거나 크면   -> 2번 규칙을 활용한 것입니다. 
			if (matrix[i][end] >= target)
			{
                //해당 row에서 target요소를 찾는다 만약 찾았다면 true 반환 
				if (matrix[i].end() != find(matrix[i].begin(), matrix[i].end(), target))
				{
					return true;
				}
			}
		}
		return false;

	}
};
```


위의 풀이도 통과하는 방식이지만 조금 더 보안해서 문제를 풀수도 있습니다. 

* 1번 규칙과 2번 규칙을 다시 한번 봅시다.
    * 1번 규칙을 통해 각 행은 정렬이 보장 되어있습니다. 
    * 2번 규칙을 통해 전의 행보다 지금의 행이 더 큰 값을 가지고 있음을 보장합니다 

1 번과 2번을 통합해서 생각해보면 전체적으로 보았을때 오름차순 정렬 경향성이 보장 되어있음을 알수있습니다. 

이런 상황에서 target값을 찾는 문제 .... 이제 감이 오시나요? .......



Binary Search를 이용하기 적절한 상황임을 알수있습니다.  2차원 배열을 1차원 배열로 늘려서 생각 해봅니다. 

아래는 Binary Search로 문제를 푼 c++ 코드입니다. 


* c++ Binary Serach 이용한 풀이 

```c++
class Solution 
{
public:
	bool searchMatrix(vector<vector<int>>& matrix, int target) 
	{
		//base case 

		if (matrix.size() == 0 || matrix[0].size() == 0)
		{
			return false;
		}

        //Initialize m*n size matrix 
		int m = matrix.size();
		int n = matrix[0].size();

        
        //2차원 배열을 1차원 배열로 생각 했을때 길이입니다. 
		int left = 0;
		int right = n * m - 1;


		while (left <= right)
		{
            //mid = (left+right) / 2 와 동일합니다 OverFlow를 막기 위한 수학적 꼼수라고 생각하시면 좋습니다. 
			int mid = left + (right - left) / 2;

			if (matrix[mid / n][mid % n] == target)
			{
				return true;
			}
			else if (matrix[mid / n][mid % n] > target)
			{
				right = mid - 1;
			}
			else
			{
				left = mid + 1;
			}
		}
		return false;

	}
};
```

* 위의 코드에서 핵심
    * 2차원 배열을 1차원 배열로 보기 
    * "mid / n", "mid % n" 이해하기 
        * mid는 2차원을 1차원으로 늘린것이므로 n size로 나누어서 몫과 나머지를 구하면 2차원 배열로 생각했을 때의 index를 구할수있습니다.


------------------------------------------------------------------------------------------------------

### 12번 Search a 2D Matrix II

11번 문제와 거의 똑같은 문제인데 2번의 규칙만 달라진 문제입니다. 


**바뀐 2번 규칙** 

각 열은 정렬되어있다. 


바뀐 2번 규칙을 사용해서 위에서 풀었던 문제를 풀면 됩니다. 

바뀐 2번 규칙 때문에 처음에 직관적으로 풀이는 더 이상 사용 할 수 없습니다. 
또한 전체적으로 상승하는 경향성도 아니기 때문에 Binary Search도 사용 할 수 없습니다. 

예제 행렬) 

| 1    | 4    | 7    | 11   | 15   |
| ---- | ---- | ---- | ---- | ---- |
| 2    | 5    | 8    | 12   | 19   |
| 3    | 6    | 9    | 16   | 22   |
| 10   | 13   | 14   | 17   | 24   |
| 18   | 21   | 23   | 26   | 30   |


이번 문제 또한 2번 규칙의 성질을 잘 활용해서 문제를 풀어야 합니다.

앞에 문제를 풀었던 것 처럼 1번 규칙과 2번 규칙을 통해 해결 방안을 생각해 보겠습니다. 

**각 행과 열은 각각 정렬 되어있다** 

만약에 찾는 target이 16이라고 생각 해봅시다 

18 요소에서 탐색을 시작해봅시다. 

그러면 각 행과 열은 각각 정렬 되어 있다는 사실 덕분에 

* *18이 포함된 행*
    즉 18 21 23 26 30 에는 찾는 target이 없다는것을 보장 할수있습니다.

그러면 행을 올릴수 있습니다.  다시 10요소에서 target을 찾기를 반복합니다. 

10은 16 보다 작습니다. 그러면 찾는 target은 10이 포함된 열에 포함이 되지 않았음을 보장 할 수 있습니다.

그러면 13으로 넘어 갈 수 있습니다. 즉 다음 열로 이동을 할수있습니다. 

이 원리를 이용해서 코드를 작성 하면 아래와 같습니다. 

* c++ 코드 

```c++
class Solution 
{
public:
	bool searchMatrix(vector<vector<int>>& matrix, int target) 
	{
        //matrix[m][0]에서 탐색을 시작 하기 위한 초기화 
		int m = matrix.size() -1;
		int idx = 0;

		while (m >= 0 && idx<matrix[0].size())
		{
            //값을 찾았다면 true 반환 
			if (matrix[m][idx] == target)
			{
				return true;
			}
			else if (matrix[m][idx] > target)   //target보다 크다면 행이동을 합니다.
			{
				m--;
			}
			else                                //아닌 경우는 열 이동을 합니다. 
			{
				idx++;
			}
		}



		return false;
	}
};
```



### 마무리 

지금까지 배열 기초 문제를 몇개 풀어보았는데요 
도움이 되었을지 궁금하네요.. 풀었던 문제라고 나두지 말고 배열 문제 풀기전에 한번씩 보면 도움이 될것입니다. 
저도 처음에는 완전히 제것이 안되어서 여러번 경험이 있네요 물론 지금도 그렇지만 보다보면 언젠가는 도움이 될것이라고 생각합니다. 

긴 글 읽어 주셔서 감사합니다 . 다음 포스팅 문자열에서 만나요~ 

