---
layout: single
title: "[HTTP] 일반헤더 콘텐츠 협상과 전송 방식"
categories: HTTP
tag: [HTTP, network]
toc: true
author_profile: false
# sidebar:
#   nav: "docs"
---

## ✔ 콘텐츠 협상(Content Negotiation)

- 클라이언트가 선호하는 표현 요청:
  - Accept: 클라이언트가 원하는 미디어 타입 전달
  - Accpet-Charset: 클라이언트가 원하는 문자 인코딩
  - Accept-Encoding: 클라이언트가 원하는 압축 인코딩
  - Accept-Language: 클라이언트가 원하는 자연 언어
  - 협상 헤더는 요청시에만 사용
- 클라언트가 원하는 방식으로 서버에 요청하는 방식

### Accept-Language 적용 전

```shell
GET /event
Accept-Language: ko
```

- 한국어 브라우저를 사용하는 클라이언트 측에서 서버에 요청을 보낸다

```shell
Content-Language: ko
안녕하세요
```

- 다중 언어를 지원하는 서버는 Accept-Language를 보고 언어에 맞는 데이터 반환

### Accept-Language 복잡한 예시

```shell
GET /event
Accept-Language: ko
```

- 한국어 브라우저를 사용하는 클라이언트 측에서 서버에 요청을 보낸다

```shell
Content-Language: ko
Hallo (독일어)
```

- 다중 언어를 지원하는 서버는 Accept-Language를 보고 언어에 맞는 데이터 반환
  - 하지만 요청을 반환하는 서버의 기본 언어가 독일어로 설정 되있는 상황
  - 요청은 한국어로 들어왔지만, 독일어를 반환하게 된다

### 협상과 우선순위 (Quality Values(q))

```shell
GET /event
Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
```

- Quality Values(q) 값 사용
- 0~1, 클수록 높은 우선순위를 갖는다
- 생략하면 1
- Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
  - ko-KR;q=1 (qulity 값이 생략됬다)
  - ko;q=0.9
  - en-US;q=0.8
  - en:q=0.7
- 제한적인 언어를 제공하는 서버에서 Accept-Language의 q(Quality)값을 확인하여 데이터를 반환한다.
- ex) 요청을 보내는 클라이언트측은 ko(한국어)를 요청하였지만 요청을 받는 서버는 기본값이 독일어인 경우.

### 협상과 우선순위 (Quality Values(q))

```shell
GET /event
Accept: text/*, text/plain, text/plain;format=flowed, */*
```

- 구체적이거나 가장 디테일한 표현이 우선순위가 높다
- Accept: text/\*, text/plain, text/plain;format=flowed, _/_
  - text/plain;format=flowed (우선순위:1)
  - text/plain (우선순위:2)
  - text/\* (우선순위:3)
  - _/_ (우선순위:4)

## ✔전송 방식 설명

- 데이터 전송방식:
  - 단순 전송
  - 압축 전송
  - 분할 전송
  - 범위 전송

### 단순 전송

```shell
GET /event
```

- 단순 전송은 Content-Length를 알고있는 경우의 전송 방식

```shell
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF=8
Content-Length: 3423

<html>
  <body>...</body>
</html>
```

- Content-Length를 반환 해준다

### 압축 전송

```shell
GET /event
```

- 압축 전송은 서버 측에서 데이터를 압축하여 반환해주는 전송 방식

```shell
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF=8
Content-Encoding: gzip
Content-Length: 3423

ldjjddieodkkdd12321313sadasdasdasdasdsadsad
```

- Content-Encoding에 압축 형식을 지정하여 응답한다

### 분할 전송

```shell
GET /event
```

- 분할 전송은 서버 측에서 데이터를 Byte 단위로 분할하여 전송하는 방식

```shell
HTTP/1.1 200 OK
Content-Type: text/plain
Transfer-Encoding: chunked

5 byte
Hello
5 byte
Wolrd
0
\r\n
```

- 서버측에 5byte 데이터를 보낸 후 클라이언트에서 처리가 완료되면 다음 처리 수행
- 각각의 데이터를 분할하여 전송하며, Content-Length를 넣어서 반환하면 안된다

### Chunked Transfer encoding

- chunked 인코딩 전송 방식은 HTTP 1.1 version에서 사용 가능하는 스트리밍 데이터 전송 방식
- chunked 인코딩 방식에서 데이터는 각각의 덩어리로 구분
- 각 덩어리들은 독립적으로 송/수신
- 각 chunked 앞에는 해당 chunk의 크기가 온다. 형식은 byte

### 범위 전송 (Range, Content-Range)

```shell
GET /event
```

- 범위 전송은 서버 측에서 데이터를 Byte 단위의 범위를 지정하여 전송하는 방식

```shell
HTTP/1.1 200 OK
Content-Type: text/plain
Content-Range: bytes 1001~2000 / 2000

qweqweskd123123saskskkdkdjfjru9e9wkslddj
```

- Content-Range에 범위를 지정하여 클라리언트측에 응답

### 참고 자료

- [콘텐츠 협상](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/lecture/61377?tab=note&mm=null)
- [범위 전송](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/lecture/61378?tab=note&mm=null)
- [Transfer encoding](https://goyunji.tistory.com/8)
