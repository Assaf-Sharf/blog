---
layout: single
title:  "[Java] 자바 객체지향 프로그래밍"
categories: Java
tag: [Java] 
author_profile: false
---
자바 객체지향 프로그래밍에 대해 알아보기.
<br>
<br>
<br>

# 절차지향 프로그래밍 vs 객체지향 프로그래밍 차이

## 절차지향 프로그래밍
절차 지향 프로그래밍은 <span style="background-color:#fff5b1"> 실행 순서를 중요시하는 방식이다. </span><br>

## 객체지향 프로그래밍 
객체지향 프로그래밍은 이름 그대로 객체를 지향한다. 즉 객체를 중요하게 생각하는
방식이다. <span style="background-color:#fff5b1"> 실제 세계의 사물이나 사건을 객체로 보고 이러한 객체들 간의 상호작용을 중심으로 
프로그래밍 하는 방식.</span><br>
<br>
<br>
<br>

# 생성자(Construct)

## 생성자란?
인스턴스가 생설될 떄마다 호출되는 객체 초기화 메서드.<br>
**즉, 생성자란 객체 초기화 메서드 , 메서드인데 조금 특별한 메서드. 객체 만들고 맴버변수에 원하는 값 세팅함.**

## 생성자를 왜 만들지?
**객체 초기화를 편하게 하려고 or 객체를 생성할떄 어떠한 처리를 반드시 해야할떄 그러한 초기값. 을 해결해줄수있다.**

```java
Time t = new Time();  //여기서 new를 통해  time 객체를 만들고 time() 생성자 호출
t.hour = 12;
t.minute = 34;
t.second = 56;
```
위 코드는 객체를 생성하고 직접 맴버변수를 선언해서 값을 초기화 해줘야 되는 번거로움이있고 중복코드가 발생.

```java
Time t = new Time(12,34,56); //객체 초기화 한줄컷 
```
클레스에 생성자를 추가해서 메인 메서드에서 그냥 생성자를 호출해서 4줄 코드를 1줄로 객체 초기화가 
가능하게 만들수있다, 직관적이고 매우편리함.이래서 생성자를 사용함.

## 생성자 작성 규칙
 * <span style="background-color:#FFE6E6"> 생성자의 이름은 클래스와 같아야한다. </span><br>
 * <span style="background-color:#FFE6E6"> 리턴값이 없다. </span><br>
 * <span style="background-color:#FFE6E6"> 모든 클래스는 반드시 생성자를 가져야한다</span><br>

## 기본생성자
  - 매개 변수가 없는 생성자
  - <span style="background-color:#fff5b1"> 생성자가 하나도 없을 떄만 , 컴파일러가 자동으로 추가해준다.</span><br>
  - <span style="background-color:#fff5b1"> 클래스 만들떄  다른 생성자를 만들더라도 기본 생성자를 만드는 습관을 들이자 </span><br>.

```
  클래스이름(){
  }
```

## 매개 변수가 있는 생성자
  ```java
  //car 클래스의 생성자 추가
  Car(String c , String g, int b){
    color = c;
    gearType = g;
    door = d;
  }
```
Car 클래스의 생성자를 추가하고 
```java
public static void main(String[] args){
    Car car1 = new Car("white","auto",4) // car 객체를 생성하고 Car() 생성자 호출해서 ()안에있는 값으로 초기화를 진행하고 참조변수 car1 에 객체 주소값을 전달한다.
}
```
## 생성자 this와  참조변수 this 차이

 **생성자 this() 사용이유는 코드 중복제거  목적이다.<br>**
 **생성자 this()사용시 주의사항은 다른 생성자 호출시 this()의 는 첫줄에만 사용가능하다.<br>**

* this() 생성자 호출전

 ```java
 package construct.ex;

public class Book {
    String title;
    String author;
    int page;

    Book() {
        this.title = "";     //중복
        this.author = "";    //중복
        this.page = 0;       //중복

    }

    Book(String title , String author) {
        this.title = title;          //중복
        this.author = author;        //중복
        this.page= 0;                //중복
    }

    Book(String title, String author, int page) {
        this.title = title;              //중복
        this.author = author;            //중복   
        this.page = page;                //중복
    }

    void displayInfo() {
        System.out.println("제목:" + title + "저자:" + author + "페이지:"+page );
    }
}
 ```

* this() 생성자 호출후

```java
package construct.ex;

public class Book {
    String title;
    String author;
    int page;

    Book() {
        this("","",0);    // = (Book(String title, String author, int page) 똑같은 의미 

    }

    Book(String title , String author) {
        this(title ,author,0);     // = (Book(String title, String author, int page)똑같은 의미 
    }

    Book(String title, String author, int page) {
        this.title = title;
        this.author = author;
        this.page = page;
    }

    void displayInfo() {
        System.out.println("제목:" + title + "저자:" + author + "페이지:"+page );
    }
}
```

* 참조변수 this 
참조변수 this는 인스턴스 자기자신. 지역변수와 인스턴스 변수 구분할떄 사용.

```java
package construct;

public class MemberConstruct {

    String name;
    int age;
    int grade;

    //추가
    MemberConstruct(String name, int age) {
        this(name,age,50); //변경

    }

    MemberConstruct(String name, int age, int grade) {
        System.out.println("생성자 호출  name = " + name + "age:"+ age + "grade" + grade);
        this.name = name;
        this.age = age;
        this.grade = grade;
    }
}
```
<br>
<br>
<br>

# 패키지(Package)

## 패키지 사용이유
 **많은 클래스 간에 관련 있는 기능들을  패키지별로 분류하면 관리가 편안하다.** 컴퓨터는 보통 파일을 분류하기 위해 폴더, 디렉토리라는 개념을 제공한다. 자바도 이런 개념을 제공하는데, 이것이 바로 **패키지**이다.
 ```
 * user
 * User
 * UserManager
 * UserHistory
* product
 * Product
 * ProductCatalog
 * ProductImage
* order
 * Order
 * OrderService
 * OrderHistory
* cart
 * ShoppingCart
 * CartItem
* payment
 * Payment
 * PaymentHistory
* shipping
 * Shipment
 * ShipmentTracker
 
 ```

## 패키지 규칙
 
 * <span style="background-color:#FFE6E6"> 패키지의 이름과 위치는 폴더(디렉터뢰) 위치와 같아야한다. </span><br>
 * <span style="background-color:#FFE6E6"> 패키지 이름은 모두 소문자를 사용한다. </span><br>
 * <span style="background-color:#FFE6E6"> 패키지 앞 부분에는 일반적으로 회사의 도메인 이름은 거꾸로 사용한다 ex)com.company.myapp </span><br>
 
## 패키지 계층 구조

 ![image description](/assets/images/java02.png)<br>
<br>
<br>
<br>

# 접근제어자(Access)  

## 접근제어자 사용이유
* 접근 제어자를 사용하면 **해당 클래스 외부에서 특정 필드나 메서드에 접근하는것을 허용하거나 제한할 수 있다**.

```java
package access;
public class Speaker {
 int volume;


 Speaker(int volume) {
 this.volume = volume;
 }
 void volumeUp() {
 if (volume >= 100) {
 System.out.println("음량을 증가할 수 없습니다. 최대 음량입니다.");
 } else {
 volume += 10;
 System.out.println("음량을 10 증가합니다.");
 }
 }
 void volumeDown() {
 volume -= 10;
 System.out.println("volumeDown 호출");
 }
 void showVolume() {
 System.out.println("현재 음량:" + volume);
 }
}
```
 
 * 해당 클래스는 스피커를 만드는 클래스이고 , 개발자가 스피커 음량이 최대 100 이상으로  셋팅해놨다.


```java
package access;
public class SpeakerMain {
 public static void main(String[] args) {
 Speaker speaker = new Speaker(90);
 speaker.showVolume();
 speaker.volumeUp();
 speaker.showVolume();
 speaker.volumeUp();
 speaker.showVolume();
 
 //필드에 직접 접근
 System.out.println("volume 필드 직접 접근 수정");
 speaker.volume = 200;
 speaker.showVolume();
 }
}
```
* 하지만 b라는 개발자  스피커 객체 사용하는 입장에서는, **접근제어자를 설정해 놓지 않았기 떄문에  필드에 직접 접근하여 볼륨값을 마음대로  변경할수있다.  속성이나 메서드값에 적절한 접근제어자를 설정해놓지않으면 a개발자가 만든 클래스의 제약사항은  의미가 없어진다**.  이렇게 떄문에 완벽한 캡슐화는 접근제어자를 사용해서 특정 필드나 메서드에 적절한 제약사항이 있어야 좋은 캡슐화이다.

## 접근 제어자 종류 
자바는 4가지 종류의 접근 제어자를 제공한다.
* <span style="background-color:#FFE6E6"> private: 모든 외부 호출을 막는다. </span><br>
* <span style="background-color:#FFE6E6"> default(package_private): 같은 패키지 안에서 호출을 허용한다. </span><br>
* <span style="background-color:#FFE6E6"> protected: 같은 패키지 안에서 호출을 허용한다. 패키지가 달라도 상속 관계의 호출은 허용한다. </span><br>
* <span style="background-color:#FFE6E6">public: 모든 외부 호출을 허용한다, </span><br>

* <span style="background-color:#FFE6E6">차단많이되는 순서 private - > default -> protected - > public </span><br>

## 접근 제어자 사용위치
접근 제어자는 필드와 메서드, 생성자에 사용된다.
추가로 클래스 레벨에도 일부 접근 제어라를 사용할수있다.
단 클래스 레벨의 접근 제어자는 public ,default만 사용할수 있다.

## 캡슐화
캡슐화는 객체 지향 프로그래밍의 중요한 개념중하나이다.
캡술화는 속성과 기능을 하나로 묶고, 외부에 꼭 필요한 기능만
노출하고 나머지는 모두 내부로 숨기는것이다.
즉 캡슐화를 통해 데이터의 직접적인 변경을 방지하거나 제한할수있다.


1.<span style="background-color:#fff5b1"> 데이터를 숨겨라. </span><br>
객체에는 속성(데이터)과 기능(메스드)이 있다.캡슐화에서 가장 필수로 숨겨야 하는 것은 속성이다.
객체 내부에 함부러 접근하게 되면  위에 예시에서 봤듯이 클래스 안에서 데이터를 다루는 모든 로직을 무시하고 데이터를 변경할수있다.<br>

2.<span style="background-color:#fff5b1"> 기능을 숨겨라. </span><br>
객체의 기능중에 외부에서 사용하지않고 내부에서 사용하는 기능들은 모두 감추는 것이 좋다.<br>
<br>
=> <span style="background-color:#fff5b1">정리하면 데이터(속성)는 모두 숨기고, 기능(메서드)은 꼭 필요한 기능만 노출하는 것이 좋은 캡슐화이다.</span>