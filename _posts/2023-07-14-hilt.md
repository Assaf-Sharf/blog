---
title: "DI(Dependency Injection)"
excerpt: "DI 라이브러리 없이 개념 이해하기"

writer: DaeYoungEE
categories:
  - Github Blog
tags:
  - [Blog, jekyll, Github, Git, markdown]

toc: true
toc_sticky: true

data: 2023-07-14
last_modified_at: 2022-07-14
---

# Dependency Injection

어떤 클래스를 사용할 때 다른 클래스가 참조가 필요한 경우가 있다. `Car` 클래스는 `Engine` 쿨래스를 참조한다.  
즉, `Car`클래스는 `Engine` 클래스에 의존한다.  
또는 `Engine` 클래스는 `Car` 클래스의 종속 항목(디펜던시) 라고 말한다.

특정 클래스가 자신이 의존하고 있는 객체를 얻기 위한 방법은 3가지 방법이 있다.

1. `Car` 클래스 안에서 `Engine` 인스턴스를 생성해 초가화
2. 다른 곳에서 객체를 가져온다. Android 로 치면 `Context`, `getSystemService()` 등에 해당한다.
3. `Car` 클래스를 생성할 때 매개변수로 `Engine` 인스턴스를 전달

세 번째 방법이 **Dependency Injection의 방법**이다.

## 의존관계에서 DI를 사용하지 않을 때

```kotlin
class Car() {
    private var engine = Engine()

    fun start() {
        engine.start()
    }
}

fun main() {
    val car = Car()
    car.start()
}
```

문제점

- `Car`가 `Engine`의 의존성이 너무 강하기 때문에 `Èngine` 클래스의 하위 클래스인 `GasEngine`, `ElectricEngine` 를 사용할 수 없게된다.
-

## 의존관계에서 DI를 사용할 때

```kotlin
class Car(private val engine: Engine) {
    fun start() {
        engine.start()
    }
}

fun main() {
    val car = Car(Engine())
    car.start()
}
```

`main()`에서 `Engine` 인스턴스를 만들고 `Car`생성자의 매개변수로 넣었다.

장점

- Car의 재사용성이 높아진다. -> `GasEngine`과 같은 `Engine`의 서브 클래스를 유연하게 넘겨 줄 수 있다.
- `Engine`의 생성자 등 구현이 변경되도 `Car` 클래스를 수정하지 않아도 된다.

---
