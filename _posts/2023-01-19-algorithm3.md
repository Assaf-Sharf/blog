---
layout: single
title:  "0119 algorithm"
categories: algorithm
tag: [algorithm]
toc: true
author_profile: false
sidebar:
    nav: "docs"
---
# 알고리즘 오답노트
## 중앙값 구하기  
### 문제:중앙값은 어떤 주어진 값들을 크기의 순서대로 정렬했을 때 가장 중앙에 위치하는 값을 의미합니다. 예를 들어 1, 2, 7, 10, 11의 중앙값은 7입니다. 정수 배열 array가 매개변수로 주어질 때, 중앙값을 return 하도록 solution 함수를 완성해보세요.  
### 예시  
array               result  
[1, 2, 7, 10, 11]   7  
[9, -1, 0]          0  
### 어려웠던 부분
```javascript
function solution(array) {
    var sarr = array.sort();
    var center = Math.floor(sarr.length/2);
    return sarr[center]
}
```
맨 처음엔 이따구로 짰다...  
근데 sort 메서드는 기본 정렬 순서는 유니코드 코드 포인트의 순서를 따르다 보니 문제가 발생한다고 한다.  
대충 예를 들자면 [2,1]은 문제없이 [1,2]로 정렬해주지만 [2,10]은 [10,2]로 정렬해버린다는 것.  
그러므로 숫자 배열을 오름차 순을 정렬하기 위해서는 array.sort((a,b)=>a-b);를 사용해야한다!
결과물은  
```javascript
function solution(array) {
    var sarr = array.sort((a,b)=>a-b);
    var center = Math.floor(sarr.length/2);
    return sarr[center]
}
```
## 최빈값 구하기
### 문제:최빈값은 주어진 값 중에서 가장 자주 나오는 값을 의미합니다. 정수 배열 array가 매개변수로 주어질 때, 최빈값을 return 하도록 solution 함수를 완성해보세요. 최빈값이 여러 개면 -1을 return 합니다.
### 제한사항
0 < array의 길이 < 100  
0 ≤ array의 원소 < 1000  
### 입출력 예
|array|result|
|------|---|
|[1, 2, 3, 3, 3, 4]|3|
|[1, 1, 2, 2]|-1|
|[1]|1|
```javascript
function solution(array) {
    let sarray = array.sort((a,b)=>a-b);
    let carr = [];
    let currentNum = sarray[0];
    let countNum = 1;
    for(let i = 0;i<array.length;++i){
        if(sarray[i]!=sarray[i+1]){
            carr.push([ currentNum, countNum ]);
            currentNum = sarray[i+1];
            countNum = 1;
        } else{
            countNum++;
        }
        
    }
    
    carr.sort((a,b)=>{
        if(a[1]>b[1]) return -1;
        if(a[1]<b[1]) return 1;
    });
    if (carr.length==1){
        return carr[0][0];
    }

    if (carr[0][1] == carr[1][1]){
        return -1;
    }
    else {
        return carr[0][0];
    }
}
```  
생각보다 어려웠다  
```javascript
function solution(array) {
    let sarray = array.sort((a,b)=>a-b); // 배열을 정렬
    let carr = [];
    let currentNum = sarray[0];
    let countNum = 1;
    for(let i = 0;i<array.length;++i){
        if(sarray[i]!=sarray[i+1]){
            carr.push([ currentNum, countNum ]);
            currentNum = sarray[i+1];
            countNum = 1;
        } else{
            countNum++;
        }
        
    }//2차원 배열로 [숫자, 나온 횟수]로 carr에 넣었다
    
    carr.sort((a,b)=>{
        if(a[1]>b[1]) return -1;
        if(a[1]<b[1]) return 1;
    }); // 2차 배열을 내림차순으로 정렬했다
    
    if (carr.length==1){
        return carr[0][0];
    } // 원래 배열이 숫자 하나 짜리면~
    if (carr[0][1] == carr[1][1]){
        return -1;
    } // 비교해서 최빈값이 여러개면 -1 반환
    else {
        return carr[0][0];
    } // 최빈값 반환
}
```  
이렇게 주석으로 달아놓은 식으로 생각하고 코드를 짰다  
[숫자, 나온 횟수]인 2차원 배열을 짜야겠다는 생각을 하기 까지가 꽤 시간이 오래걸렸다  