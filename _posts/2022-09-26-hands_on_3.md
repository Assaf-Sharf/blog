---
layout: single
title:  "핸즈온 머신러닝 - 3 진행중"
categories : scikit-learn
tag : [scikit-learn, machine-learning, python]
toc: true
toc_sticky: true

---

![header](https://capsule-render.vercel.app/api?type=waving&color=a2dcec&height=300&section=header&text=핸즈온 머신러닝 - 3&fontSize=40&animation=fadeIn&fontAlignY=38&fontColor=FFFFFF)

- 참고 : [핸즈온 머신러닝 2판](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9791162242964)

------------------------------------------------------

&nbsp;



## 이진 분류기

- mnist를 활용한 5, 5아님 분류기
- sklearn의 SGDClassifier 모델 사용
  - SGD (확률적 경사 하강법)은 매우 큰 데이터셋을 효율적으로 처리하는 장점을 가짐
  - SGD는 한번에 하나씩 훈련 샘플을 독립적으로 처리함

```python
from sklearn.linear_model import SGDClassifier

sgd_clf = SGDClassifier(max_iter=1000, tol=1e-3, random_state=42)
sgd_clf.fit(X_train, y_train_5)
```

> SGDClassifier은 훈련하는데 무작위성을 사용



&nbsp;

## 성능 측정

- 교차 검증
  - skleran의 cross_val_score 함수와 유사한 작업 수행하는 예시

```python
from sklearn.model_selection import StratifiedKFold
from sklearn.base import clone

# shuffle=False가 기본값이기 때문에 random_state를 삭제하던지 shuffle=True로 지정하라는 경고가 발생합니다.
# 0.24버전부터는 에러가 발생할 예정이므로 향후 버전을 위해 shuffle=True을 지정합니다.
skfolds = StratifiedKFold(n_splits=3, random_state=42, shuffle=True)

for train_index, test_index in skfolds.split(X_train, y_train_5):
    clone_clf = clone(sgd_clf)
    X_train_folds = X_train[train_index]
    y_train_folds = y_train_5[train_index]
    X_test_fold = X_train[test_index]
    y_test_fold = y_train_5[test_index]

    clone_clf.fit(X_train_folds, y_train_folds)
    y_pred = clone_clf.predict(X_test_fold)
    n_correct = sum(y_pred == y_test_fold)
    print(n_correct / len(y_pred))
```

&nbsp;

**위 과정을 cross_val_score로 표현하면**

- cross_val_score() 함수로 폴드가 3개인 k-겹 교차 검증을 사용해 SGDClassifier 평가

```python
from sklearn.model_selection import cross_val_score
cross_val_score(sgd_clf, X_train, y_train_5, cv=3, scoring="accuracy")
```

&nbsp;

**클래스를 분류하는 더미 분류기 작성**

```python
from sklearn.base import BaseEstimator
class Never5Classifier(BaseEstimator):
    def fit(self, X, y=None):
        pass
    def predict(self, X):
        return np.zeros((len(X), 1), dtype=bool)
    
never_5_clf = Never5Classifier()
cross_val_score(never_5_clf, X_train, y_train_5, cv=3, scoring="accuracy")
>>> array([0.91125, 0.90855, 0.90915])
```

- 아무런 학습을 수행하지 않아도 정확도 90% 이상
- 불균형 데이터셋을 다룰때 이러한 분류 성능 문제가 발생

&nbsp;



## 오차 행렬

- 분류기의 성능을 평가하는 방법
- cross_val_predict() 함수를 통해 사용가능
- cross_val_score 함수처럼 cross_val_predict 함수는 k-겹 교차 검증을 수행하지만 평가 점수를 반환하지 않고 각 테스트 폴드에서 얻은 예측을 반환


```python
from sklearn.model_selection import cross_val_predict

y_train_pred = cross_val_predict(sgd_clf, X_train, y_train_5, cv=3)
```

**오차 행렬** 

- 오차 행렬의 행은 실제 클래스를 의미, 열은 예측한 클래스를 의미
  - 밑의 결과의 첫 행은 '5 아님' 이미지에 대한 것 53892개를 '5 아님'으로 정확하게 판단, 687을 5라고 잘못 판단
  - 두번째 행은 5에 대한 이미지, 1891을 5아님으로 잘못 판단, 3530을 5라고 맞게 판단


```python
from sklearn.metrics import confusion_matrix

confusion_matrix(y_train_5, y_train_pred)

>> array([[53892,   687],
      	 [ 1891,  3530]])
```

- 오차 행렬은 많은 정보를 제공하지만 요약된 지표를 통해 빠르게 판단해야 하는 상황이 필요함

&nbsp;

![image-20220926200755530](/images/2022-09-26-hands_on_3/image-20220926200755530.png)

**정밀도(Precision)**

- **예측을 Positive로 한 대상**(FP + TP) 중 **예측과 실제 값이 Positive로 일치한 데이터**(TP)의 비율

- TP / (FP + TP) (TP : 진짜 양성의 수, FP : 가짜 양성의 수)

**재현율(Recall)**

- **실제가 Positive인 대상**(FN + TP) 중 **예측과 실제 값이 Positive로 일치한 데이터**(TP)의 비율
- TP / (FN + TP)
- 민감도 라고도 함



&nbsp;



## 정밀도와 재현율

```python
from sklearn.metrics import precision_score, recall_score

# 정밀도
precision_score(y_train_5, y_train_pred)
>> 0.8370879772350012

# 재현율
recall_score(y_train_5, y_train_pred)
>> 0.6511713705958311
```

- 전체 5로 판단한 이미지 중에서 83% 정확함
- 전체 숫자 5중에서 65% 정확함

- 정밀도와 재현률을 F1 score라고 하는 하나의 값으로 판단, 정밀도와 재현율의 조화 평균
  - ![image-20220926201309057](/images/2022-09-26-hands_on_3/image-20220926201309057.png)

```python
from sklearn.metrics import f1_score

f1_score(y_train_5, y_train_pred)

>> 0.7325171197343846
```

- 상황에 따라서 정밀도가 중요한지 재현율이 중요한지 기준이 바뀜


&nbsp;

## 정밀도/재현율 트레이드오프

- 임계값을 내리면 재현율이 높아지고 정밀도가 줄어듦
- 임계값을 올리면 재현율은 줄어들고 정밀도는 높아짐
- 분류기의 predict 대신 decision_function을 통해 각 셈플의 점수를 얻을수 있음, 이를 통해 원하는 임계값 설정 가능


```python
y_scores = sgd_clf.decision_function([some_digit]) # some_digit는 5의 이미지
y_scores
>> array([2164.22030239])
# 위의 기준값을 통해 적절한 임계값을 설정할수 있지만 cross_val_predict()를 통해 수행가능
```

&nbsp;

**cross_val_predict()**

- 훈련 세트에 있는 모든 샘플의 점수를 구함
- 예측 결과가 아닌 결정 점수를 반환 받도록 지정

```python
y_scores = cross_val_predict(sgd_clf, X_train, y_train_5, cv=3,
                             method="decision_function")
```


- 위의 y_scores를 통해 가능한 모든 임계값에 대해 정밀도와 재현율을 계산할수 있음


```python
from sklearn.metrics import precision_recall_curve

precisions, recalls, thresholds = precision_recall_curve(y_train_5, y_scores)
```

- precision_recall_curve를 통해 트레이드 오프 그래프 그리기


```python
def plot_precision_recall_vs_threshold(precisions, recalls, thresholds):
    plt.plot(thresholds, precisions[:-1], "b--", label="Precision", linewidth=2)
    plt.plot(thresholds, recalls[:-1], "g-", label="Recall", linewidth=2)
    plt.legend(loc="center right", fontsize=16) # Not shown in the book
    plt.xlabel("Threshold", fontsize=16)        # Not shown
    plt.grid(True)                              # Not shown
    plt.axis([-50000, 50000, 0, 1])             # Not shown
    
    
plot_precision_recall_vs_threshold(precisions, recalls, thresholds)
plt.show()
```

![image-20220926202639170](/images/2022-09-26-hands_on_3/image-20220926202639170.png)

>  정밀도 곡성이 재현율 곡선보다 울틍불퉁한 이유는 임계값을 올리더라도 정밀도가 가끔 낮아질때가 있음

- 다른 방법으로는 재현율에 대한 정밀도 곡선을 작성


```python
def plot_precision_vs_recall(precisions, recalls):
    plt.plot(recalls, precisions, "b-", linewidth=2)
    plt.xlabel("Recall", fontsize=16)
    plt.ylabel("Precision", fontsize=16)
    plt.axis([0, 1, 0, 1])
    plt.grid(True)

plt.figure(figsize=(8, 6))
plot_precision_vs_recall(precisions, recalls)
plt.plot([recall_90_precision, recall_90_precision], [0., 0.9], "r:")
plt.plot([0.0, recall_90_precision], [0.9, 0.9], "r:")
plt.plot([recall_90_precision], [0.9], "ro")
save_fig("precision_vs_recall_plot")
plt.show()
```

![image-20220926203016559](/images/2022-09-26-hands_on_3/image-20220926203016559.png)

&nbsp;

