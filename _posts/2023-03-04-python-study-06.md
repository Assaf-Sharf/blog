---
layout: single
title: python-study-06 컬렉션 관리
tags: python
---

## 컬렉션 관리 함수
### enumerate
순서값과 요소값 둘을 한꺼번에 구해주는 내장함수로, 리스트의 순서값과 요소값을 튜플로 묶은 컬렉션을 리턴한다. 

```python
score = [88,12,34,23]
for no, s in enumerate(score,1):
    print(str(no) + "번 학생의 성적 :", s)
```
>1번 학생의 성적 : 88
2번 학생의 성적 : 12
3번 학생의 성적 : 34
4번 학생의 성적 : 23


### zip
여러 개의 컬렉션을 합쳐서 하나로 만든다. 두 리스트의 대응되는 요소끼리 찍을 지어 튜플의 리스트를 생성한다. 두 개의 리스트를 병렬로 순회할 때 편리하다.
```python
a = ['월','화','수']
b = ['1','2','3']
test_zip = zip(a,b)
for tmp1,tmp2 in test_zip:
    print("%s 테스트용 : %s" % (tmp1,tmp2))
```
>월 테스트용 : 1
화 테스트용 : 2
수 테스트용 : 3

합쳐지는 두 리스트는 길이가 달라도 상관이 없으며, 짧은 쪽의 길이에 맞추어지고 긴 쪽의 남는 요소는 사용하지 않는다.  
생성되는 튜플의 순서는 원본 리스트의 순서와 같으며, 세 개 이상의 리스트를 인수로 주어서 병합하는 것도 가능하다. 이때는 결과 튜플의 요소도 세 개이다.  
zip함수가 사용하는 튜플을 dict함수 로 넘겨서 변환하면 앞 요소를 키로하고 뒤 요소를 값으로 하는 사전이 만들어진다. 

### any, all
any 함수는 리스트를 순회하며, 참인 요소가 하나라도 있는지 조사한다. 반면 all함수는 리스트의 모든 요소가 참인지 조사한다. 리스트에 저장된 모든 요소의 진리값 조합을 구하는 것이다.
```python
test_anyall = [True,False,True]
print(any(test_anyall))
print(all(test_anyall))
```
>True
False

빈 리스트의 경우, any함수는 참이 하나도 없다고 판단하여 거짓이라는 결과가 나오고, all함수는 거짓이 하나도 없다고 판단하여 참이라는 결과가 나온다.


## 람다 함수
### filter
filter함수는 리스트의 요소 중 조건에 맞는 것만 골라낸다, filter(조건지정함수,대상리스트)  
함수의 인수로 함수를 전달해야 하며, 함수를 정의해놓고 인수 목록에 이름을 밝히면 된다. filter함수가 리스트를 리턴하므로, for루프로 filter호출식을 순회하면 골라낸 점수를 모두 구할 수 있다.  
조건을 점검하는것이 단순한 값이나 수식이 아닌 동작이라서 함수가 필요하고, 모든 요소에 대해 함수를 호출하여 제어권을 넘겨주므로 자유도가 높다.
```python
def flunk(s):
    return s<60
score = [45,89,72,53,94]
for s in filter(flunk,score):
    print(s)
```
>45
53

### map
map함수는 모든 요소에 대해 변환 함수를 호출하여 새 요소값으로 구성된 리스트를 생성한다. map(함수,리스트)  
원본인 score리스트는 읽기만 할 뿐 변경하지는 않는다.
```python
def half(s):
    return s/2
score = [45,89,72,53,94]
for s in map(half,score):
    print(s, end=', ')
```
>22.5, 44.5, 36.0, 26.5, 47.0, 


두개 이상의 리스트를 받아 각 리스트의 요소를 조합할수도 있는데, 이때 변환 함수는 두개의 요소값을 전달받아야 하므로 대상 리스트 인수가 2개여야 한다. 두 개의 정수값을 더해 리턴하는 total 함수를 정의하고, 이 함수와 두 리스트를 전달하면 두 리스트의 각 요소가 순서대로 total로 전달된다. total이 리턴하는 합계로 새로운 리스트가 생성된다.
```python
def total(s,b):
    return s+b
score = [45,89,72,53,94]
bonus = [2,3,0,0,5]
for s in map(total,score,bonus):
    print(s, end=", ")
```
>47, 92, 72, 53, 99, 


### 람다 함수
filter함수나 map함수는 필터링과 변환을 위해 다른 함수를 인수로 받는다. 이 함수를 호출 하기 전에 인수로 전달할 함수부터 정의해야 한다...(그냥 내장함수를 사용해도 됨)  
이 경우 간편하게 쓸 수 있는것이 람다식이다. 람다는 이름이 없고 입력과 출력만으로 함수를 정의하는 축약된 방법이다.  
__lambda 인수:식__ 의 형태로 사용한다.  
  
키워드 lambda로 시작하고 인수와 리턴할 값을 밝힌다. 인수는 콤마로 구분하며 여러 개 가질수 있따. return문이 없지만 인수로부터 계산한 식을 리턴한다.  

```python
lambda x:x + 1
```
인수 x를 받아서 x+1을 리턴하는 람다식이다. 함수 이름과 return 키워드가 생략되어 더 간단하다.  
  
축약된 형태이므로 filter, map처럼 함수를 요구하는 호출식의 인수 목록에 람다식을 바로 사용할 수 있다.
```python
score = [45,89,72,53,94]
for s in filter(lambda x:x < 60,score):
    print(s)
```
>45
53


```python
score = [45,89,72,53,94]
for s in map(lambda x:x/2,score):
    print(s,end=', ')
```
>22.5, 44.5, 36.0, 26.5, 47.0, 


## 컬렉션의 사본
### 리스트의 사본
기본 변수는 서로 독립적이라서, 대입하면 일시적으로 값이 같아질뿐, 둘중 하나를 그 뒤에 바뀌어도 다른 변수에 영향이 없다. 그러나 컬렉션의 경우에는 다른데, list2에 list1을 대입하면 두 리스트의 내용이 같아진다. 대입한 상태에서 list2의 1번째 요소를 100으로 변경한 후 출력해보면 list1의 1번째 요소도 같이 바뀌어 있다. 두 리스트가 독립된 사본이 아니라 같은 메모리를 가리키고 있기 때문이다.
```python
a = 3
b = a
print("a=%d, b=%d" %(a,b))
a = 5
print("a = %d, b=%d" %(a,b))

list1 = [1,2,3]
list2 = list1
list2[1] = 100
print(list1)
print(list2)
```
>a=3, b=3
a = 5, b=3
[1, 100, 3]
[1, 100, 3]


두 리스트를 완전히 독립적인 사본으로 만들려면 copy메서드를 사용하여 복사본을 생성하거나, list1[:] 이렇게 슬라이싱을 이용하여 전체 범위의 사본을 만들면 된다.
```python
list2 = list1[:]
```

### 얕은 복사와 깊은 복사
```python
list0 = ['a','b']
list1 = [list0, 1, 2]
list2 = list1.copy()

list2[0][1] = 'c'
print(list1)
print(list2)
```
>[['a', 'c'], 1, 2]
[['a', 'c'], 1, 2]

list1 안에 list0가 포함되어 있는 상황인데 copy메서드로 list2를 복사하면 두 리스트가 내부의 list0을 공유하는 상황이 된다. 이 상태에서 list2에 포함된 list0을 변경하면 list1도 영향을 받는다.  
완전한 사본을 만들려면 깊은 복사를 수행해야 하는데, 이때는 copy모듈의 deepcopy함수를 사용한다.

```python
import copy

list0 = ['a','b']
list1 = [list0, 1, 2]
list2 = copy.deepcopy(list1)

list2[0][1] = 'c'
print(list1)
print(list2)
```
>[['a', 'b'], 1, 2]
[['a', 'c'], 1, 2]

deepcopy 함수는 중첩된 리스트까지 모두 복사하여 완전한 사본을 만드는 깊은 복사를 수행한다. list2를 수정해도 list1에 영향이 없다.


### is 연산자
두 변수가 같은 객체를 가리키고 있는지 조사할때 사용하며, 좌우 변수가 같은 객체를 가리키고 있다면 True를 리턴한다.
```python
list1 = [1,2,3]
list2 = list1
list3 = list1.copy()

print(list1 is list2)
print(list1 is list3)
print(list2 is list3)
```
>True
False
False

list2는 list1을 단순 대입받았으므로 같은 객체를 가리키고 있다. 두 리스트가 가리키는 대상이 같아서 list1 is list2는 True를 리턴한다. 이 상타에서는 둘 중 어떤 리스트를 변경하든 다른 것도 영향을 받는다.  
반면 list3은 copy메서드로 list1의 사본을 뜬 것이어서 메모리가 완전히 분리된 다를 객체이다.  
list1,list2 는 같은 리스트를 가리키고 있고, list3은 내용만 같은 다른 리스트를 가리키고 있는 것이다.  

```python
a = 1
b = a
print("a =",a,"b =",b,":",a is b)
b = 2
print("a =",a,"b =",b,":",a is b)
```
>a = 1 b = 1 : True
a = 1 b = 2 : False

a를 1로 초기화해놓은 상태에서 b에 a를 대입하면 두 변수는 1이라는 같은 객체를 가리킨다. 파이썬은 상수까지도 객체 취급하는데 1이라는 상수가 하나의 객체이며 두 변수가 같은 객체를 가리킨다.  
그러나 리스트와는 달리 두 변수 중 하나를 변경한다고 해서 다른 값이 같이 바뀌지는 않는다. b에 2를 대입하는 순간 b가 가리키는 객체가 1에서 2로 바뀌며 a는 여전히 1을 가리키고 있다. 이 상태에서는 a와 b의 값이 달라지며 a is b도 false가 된다.(1을 가리키던 b가 2를 향하게 된다.)

정수는 대입에 의해서 일시적으로 같은 객체를 가리킬 수 있지만 다른 값을 대입하면 참조가 변경되어 즉시 분리된다. 따라서 컬렉션과는 달리 서로 독립적이다.
