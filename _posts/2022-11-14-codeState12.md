---
layout: single
title: "[Project] 나만의 아고라스테이츠 만들기 1차"
categories: JavaScript, CSS, HTML
tags: [ Project, CodeStates]
toc: true

---

### 2022.11.14

### 💡  SOLO Project

#### ▶️ 나만의 아고라스테이츠 만들기

#### Bare Minimum Requirement

1. Discussion 컴포넌트
   - 모든 요소에 `border-box`를 적용합니다.
   - `<li>` 요소의 기본 스타일인 점을 보이지 않게 합니다.
   - Discussion 컴포넌트 전체의 폭을 540px로 만드세요.
2. 왼쪽 아바타
   - 아바타 사진을 인스타그램 프로필 사진처럼 동그랗게 표현하세요.
   - 아바타 사진의 너비를 48px로 설정하세요.
   - 아바타 사진이 Discussion 컴포넌트 높이의 중간에 오도록 정렬합니다.
3. 중간 Discussion 콘텐츠
   - Discussion 제목과 저자, 생성일간에 간격을 충분히 줍니다.
   - 저자, 생성일을 함께 작성하고, 오른쪽 정렬하여 오른쪽에 붙입니다.
4. 오른쪽 체크 표시
   - 체크 표시가 Discussion 컴포넌트 높이의 중간에 오도록 정렬합니다.

아직 css를 만져서 꾸미지는 못하였지만 Bare Minimum에서 요구하는 것들만 해결했다. 

###### 📌 style.css [ 수정 예정 ]

```js
/* TODO: 보기 좋은 나만의 아고라 스테이츠를 위해서 CSS를 수정하세요. */
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  line-height: 1;
  display: flex;
  flex-direction: column;
}
ol,
li {
  list-style: none;
}

/* 전체 디스커젼 */
.discussion__container {
  display: flex;
  width: 540px;
  justify-content: space-between;
  align-items: center;
  background-color: whitesmoke;
}

/* 프로필 사진 */
.discussion__avatar--wrapper {
  margin: 1px;
  border-radius: 70%;
  height: 48px;
  width: 48px;
  overflow: hidden;
  margin-left: 5%;
}
.discussion__avatar--wrapper .discussion__avatar--image {
  object-fit: cover;
  width: 50px;
  height: 50px;
}

.discussion__container > .discussion__content {
  display: flex;
  flex-direction: column;
  width: 480px;
  display: block;
}
.discussion__container > .discussion__content > .discussion__information {
  text-align: right;
  font-size: 0.7rem;
}
.discussion__container > .discussion__content > .discussion__title {
  margin: 10px 0 20px 20px;
  font-size: 1.1rem;
}
/* 체크박스 */
.discussion__container > .discussion__answered {
  width: 30px;
  text-align: center;
}
```

아직 제대로 정리하지 못하고 시간 급급하게 진행해서 깔끔하지도 못하고 정리도 시급하다. [ 내일 수정예정 ]

##### Bare Minimum Requirement

- `agoraStatesDiscussions` 배열의 모든 디스커션을 화면에 렌더링합니다.

##### Advanced Challenge

- 답변이 있는 경우, 답변도 화면에 렌더링합니다.

###### 📌 script.js

```js
// convertToDiscussion은 아고라 스테이츠 데이터를 DOM으로 바꿔줍니다.
const convertToDiscussion = (obj) => {
  const li = document.createElement("li"); // li 요소 생성
  li.className = "discussion__container"; // 클래스 이름 지정

  const avatarWrapper = document.createElement("div");
  avatarWrapper.className = "discussion__avatar--wrapper";
  const discussionContent = document.createElement("div");
  discussionContent.className = "discussion__content";
  const discussionAnswered = document.createElement("div");
  discussionAnswered.className = "discussion__answered";

  // TODO: 객체 하나에 담긴 정보를 DOM에 적절히 넣어주세요.
  // 프로필 사진
  const faceimg = document.createElement('img')
  faceimg.className = 'discussion__avatar--image'
  faceimg.src = obj.avatarUrl
  faceimg.alt = 'avatar of' + obj.autor
  avatarWrapper.append(faceimg)

  // 타이틀 제목 
  const discussionTitle = document.createElement('h2')
  discussionTitle.className = 'discussion__title'
  discussionContent.append(discussionTitle)
  // 타이틀 링크
  const titlelink = document.createElement('a')
  titlelink.href = obj.url
  titlelink.textContent = obj.title
  discussionTitle.append(titlelink)

  // 사용자 정보
  const information = document.createElement('div')
  information.className = 'discussion__information'
  information.textContent = `${obj.author} / ${obj.createdAt}` 
  discussionContent.append(information)
  // answer p 
  const checked = document.createElement('p')
  discussionAnswered.append(checked)
  
  li.append(avatarWrapper, discussionContent, discussionAnswered);
  return li;
};
```

듀토리얼을 보고 따라해보고 이해하기 바빴다. 교본에 작성되어 있는 render( )함수를 차근차근 살펴보면서 최대한 내 머리로 이해해보려고 애썼던 것 같다. 

data.js 파일 내의 41개 배열 Discussion 정보를 화면에 렌더링하는 방법으로 데이터를 만지는 작업을 처음으로 경험해보았다. DOM을 배우지 않았더라면 하나하나 하드코딩해야 했겠지만 DOM을 활용해서 위와같이 코드를 작성했다.

우선 HTML구조를 하나씩 뜯어보고 각 요소들을 Dom구조로 불러내었다. 코딩을 하면서 최대한 가독성있게 나눠보았고 교본에 이미 정의되어있는 요소들에 append해주었다. 

##### 📌 11.14 [ 결과물 ]

<img width="659" alt="스크린샷 2022-11-14 21 15 46" src="https://user-images.githubusercontent.com/104547038/201657871-9cee591d-be3a-4e09-aa0a-ab60626ffd83.png">









2. 데이터를 보존하는 함수 

외부함수의 실행이 끝나더라도, 외부함수 내 변수를 사용할 수 있다. 

일반적인 함수는, 함수 실행이 끝나고 나면 함수 내부의 변수를 사용할 수 없다. 이와 다르게, 클로저는 외부함수의 실행이 끝나더라도, 외부 함수 내 변수가 메모리 상에 저장된다. 

```js
// HTML 문자열 생성기 
const tagMaker = tag => content => `<${tag}> ${content} </${tag}>`

const divMaker = tagMaker('div')
divMaker('hello') = '<div> hello </div>'
```



3. 정보의 접근 제한 ( 캡슐화 )

```js
// 클로저 모듈 패턴 
const makeCounter = () => {
  let value = 0;
  
  return {
    increase: () => {
			value = value + 1 
    },
    decrease: () => {
      value = value - 1
    },
    getValue: () => value
  }
}
const counter1 = makeCounter()
```

이처럼 클로저를 이용해 내부함수를 단 하나만 리턴하는 것에 그치지 않고, 객체에 담아 여러 개의 내부 함수를 리턴한도록 한다. 

makeCounter 함수를 바꾸지 않고, value 라는 변수에 값을 새롭게 할당할 수 있는 방법이 있을까? 

대답은 No이다. 외부 스코프에서는 내부스코프에 접근할 수 없다는 규칙에 의해, 어떤 경우에도 'value'는 직접 수정이 불가능하다. 

그러나 리턴하는 객체가 제공하는 메서드를 통해 'value' 값을 간접적으로는 수정할 수 있다. 

만일 스코프로 value의 값을 감싸지 않았다면,  value의 값은 전역변수였을 것이다. 하지만 makeCounter 함수가 value의 값을 보존하고 있기 때문에 따로 전역변수를 만들 필요가 없는 것이다. 



상태를 은닉

```js
const x = 1;
function outer(){
  // 지역변수 x 선언
  const x = 10;
  // inner함수 정의
  const inner = function(){console.log(x)}
  // inner함수를 그대로 리턴 
  return inner
}
// outer의 역할은 여기서 끝
// inner함수가 정의된 outer는 사라지지만 inner함수는 상위 스코프인 outer의 변수를 기억하고있다.

const innerFunc = outer();
innerFunc() // outer함수 내부에 있는 inner함수를 실행한다. 
 
```

중첩 여부와 상관없이 처음 정의된 곳의 상위 스코프가 정적으로 결정되었기 때문



#### ▶️ JavaScript의 함수는 일급 객체 

자바스크립트의 함수는 변수에 할당도 가능하고, 리턴도 할 수 있고, 매개변수로도 넣을 수 있고 등등... 

근데 함수가 함수를 리턴하는 형태가 나온다? -> 일단 클로저라고 의심!

1. 중첩함수
2. 중첩함수(리턴되고있는 함수)가  외부함수의 변수를 참조한다? ->  이게 바로 클로저 \

왜? 변수를 안전하게 보호하기 위해서(은닉) -> 리턴된 함수를 사용하지 않으면 다른 요인으로 변수 못바꾼다. 



```js
const increase = function(){
  let num = 0;
  return function(){ //  === increase1
    return ++num;
  }
}
const increase1 = increase();
console.log(increase1()); // 1
console.log(increase1()); // 2
console.log(increase1()); // 3


let num = 0;
const increase = function(){
  return ++num;
}
console.log(increase()) // 1
console.log(increase()) // 2
console.log(increase()) // 3
num = 5
num++
console.log()
// 외부에 의해 영향을 받아서 num변수를 지킬 수 없음 
```





##### 📌 왜 원시 자료형이라고 부를까? 

원시 자료형은 모두 '하나'의 데이터를 담고있다. 옛날 컴퓨터에서는 데이터 보관함 한칸에 하나의 데이터만 넣을 수 있었기에 비슷한 느낌으로 원시 자료형이라 부른다. 

원시자료형의 보관함인 변수에는 하나의 원시자료형만 담을 수 있다. 이 특징은 참조 자료형의 heap과는 구분되는 모습이다.  

```js
const num1 = 123;
const num2 = 12345;
// 이렇게 변수에는 데이터 크기와 상관없이 
// 하나의 데이터만 담을 수 있다. 
```



##### 📌 참조 자료형?? Heap? 

참조 자료형에서는 하나의 데이터가 아닌 여러 데이터가 담긴다. 

원시 자료형이 하나의 데이터 보관함에 저장되었다면 참조자료형은 별도의 공간 **heap**을 생성해 그 곳의 주소에 데이터를 저장한다고 생각하면 된다. 이 특별한 공간은 데이터에 맞게 사이즈를 동적으로 변하기도 한다. 

나름 예시를 들어보자면 

```js 
let a = [4,5,6];      // 1번 사물함:a 주소:1
let b = ['hi',1,2];   // 2번 사물함:b 주소:2
let c = [true,false]	// 3번 사물함:b 주소:3
a[0] =3;
b.pop();
c.push('a')
--------------------------------------
// heap 공간 
// 주소 1 = 3,4,5
// 주소 2 = 'a',1
// 주소 3 = true,false,'a'
```

이런 식으로 이해하면 될 것 같다. 

##### 📌 Quiz

```js
// 다음 코드들의 x의 값은?  
let x = 2;
let y = x;
y = 3;
// x = 2 이다 
// 원시자료형이기에 y에 다른 값을 할당해도 
// x는 변하지 않는다. 

let x = {foo:3};
let y = x;
y.foo = 2
// 참조자료형이기에 기본값에 영향을 준다. 
// x = 2 이다

let x = {foo:3};
let y = x;
y = 2
// 참조자료형으로 주소값을 할당받았지만,
// y를 원시타입으로 할당했으니 기본값에 영향을 받지 않는다. 
// x = 3 이다
```

