---
title: "[Software-R] Unit 1: 1.5: Agile Software Development"

categories:
  - Software-R
tags:
  - [Agile]

toc: true
toc_sticky: true

date: 2023-05-13
last_modified_at: 2023-05-13
---

<!-- {% capture notice-2 %}

üìã This is the tech-news archives to help me keep track of what I am interested in!

- Reference tech news link: <https://thenextweb.com/news/blockchain-development-tech-career>
  {% endcapture %}

<div class="notice--danger">{{ notice-2 | markdownify }}</div> -->

üìã This is my note-taking from what I learned in the class "Software Requirements Engng"
{: .notice--danger}

<br>

# Agility in Software Development

> What is Agile development?

Agile development is a philosophy in addition to a set of guidelines. The philosophy encourages customer satisfaction and early incremental delivery of software; small, highly motivated project teams; informal methods; minimal software engineering work products; and overall development simplicity. The development guidelines stress delivery over analysis and design (although these activities are not discouraged), and active and continuous communication between developers and customers.

![Image](../../../assets/images/1.15.png)

In 2001, Kent Beck and 16 other noted software developers, writers, and consultants (referred to as the ‚ÄúAgile Alliance‚Äù) signed the ‚ÄúManifesto for Agile Software Development.‚Äù

![Image](../../../assets/images/1.16.png)

<br>

# Agile Alliance

> What is "Agility" in the context of Software Engineering?
>
> &rarr; Embrace change; software engineering should be quick on their feet.

Agile processes are based on three key assumptions:

- It is difficult to predict in advance which requirements or customer priorities will change and which will not.
- For many types of software design and construction activities are interleaved (construction is used to prove the design).
- Analysis, design, and testing are not as predictable from a planning perspective as one might like them to be.

Agile processes must be adapted incrementally to manage unpredictability. Incremental adaptation requires customer feedback based on evaluation of delivered software increments (executable prototypes) over short time periods.

Agile 12 principles, the principles define an agile spirit that is maintained in each of the process models:

1. Highest priority is to satisfy customer through early and continuous delivery of valuable software.
2. Welcome changing requirements, even late in development; accommodating change is viewed as increasing the customer‚Äôs competitive advantage.
3. Delivering working software frequently with a preference for shorter delivery schedules (e.g. every 2 or 3 weeks).
4. Business people and developers must work together daily during the project.
5. Build projects around motivated individuals. Give them the right environment and the support they need and trust them to get the job done.
6. Face-to-face communication is the most effective method of conveying information within the development team.
7. Working software is the primary measure of progress.
8. Agile processes support sustainable development. Developers and customers should be able to continue development indefinitely.
9. Continuous attention to technical excellence and good design will enhance agility.
10. Simplicity (defined as maximizing the work not done) is essential.
11. The best architectures, requirements, and design emerge from self-organizing teams.
12. At regular intervals teams should reflect on how to become more effective and then adjust behavior accordingly.

![Image](../../../assets/images/1.17.png)

Not every agile process model applies these 12 principles with equal weight, and some models choose to ignore (or at least downplay) the importance of one or more of the principles.

<br>

# Agile process models in Software Development

Extreme Programming (XP)

<br>

# Specialized process models

Specialized process models take on many of the characteristics of one or more of the traditional models presented in the preceding sections. However, these models tend to be applied when a specialized or narrowly defined software engineering approach is chosen.

## Component-Based Development:

Spiral model variation in which applications are built from prepackaged software components called classes

- The model leads to software reuse which leads to a reduction in the development cycle time and if component reuse is adopted in the organization, a reduction in the cost.
- Follows the following five steps:
  : - Available component-based products are researched and evaluated for the application domain in question.
  : - Component integration issues are considered.
  : - A software architecture is designed to accommodate the components.
  : - Components are integrated into the architecture.
  : - Comprehensive testing is conducted to ensure proper functionality.

## Formal Methods Model:

Rigorous mathematical notation used to specify, design, and verify computer-based systems:

- Not widely adopted because of the following:
  : - The development of formal models is currently quite time consuming and expensive.
  : - Because few software developers have the necessary background to apply formal methods, extensive training is required.
  : - It is difficult to use the models as a communication mechanism for technically unsophisticated customers.
- Applied for safety - critical software for example: Aircraft software or Medical software

## Aspect-Oriented Software Development:

Aspect-oriented programming - provides a process for defining, specifying, designing, and constructing software aspects like user interfaces, security, and memory management that impact many parts of the system being developed:

- Fairly new and a distinct process has not yet matured.

<br>

# The unified process model

- Use-case driven, architecture centric, iterative, and incremental software process
- Attempts to draw on best features of traditional software process models and implements many features of agile software development
- Phases
  : - Inception phase (customer communication and planning)
  : - Elaboration phase (communication and modeling)
  : - Construction phase
  : - Transition phase (customer delivery and feedback)
  : - Production phase (software monitoring and support)

![Image](../../../assets/images/1.14.png)

<br>

# Personal and team process model

## Personal and process model

- Emphasizes personal measurement of both work products and the quality of the work products
- Stresses importance of identifying errors early and to understand the types of errors likely to be made
- Framework activities
  : - Planning: size and resource estimates based on requirements.
  : - High-level design: external specifications developed for components and component level design is created.
  : - High-level design review: formal verification methods used to uncover design errors, metrics maintained for important tasks.
  : - Development component level design refined, code is generated, reviewed, compiled, and tested, metric maintained for important tasks and work results.
  : - Postmortem effectiveness of processes is determined using measures and metrics. collected, results of analysis should provide guidance for modifying the process to improve its effectiveness.

## Team process model

- Objectives
  : - Build self-directed teams that plan and track their work, establish goals, and own their processes and plans
  : - Show managers how to coach and motivate their teams and maintain peak performance
  : - Accelerate software process improvement by making CCM Level 5 behavior normal and expected
  : - Provide improvement guidance to high-maturity organizations
  : - Facilitate university teaching of industrial team skills
- Scripts for Project Activities
  : - Project launch
  : - High Level Design
  : - Implementation
  : - Integration and system testing
  : - Postmortem

<br>

# Process technology tools

- Used to adapt process models to be used by software project team
- Allow organizations to build automated models of common process framework, task sets, and umbrella activities
- These automated models can be used to determine workflow and examine alternative process structures
- Tools can be used to allocate, monitor, and even control all software engineering tasks defined as part of the process model

<br>

---

<br>

    üñãÔ∏è This is my self-taught blog! Feel free to let me know
    if there are some errors or wrong parts üòÜ

[Back to Top](#){: .btn .btn--primary }{: .align-right}
