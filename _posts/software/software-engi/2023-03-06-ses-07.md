---
title: "[Software] C.6 Principles that Guide Practice"

categories:
  - Software
tags:
  - [Principle]

toc: true
toc_sticky: true

date: 2023-03-06
last_modified_at: 2023-03-06
---

<!-- {% capture notice-2 %}

üìã This is the tech-news archives to help me keep track of what I am interested in!

- Reference tech news link: <https://thenextweb.com/news/blockchain-development-tech-career>
  {% endcapture %}

<div class="notice--danger">{{ notice-2 | markdownify }}</div> -->

üìã This is my note-taking from what I learned in the class "Software Engineering Fundamentals - COMP 120-002"
{: .notice--danger}

## Principles that Guide Process

1. Be agile.
   : Whether the process model you choose is prescriptive or agile, the basic tenets of agile development should govern your approach.
2. Focus on quality at every step.
   : The exit condition for every process activity, action, and task should focus on the quality of the work product that has been produced.
3. Be ready to adapt.
   : Process is not a religious experience and dogma has no place in it. When necessary, adapt your approach to constraints imposed by the problem, the people, and the project itself.
4. Build an effective team.
   : Software engineering process and practice are important, but the bottom line is people. Build a self-organizing team that has mutual trust and respect.
5. Establish mechanisms for communication and coordination.
   : Projects fail because important information falls into the cracks and/or stakeholders fail to coordinate their efforts to create a successful end product.
6. Manage change.
   : The approach may be either formal or informal, but mechanisms must be established to manage the way changes are requested, assessed, approved and implemented.
7. Assess risk.
   : Lots of things can go wrong as software is being developed. It‚Äôs essential that you establish contingency plans.
8. Create work products that provide value for others.
   : Create only those work products that provide value for other process activities, actions or tasks.

<br>

## Principles that Guide Practice

1. Divide and conquer.
   : Stated in a more technical manner, analysis and design should always emphasize separation of concerns (SoC).
2. Understand the use of abstraction.
   : At it core, an abstraction is a simplification of some complex element of a system used to communication meaning in a single phrase(simply).
3. Strive for consistency.
   : A familiar context makes software easier to use.
4. Focus on the transfer of information.
   : Pay special attention to the analysis, design, construction, and testing of interfaces.
5. Build software that exhibits effective modularity.
   : Separation of concerns (Principle #1) establishes a philosophy for software. Modularity provides a mechanism for realizing the philosophy. Provides a mechanism for realizing the philosophy of Separation of concerns.
6. Look for patterns.
   : Brad Appleton [App00] suggests that: ‚ÄúThe goal of patterns within the software community is to create a body of literature to help software developers resolve recurring problems encountered throughout all of software development".
7. Use multiple viewpoints.
   : When possible, represent the problem and its solution from a number of different perspectives.
8. Some consumes your work products.
   : Remember that someone will maintain the software.

<br>

## Simplified Process Framework

![SimplifiedProcessF](../../../assets/images/SimplifiedProcessF.png)

<br>

## Communication Principles

1. Listen.
   : Try to focus on the speaker‚Äôs words, rather than formulating your response to those words.
2. Prepare before you communicate.
   : Spend the time to understand the problem before you meet with others.
3. Someone should facilitate the activity.
   : Every communication meeting should have a leader (a facilitator) to keep the conversation moving in a productive direction; (2) to mediate any conflict that does occur, and (3) to ensure than other principles are followed.
4. Face-to-face communication is best.
   : But it usually works better when some other representation of the relevant information is present. Visual representations of information can be helpful.
5. Take notes and document decisions.
   : Someone participating in the communication should serve as a ‚Äúrecorder‚Äù and write down all important points and decisions.
6. Strive for collaboration.
   : Collaboration and consensus occur when the collective knowledge of members of the team is combined.
7. Stay focused, modularize your discussion.
   : The more people involved in any communication, the more likely that discussion will bounce from one topic to the next.
8. If something is unclear, draw a picture.
9. Move on:
   : - a) Once you agree to something, move on.
   : - b) If you can‚Äôt agree to something, move on.
   : - c) If a feature or function is unclear and cannot be clarified at the moment, move on.
10. Negotiation is not a contest or a game. It works best when both parties win.

<br>

## Communications Mode Effectiveness

![CommunicationMode](../../../assets/images/CommunicationMode.png)

<br>

## Planning Principles

1. Understand the scope of the project.
   : It‚Äôs impossible to use a roadmap if you don‚Äôt know where you‚Äôre going. Scope provides the software team with a destination as the roadmap is created.
2. Involve the customer in the planning activity.
   : The customer defines priorities and establishes project constraints.
3. Recognize that planning is iterative.
   : A project plan is never engraved in stone. As work begins, it very likely that things will change.
4. Estimate based on what you know.
   : The intent of estimation is to provide an indication of effort, cost, and task duration, based on the team‚Äôs current understanding of the work to be done.
5. Consider risk as you define the plan.
   : If you have identified risks that have high impact and high probability, contingency planning is necessary. Contingency planning is needed for identified high impact and high probability risks.
6. Be realistic.
   : People don‚Äôt work 100 percent of every day.
7. Adjust granularity as you define the plan.
   : Granularity refers to the level of detail that is introduced as a project plan is developed.
8. Define how you intend to ensure quality.
   : The plan should identify how the software team intends to ensure quality.
9. Describe how you intend to accommodate change.
   : Even the best planning can be obviated by uncontrolled change.
10. Track the plan frequently and make adjustments as required.
    : Software projects fall behind schedule one day at a time.

<br>

## Iterative Planning Process

![IterativePlanning](../../../assets/images/IterativePlanning.png)

<br>

## Modeling Principles

### <u>Software Modeling</u>

![SoftwareModeling](../../../assets/images/SoftwareModeling.png)

### <u>Agile Modeling Principles</u>

1. The primary goal of the software team is to build software, not create models.
2. Travel light ‚Äì don‚Äôt create more models than you need.
3. Strive to produce the simplest model that will describe the problem or the software.
4. Build models in a way that makes them amenable to change.
5. Be able to state an explicit purpose for each model that is created.
6. Adapt the models you create to the system at hand.
7. Try to build useful models, forget abut building perfect models.
8. Don‚Äôt become dogmatic about model syntax. Successful communication is key.
9. If your instincts tell you a paper model isn‚Äôt right you may have a reason to be concerned.
10. Get feedback as soon as you can.

{% capture notice-2 %}

In software engineering work, two classes of models can be created:

1. "Requirements models (also called analysis models)" represent the customer requirements by depicting the software in three different domains: the information domain, the functional domain, and the behavioral domain.
2. "Design models" represent characteristics of the software that help practitioners to construct it effectively: the architecture, the user interface, and component-level detail.
   {% endcapture %}

<div class="notice--info">{{ notice-2 | markdownify }}</div>

### <u>Requirements Modeling Principles</u>

1. The information domain of a problem must be represented and understood.
2. The functions that the software performs must be defined.
3. The behavior of the software (as a consequence of external events) must be represented.
4. The models that depict information, function, and behavior must be partitioned in a manner that uncovers detail in a layered (or hierarchical) fashion.
5. The analysis task should move from essential information toward implementation detail.

### <u>Design Modeling Principles</u>

1. Design should be traceable to the requirements model.
2. Always consider the architecture of the system to be built.
3. Design of data is as important as design of processing functions.
4. Interfaces (both internal and external) must be designed with care.
5. User interface design should be tuned to the needs of the end-user. Stress ease of use.
6. Component-level design should be functionally independent.
7. Components should be loosely coupled to each other than the environment.
8. Design representations (models) should be easily understandable.
9. The design should be developed iteratively.
10. Creation of a design model does not preclude using an agile appraoch.

### <u>Living Modeling Principles</u>

1. Stakeholder-centric models should target specific stakeholders and their tasks.
2. Models and code should be closely coupled.
3. Bidirectional information flow should be established between models and code.
4. A common system view should be created.
5. Model information should be persistent to allow tracking system changes.
6. Information consistency across all model levels must be verified.
7. Each model element has assigned stakeholder rights and responsibilities.
8. The states of various model elements should be represented.

<br>

## Construction Principles - Coding

The construction activity encompasses a set of coding and testing tasks that lead to operational software that is ready for delivery to the customer or end-user.

Coding principles and concepts are closely aligned programming style, programming languages, and programming methods.

Testing principles and concepts lead to the design of tests that systematically uncover different classes of errors and to do so with a minimum amount of time and effort.

<u>Preparation Principles: Before you write one line of code, be sure you:</u>

1. Understand of the problem you‚Äôre trying to solve.
2. Understand basic design principles and concepts.
3. Pick a programming language that meets the needs of the software to be built and the environment in which it will operate.
4. Select a programming environment that provides tools that will make your work easier.
5. Create a set of unit tests that will be applied once the component you code is completed.

<u>Coding Principles: As you being writing code, be sure you:</u>

1. Constrain your algorithms by following structured programming practice.
2. Consider the use of pair programming.
3. Select data structures that will meet the needs of the design.
4. Understand the software architecture and create interfaces that are consistent with it.
5. Keep conditional logic as simple as possible.
6. Create nested loops in a way that makes them easily testable.
7. Select meaningful variable names and follow other local coding standards.
8. Write code that is self-documenting.
9. Create a visual layout (e.g., indentation and blank lines) that aids understanding.

<u>Validation Principles: After you've completed your first coding pass, be sure you:</u>

1. Conduct a code walkthrough when appropriate.
2. Perform unit tests and correct errors you‚Äôve uncovered.
3. Refactor the code to improve its quality.

<u>Testing Principles: Myers [Mye79] states these rules of testing that can also serve as testing objectives:</u>

1. Testing is a process of executing a program with the intent of finding an error.
2. A good test case is one that has a high probability of finding an as-yet-undiscovered error.
3. A successful test is one that uncovers an as-yet-undiscovered error.

### <u>Testing Principles</u>

Davis [Dav95b] suggests a set of testing principles that have been added to by Everett and Meyer [Eve09]:

1. All tests should be traceable to customer requirements.
2. Tests should be planned long before testing begins.
   : 1. Testing is a process of executing a program with intent of finding an error,
   : 2. A good test case is one that has a high probability of finding an as-yet-undiscovered error.
   : 3. A successful test is one that uncovers an as-yet-undiscovered error.
3. The Pareto principle applies to software testing.
4. Testing should begin ‚Äúin the small‚Äù and progress toward testing ‚Äúin the large‚Äù.
5. Exhaustive testing is not possible.
6. Testing effort for each system module commensurate to expected fault density.
7. Static testing can yield high results.
8. Track defects and look for patterns in defects uncovered by testing.
9. Include test cases that demonstrate software is behaving correctly.

### <u>Agile Testing</u>

![AgileTesting](../../../assets/images/AgileTesting.png)

<br>

## Deployment Principles

1. Customer expectations for the software must be managed.
2. A complete delivery package should be assembled and tested.
3. A support regime must be established before the software is delivered.
4. Appropriate instructional materials must be provided to end-users.
5. Buggy software should be fixed first, delivered later

<br>

## Software Deployment Actions

![SoftwareDeployment](../../../assets/images/SoftwareDeployment.png)

<br>

---

<br>

    üñãÔ∏è This is my self-taught blog! Feel free to let me know
    if there are some errors or wrong parts üòÜ

[Back to Top](#){: .btn .btn--primary }{: .align-right}
