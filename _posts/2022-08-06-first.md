---
layout: single
title:  "코딩테스트 문제 풀이 "
categories: 코딩테스트  
tag: [코딩테스트, 제로베이스 프론트엔드 스쿨 5기] 
toc: true 
author_profile: false
# sidebar: 
#   nav: "docs"
search: true
---


> ### **문제 상세**

[프로그래머스 - 로또의 최고 순위와 최저 순위](https://school.programmers.co.kr/learn/courses/30/lessons/77484?language=java)


> ### **무식하고 엉망진창인 나의 풀이 과정**


***
```js
function solution(lottos, win_nums) {
  var answer = [];

  let count_1 = 0; 
  let count_2 = 0; 

  for (let i = 0; i < lottos.length; i++) {
    for (let j = 0; j < win_nums.length; j++) {
      if (lottos[i] == win_nums[j]) {
        count_1++; 
      }
    }
    if (lottos[i] == 0) {
      count_2++; 
    }
  }

  switch (count_1 + count_2) {
    case 0:   
      answer[0] = 6; break; 
    case 1: 
      answer[0] = 6; break; 
    case 2: 
      answer[0] = 5; break; 
    case 3: 
      answer[0] = 4; break; 
    case 4: 
      answer[0] = 3; break; 
    case 5: 
      answer[0] = 2; break; 
    case 6: 
      answer[0] = 1; break; 
  }

  switch (count_1) {
    case 0:   
      answer[1] = 6; break; 
    case 1: 
      answer[1] = 6; break; 
    case 2: 
      answer[1] = 5; break; 
    case 3: 
      answer[1] = 4; break; 
    case 4: 
      answer[1] = 3; break; 
    case 5: 
      answer[1] = 2; break; 
    case 6: 
      answer[1] = 1; break; 
  }

  return answer;
}
```

> ### **다른 사람들의 풀이로 보는 코드 개선**

***

* count_1과 count_2가 아니라 max, min 값으로 선언하면 훨씬 보기에 깔끔했을 것이다. 
* 이중 for 문을 도는 게 아니라, lottos의 for 문을 돌면서 lottos의 원소들이 win_nums에 있는지를 확인하고 있으면 ++해주는 식으로 생각하면 더 좋을 것 같다. 
* switch 문에서 case 0, 1을 각각 적는 게 아니라 default 값으로 적었으면 더 좋았다. 

```js
let min = 0; 
let max = 0; 

for (let lotto of lottos) {
  if (win_nums.includes(lotto)) {
	min++; 
  }
  if (lotto === 0) {
  	max++; 
  }
}

switch (max + min) {
	default:
		answer.push(6);
		break;
}
switch (min) {
	default:
		answer.push(6);
		break;
}
  
```
* filter를 사용해서, inlcudes인 애들의 길이를 반환해 min 값을 찾을 수도 있었다. !0 = true임을 이용해 0을 카운트하는 방식도 있었다. 그리고 단순히 switch 문을 사용해서 계산하는 게 아니라 const로 랭크값들을 배열에 넣어놓고 index와 value 관계를 활용해 도출하기도 했다. 

```js
function solution(lottos, win_nums) {
  //var answer = [];
  const rank = [6, 6, 5, 4, 3, 2, 1];

  let minCount = lottos.filter(v => win_nums.includes(v)).length;

  let zeroCount = lottos.filter(v => !v).length;

  const maxCount = minCount + zeroCount;

  return [rank[maxCount], rank[minCount]];

  //return answer;
}
```

* 앞선 풀이와 유사했지만 맞춘 개수가 0, 1인 점과 랭크와 맞춘 개수가 모두 정수인 점을 활용해서 1보다 작으면 min을 뺀 값을 넣어주고 1보다 크면 max값을 빼주는 방식의 풀이도 있었다. 

```js
function solution(lottos, win_nums) {

  const answer = [];
  const min = lottos.filter(n => win_nums.includes(n)).length;
  const max = lottos.filter(n => n === 0).length + min;

  max > 1 ? answer.push(7 - max) : answer.push(6);
  min > 1 ? answer.push(7 - min) : answer.push(6);

    return answer;
}

```

* map()과 find()를 활용한 풀이 방식도 좋아보였다. 
```js
function solution(lottos, win_nums) {
  
  const rank = [6, 6, 5, 4, 3, 2, 1];
    let answer = [],
        ans = [],
        ans1 = [];

    lottos.map(x => {
        let val = win_nums.find(y => y == x);

        if(x == 0) ans1.push(x)
        if(val) {
            ans.push(val)
            ans1.push(val)
        }
    })
    answer.push(rank[ans1.length])
    answer.push(rank[ans.length])

    return answer;
}
```

> ### **정리하기**

***


[for...of 개념](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/for...of)

[Array.prototype.filter 개념](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)





  

