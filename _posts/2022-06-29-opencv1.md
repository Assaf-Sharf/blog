---
layout: single
title:  "OpenCV chapter 1"
categories : OpenCV
tag : [python, OpenCV]
toc: true
toc_sticky: true
---

![header](https://capsule-render.vercel.app/api?type=waving&color=a2dcec&height=300&section=header&text=OpenCV chapter 1&fontSize=40&animation=fadeIn&fontAlignY=38&fontColor=FFFFFF)

- 참고
  - https://github.com/dltpdn/insightbook.opencv_project_python 
  - [귀퉁이서재_opencv](https://bkshin.tistory.com/entry/OpenCV-1-%ED%8C%8C%EC%9D%B4%EC%8D%AC%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%9C%EB%8A%94-OpenCV-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8?category=1148027)



## 목차

1. 이미지 다루기
2. 영상 다루기
3. 이미지 내 관심영역(ROI) 표시
4. 이미지 색상 표현 방식(BGR, HSV, YUV)



## 1. 이미지 다루기



### 이미지 읽기

cv2.imread() : 함수를 이용하여 이미지 파일을 읽습니다. 이미지 파일의 경로는 절대/상대경로가 가능합니다.

Parameters : fileName : 이미지파일의 경로 , flag : 이미지 파일 읽을 때의 추가설정, return : numpy.ndarray

- flag 종류


```python
cv2.IMREAD_COLOR(이미지 파일을 Color로 읽어들입니다. 투명한 부분은 무시되며, Default값입니다.)

cv2.IMREAD_GRAYSCALE(이미지를 Grayscale로 읽어 들입니다. 실제 이미지 처리시 중간단계로 많이 사용합니다.)

cv2.IMREAD_UNCHANGED(이미지파일을 alpha channel까지 포함하여 읽어 들입니다.)

flag 대신 1,0,-1로도 가능
```


```python
img = cv2.imread('test_image.jpg', cv2.IMREAD_COLOR)
```


```python
img.shape
```


    (225, 400, 3)



&nbsp;

### 이미지 보기

cv2.imshow() : 함수는 이미지를 사이즈에 맞게 보여줍니다.

parameters : title(윈도우 창의 Title), image(cv2.imread() 의 return값)

cv2.waitKey() 는 keyboard입력을 대기하는 함수로 0이면 key입력까지 무한대기이며 특정 시간동안 대기하려면 milisecond값을 넣어주면 됩니다.

cv2.destroyAllWindows() 는 화면에 나타난 윈도우를 종료합니다. 일반적으로 위 3개는 같이 사용됩니다.


```python
fname = 'test_image.jpg'

original = cv2.imread(fname, cv2.IMREAD_COLOR)
gray = cv2.imread(fname, cv2.IMREAD_GRAYSCALE)
unchange = cv2.imread(fname, cv2.IMREAD_UNCHANGED)

cv2.imshow('Original', original)
cv2.imshow('Gray', gray)
cv2.imshow('Unchange', unchange)

cv2.waitKey(0)
cv2.destroyAllWindows()
```

&nbsp;

### 이미지 저장하기

cv2.imwrite() 함수를 이용하여 변환된 이미지나 동영상의 특정 프레임을 저장합니다.

parameter : fileName(저장될 파일명), image(저장할 이미지)


```python
img = cv2.imread('test_image.jpg', cv2.IMREAD_GRAYSCALE)
cv2.imshow('image',img)
k = cv2.waitKey(0)
if k == 27: # esc key
    cv2.destroyAllWindow()
elif k == ord('s'): # 's' key
    cv2.imwrite('lenagray.png',img)
    cv2.destroyAllWindows()
```

&nbsp;

### Matplotlib 사용하기

Matplotlib는 다양한 plot기능을 가진 Python Plot Library입니다. 이미지를 zoom하거나 하나의 화면에 여러개의 이미지를 보고자 할 때 유용합니다.


```python
img = cv2.imread('test_image.jpg', cv2.IMREAD_COLOR)


plt.imshow(img)
plt.xticks([]) # x축 눈금
plt.yticks([]) # y축 눈금
plt.show()
```


![png](/images/2022-06-29-opencv1/output_21_0.png)
    


openCV는 BGR로 사용하지만, Matplotlib는 RGB로 이미지를 보여주기 때문에 색이 이상하게 나옴

b,g,r -> r,g,b로 바꾸면 가능


```python
img = cv2.imread('test_image.jpg', cv2.IMREAD_COLOR)

b, g, r = cv2.split(img)   # img파일을 b,g,r로 분리
img2 = cv2.merge([r,g,b]) # b, r을 바꿔서 Merge

plt.imshow(img2)
plt.xticks([]) # x축 눈금
plt.yticks([]) # y축 눈금
plt.show()
```


![png](/images/2022-06-29-opencv1/output_24_0.png)
    


## 2. 영상 다루기



### Camera로 부터 영상 재생

- Camera로부터 영상을 읽어, 화면에 보옂기 위해서 아래와 같은 순서로 진행

  - VideoCapture Object를 생성합니다. 변수로는 camera device index나 동영상 파일명을 넘겨줍니다. 일반적으로 0 이면 Camera와 연결

  - Loop를 돌면서 frame을 읽어 들입니다.

  - 읽은 frame에 대해서 변환작업을 수행한 후, 화면에 보여줍니다.

  - 영상 재생이 끝나면, VideoCapure Object를 release하고 window를 닫습니다.


```python
# cap 이 정상적으로 open이 되었는지 확인하기 위해서 cap.isOpen() 으로 확인가능
cap = cv2.VideoCapture(0)

# cap.get(prodId)/cap.set(propId, value)을 통해서 속성 변경이 가능.
# 3은 width, 4는 heigh

print('width: {0}, height: {1}'.format(cap.get(3),cap.get(4)))
cap.set(3,320)
cap.set(4,240)

while(True):
    # ret : frame capture결과(boolean)
    # frame : Capture한 frame
    ret, frame = cap.read()

    if (ret):
        # image를 Grayscale로 Convert함.
        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

        cv2.imshow('frame', gray)
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

cap.release()
cv2.destroyAllWindows()
```

    width: 640.0, height: 480.0


&nbsp;

### File로 부터 영상 재생

File로 부터 동영상 재생도 Camera에서 영상 재생과 동일합니다.


```python
cap = cv2.VideoCapture('vtest.avi')

while(cap.isOpened()):
    ret, frame = cap.read()
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    cv2.imshow('frame',gray)

    if cv2.waitKey(1) & 0xFF == ord('q'):
        break
cap.release()
cv2.destroyAllWindows()
```

&nbsp;

### 영상 저장

영상을 저장하기 위해서는 cv2.VideoWriter Object를 생성해야 합니다.

- parameter

  - outputFile : 저장될 파일명
  - fourcc : Codec정보. cv2.VideoWriter_fourcc()
  - frame : 초당 저장될 frame
  - size : 저장될 사이즈

fourcc정보는 cv2.VideoWriter_fourcc('M','J','P','G') 또는 cv2.VideoWriter_fourcc(*'MJPG) 와 같이 표현할 수 있습니다. 


```python
cap = cv2.VideoCapture(0)

# video recorder
fourcc =  cv2.VideoWriter_fourcc(*'XVID')  # cv2.VideoWriter_fourcc() does not exist
out = cv2.VideoWriter("output.avi", fourcc, 25.0, (640,480))

# record video
while (cap.isOpened()):
    ret, frame = cap.read()

    if ret:
        # 이미지 반전,  0:상하, 1 : 좌우
        frame = cv2.flip(frame, 0)

        out.write(frame)

        cv2.imshow('frame', frame)

        if cv2.waitKey(0) & 0xFF == ord('q'):
            break
    else:
        break

cap.release()
out.release()
cv2.destroyAllWindows()
```



## 3. 이미지 내 관심영역(RoI) 표시

- 관심 영역(ROI)이란 말 그대로 영상 내에서 관심이 있는 영역을 뜻함
- 임의의 사진으로 확인하면서 설명


```python
def imshow(a):
    globals()['img'] = cv2.imread(f'{a}', cv2.IMREAD_COLOR)
    b, g, r = cv2.split(img)   # img파일을 b,g,r로 분리
    img2 = cv2.merge([r,g,b]) # b, r을 바꿔서 Merge

    plt.imshow(img2)
    plt.xticks([]) # x축 눈금
    plt.yticks([]) # y축 눈금
    plt.show()
```


```python
def imsave(a,b):
    cv2.imshow("img", a)
    cv2.imwrite(f'{b}',a)
    cv2.destroyAllWindows()

    imshow(f'{b}')
```


```python
imshow('roi.jpg')
```


![png](/images/2022-06-29-opencv1/output_41_0.png)
​    


### 태양 위치 주위를 사각형으로 표시


```python
x=320; y=150; w=50; h=50        # roi 좌표
roi = img[y:y+h, x:x+w]         # roi 지정     

print(roi.shape)                # roi shape, (50,50,3)
cv2.rectangle(roi, (0,0), (h-1, w-1), (0,255,0)) # roi 전체에 사각형 그리기 

# --- cv2 창으로 보기 ---
# cv2.imshow("img", img)
# key = cv2.waitKey(0)
# print(key)
# cv2.destroyAllWindows()

imsave(img,'roi_rec.png')
```

    (50, 50, 3)


![png](/images/2022-06-29-opencv1/output_43_1.png)
    


cv2.imread() 함수를 실행하면 이미지를 numpy 배열로 반환, numpy 배열은 슬라이싱이 가능, 원하는 영역을 지정하기 위해서는 이미지 numpy 배열을 슬라이싱 하면 됩니다. 위 코드에서 img[y:y+h, x:x+w]는 원하는 영역을 슬라이싱 합니다. 즉, roi 변수에는 관심 영역인 태양을 슬라이싱 한 numpy 배열이 담깁니다.

cv2.rectangle(roi, (0,0), (h-1, w-1), (0,255,0))은 태양 부분만 슬라이싱 한 roi 이미지의 (0, 0)부터 (h-1, w-1)까지 (0, 255, 0) 색으로 사각형을 표시하는 코드
    

    - (0, 0)은 좌측 상단
    - (h-1, w-1)은 우측 하단
    - RGB 값인 (0, 255, 0)은 녹색

### 관심영역 복제 및 새 창에 띄우기 


```python
x=320; y=150; w=50; h=50
roi = img[y:y+h, x:x+w]     # roi 지정
img2 = roi.copy()           # roi 배열 복제 

img[y:y+h, x+w:x+w+w] = roi # 새로운 좌표에 roi 추가, 태양 2개 만들기
cv2.rectangle(img, (x,y), (x+w+w, y+h), (0,255,0)) # 2개의 태양 영역에 사각형 표시


imsave(img,'roi_2.png') # 원본 이미지 출력
imsave(img2,'roi_point.png') # roi 만 따로 출력
```


![png](/images/2022-06-29-opencv1/output_47_0.png)
​    




![png](/images/2022-06-29-opencv1/output_47_1.png)
    


### 마우스 드래그로 관심 영역 표시하기

- 관심 영역을 관심 영역을 표시하기 위해서는 원하는 영역의 좌표와 크기(높이, 너비)가 필요
- 마우스를 통해 번거로운 과정 쉽게 적용


```python
isDragging = False                      # 마우스 드래그 상태 저장 
x0, y0, w, h = -1,-1,-1,-1              # 영역 선택 좌표 저장
blue, red = (255,0,0),(0,0,255)         # 색상 값 

def onMouse(event,x,y,flags,param):     # 마우스 이벤트 핸들 함수  
    global isDragging, x0, y0, img      # 전역변수 참조
    if event == cv2.EVENT_LBUTTONDOWN:  # 왼쪽 마우스 버튼 다운, 드래그 시작 
        isDragging = True
        x0 = x
        y0 = y
    elif event == cv2.EVENT_MOUSEMOVE:  # 마우스 움직임 
        if isDragging:                  # 드래그 진행 중
            img_draw = img.copy()       # 사각형 그림 표현을 위한 이미지 복제
            cv2.rectangle(img_draw, (x0, y0), (x, y), blue, 2) # 드래그 진행 영역 표시
            cv2.imshow('img', img_draw) # 사각형 표시된 그림 화면 출력
    elif event == cv2.EVENT_LBUTTONUP:  # 왼쪽 마우스 버튼 업 
        if isDragging:                  # 드래그 중지
            isDragging = False          
            w = x - x0                  # 드래그 영역 폭 계산
            h = y - y0                  # 드래그 영역 높이 계산
            print("x:%d, y:%d, w:%d, h:%d" % (x0, y0, w, h))
            if w > 0 and h > 0:         # 폭과 높이가 양수이면 드래그 방향이 옳음 
                img_draw = img.copy()   # 선택 영역에 사각형 그림을 표시할 이미지 복제
                # 선택 영역에 빨간 사각형 표시
                cv2.rectangle(img_draw, (x0, y0), (x, y), red, 2) 
                cv2.imshow('img', img_draw) # 빨간 사각형 그려진 이미지 화면 출력
                cv2.imwrite('./red_img.jpg', img_draw) # ROI 영역드래그한 빨간색 사각형 저장 
                roi = img[y0:y0+h, x0:x0+w] # 원본 이미지에서 선택 영영만 ROI로 지정
                cv2.imshow('cropped', roi)  # ROI 지정 영역을 새창으로 표시
                cv2.moveWindow('cropped', 0, 0) # 새창을 화면 좌측 상단에 이동
                cv2.imwrite('./cropped.jpg', roi)   # ROI 영역만 파일로 저장
                print("croped.")
            else:
                cv2.imshow('img', img)  # 드래그 방향이 잘못된 경우 사각형 그림이 없는 원본 이미지 출력
                print("좌측 상단에서 우측 하단으로 영역을 드래그 하세요.")
```


```python
img = cv2.imread('roi.jpg', cv2.IMREAD_COLOR)
cv2.imshow('img', img)
cv2.setMouseCallback('img', onMouse) # 마우스 이벤트 등록 --- 9
cv2.waitKey()
cv2.destroyAllWindows()
```

    x:324, y:160, w:42, h:31
    croped.


- onMouse()라는 콜백 함수를 선언

  - 1. 마우스 왼쪽 버튼을 눌렀을 때

      - 드래그가 시작되었다는 것을 기억하기 위한 isDragging이라는 변수의 상태를 True로 변경, 드래그가 시작된 점을 x0, y0로 지정

  - 2. 누른 상태로 드래그했을 때

      -  img를 복제하고, 복제한 이미지의 (x0, y0)부터 (x, y)까지 파란색 사각형으로 표시, (x0, y0)는 마우스 드래그가 시작된 위치이고, (x, y)는 마우스의 현재 위치

  - 3. 마우스 왼쪽 버튼을 뗄 때

      -  isDragging은 False로 바꾸고, 드래그 영역의 폭은 w, 높이는 h로 계산, w와 h가 모두 양수이면 지정 영역을 빨간색 사각형으로 표시

  - 위의 3단계가 끝나면 이미지를 저장


```python
imshow('red_img.jpg') # 마우스로 표시한 부분
imshow('cropped.jpg') # crop한 부분
```


![png](/images/2022-06-29-opencv1/output_53_0.png)
​    




![png](/images/2022-06-29-opencv1/output_53_1.png)
    


&nbsp;

### selectROI로 관심영역 지정 및 표시, 저장

- 마우스로 관심영역 추출할때 매번 함수를 작성하는것은 번거로움
- OpenCV에서는 이를 간단하게 도와주는 함수를 제공
- 마우스 이벤트 처리를 위한 코드 없이도 관심 영역을 지정 가능

- ret = cv2.selectROI(win_name, img, showCrossHair=True, fromCenter=False)
  - win_name: 관심영역을 표시할 창의 이름
  - img: 관심영역을 표시할 이미지
  - showCrossHair: 선택 영역 중심에 십자 모양 표시 여부
  - fromCenter: 마우스 시작 지점을 영역의 중심으로 지정
  - ret: 선택한 영역의 좌표와 크기 (x, y, w, h); 선택을 취소하면 모두 0으로 지정됨


```python
img = cv2.imread('roi.jpg', cv2.IMREAD_COLOR)
x,y,w,h = cv2.selectROI('img', img, False)
if w and h:
    roi = img[y:y+h, x:x+w]
    cv2.imshow('cropped', roi)                   # ROI 지정 영역을 새창으로 표시
    cv2.moveWindow('cropped', 0, 0)              # 새창을 화면 측 상단으로 이동
    cv2.imwrite('cropped2.jpg', roi)  # ROI 영역만 파일로 저장
    
cv2.imshow('img', img)
cv2.waitKey(0)
cv2.destroyAllWindows()


imshow('cropped2.jpg')
```


![png](/images/2022-06-29-opencv1/output_57_0.png)
    


&nbsp;

## 4. 이미지 색상 표현 방식(BGR, HSV, YUV)

- BGR, BGRA
  - 색상을 표현하는 방법으로 RGB, 빨강, 초록, 파랑 세 가지 색의 빛을 섞어서 원하는 색을 만드는 방식
  - OpenCV는 그 반대의 순서인 BGR로 표현

  - RGBA는 RGB에 A(알파, alpha)가 추가된 색상 표기법, A는 배경의 투명도를 의미


```python
import cv2
from matplotlib import pyplot as plt
import numpy as np
```


```python
# 기본 값 옵션
img = cv2.imread('opencv_logo.png')   
# IMREAD_COLOR 옵션                   
bgr = cv2.imread('opencv_logo.png', cv2.IMREAD_COLOR)    
# IMREAD_UNCHANGED 옵션
bgra = cv2.imread('opencv_logo.png', cv2.IMREAD_UNCHANGED) 
# 각 옵션에 따른 이미지 shape
print("default", img.shape, "color", bgr.shape, "unchanged", bgra.shape) 

cv2.imshow('bgr', bgr)
cv2.imshow('bgra', bgra)
cv2.imshow('alpha', bgra[:,:,3])  # 알파 채널만 표시
cv2.waitKey(0)
cv2.destroyAllWindows()
```

    default (1024, 831, 3) color (1024, 831, 3) unchanged (1024, 831, 4)


![image.png](/images/2022-06-29-opencv1/new1.png)

- 파라미터를 cv2.IMREAD_COLOR로 전달한 것과 아무 파라미터를 전달하지 않은 이미지의 차이는 없음
- 첫 번째와 두 번째 이미지 모두 shape가 (240, 195, 3), 세 번째 이미지는 알파 채널이 하나 더 있어 shape가 (240, 195, 4)
- 세 번째 이미지에서 전경의 알파 값은 255, 배경의 알파 값은 0, 255 = 흰색 , 0 = 검은색
- 첫 번째, 두 번째 이미지와 달리 세 번째 이미지는 알파 채널만 표시했으므로 전경과 배경을 쉽게 분리가능, 이런 이유로 알파 채널은 마스크 채널이라고 함

&nbsp;

### BGR 색상 이미지를 회색조 이미지로 변환하기

- 컬러 이미지를 회색조 이미지로 변환하는 것은 이미지 연산의 양을 줄여서 속도를 높임
- 처음부터 회색조로 읽어 들이는 함수 :  cv2.imread(img, cv2.IMREAD_GRAYSCALE), cv2.imread() 함수의 두 번째 파라미터로 cv2.IMREAD_GRAYSCALE을 전달
- 처음에는 BGR 컬러 이미지로 읽어 들이고 그 이후에 회색조로 변환하는 경우 : cv2.cvtcolor() 함수로 구현


```python
img = cv2.imread('test_image.jpg')

img2 = img.astype(np.uint16)                # dtype 변경 
b,g,r = cv2.split(img2)                     # 채널 별로 분리 b,g,r = img2[:,:,0], img2[:,:,1], img2[:,:,2]

gray1 = ((b + g + r)/3).astype(np.uint8)    # 평균 값 연산후 dtype 변경
gray2 = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # BGR을 그레이 스케일로 변경


cv2.imshow('original', img)
cv2.imshow('gray1', gray1)
cv2.imshow('gray2', gray2)

cv2.waitKey(0)
cv2.destroyAllWindows()
```

![image.png](/images/2022-06-29-opencv1/new2.png)

- gray1 이미지는 평균값을 이용해 회색조 이미지로 표현하는 알고리즘을 직접 구현한 것
- 평균을 구하기 전에 dtype을 unit16으로 변경(3 채널의 값을 합하면 255보다 큰 값이 나올 수 있기 때문에), 평균을 구한 뒤에는 다시 unit8로

- gray2 는 cv2.cvtcolor(img, flag)를 통한 그레이 스케일변경 방법
- flag 파라미터에 cv2.COLOR_BRG2GRAY

- flag parameter은 총 274개, 그중 가장 잘 사용되는 parameter 설명
  - cv2.COLOR_BGR2GRAY: BGR 색상 이미지를 회색조 이미지로 변환
  - cv2.COLOR_GRAY2BGR: 회색조 이미지를 BGR 색상 이미지로 변환
  - cv2.COLOR_BGR2RGB: BGR 색상 이미지를 RGB 색상 이미지로 변환
  - cv2.COLOR_BGR2HSV: BGR 색상 이미지를 HSV 색상 이미지로 변환
  - cv2.COLOR_HSV2BGR: HSV 색상 이미지를 BGR 색상 이미지로 변환
  - cv2.COLOR_BGR2YUV: BGR 색상 이미지를 YUV 색상 이미지로 변환
  - cv2.COLOR_YUV2BGR: YUB 색상 이미지를 BGR 색상 이미지로 변환

&nbsp;

### HSV 방식

- HSV 방식은 RGB와 마찬가지로 3개의 채널을 갖는 색상 이미지 표현법
- 3개의 채널은 H(Hue, 색조), S(Saturation, 채도), V(Value, 명도)

![image.png](/images/2022-06-29-opencv1/image-20220629222836184.png)

위 그림을 통해 확인하면

    - H 값은 이미지가 어떤 색상인지 나타내는 값
    - S는 이미지의 색상이 얼마나 순수하게 포함되어 있는지를 나타내는 값
    - V는 색상이 얼마나 밝은지 어두운지 나타내는 값

cv2.cvtColor() 함수에서 두 번째 파라미터로 cv2.COLOR_BGR2HSV 넣어주면  BGR -> HSV 으로 변환, cv2.COLOR_HSV2BGR은 HSV -> BGR

### BGR을 HSV로 변환


```python
#BGR 컬러 스페이스로 원색 픽셀 생성
red_bgr = np.array([[[0,0,255]]], dtype=np.uint8)   # 빨강 값만 갖는 픽셀
green_bgr = np.array([[[0,255,0]]], dtype=np.uint8) # 초록 값만 갖는 픽셀
blue_bgr = np.array([[[255,0,0]]], dtype=np.uint8)  # 파랑 값만 갖는 픽셀
yellow_bgr = np.array([[[0,255,255]]], dtype=np.uint8) # 노랑 값만 갖는 픽셀

#BGR 컬러 스페이스를 HSV 컬러 스페이스로 변환
red_hsv = cv2.cvtColor(red_bgr, cv2.COLOR_BGR2HSV);
green_hsv = cv2.cvtColor(green_bgr, cv2.COLOR_BGR2HSV);
blue_hsv = cv2.cvtColor(blue_bgr, cv2.COLOR_BGR2HSV);
yellow_hsv = cv2.cvtColor(yellow_bgr, cv2.COLOR_BGR2HSV);

#HSV로 변환한 픽셀 출력
print("red:",red_hsv)
print("green:", green_hsv)
print("blue", blue_hsv)
print("yellow", yellow_hsv)
```

    red: [[[  0 255 255]]]
    green: [[[ 60 255 255]]]
    blue [[[120 255 255]]]
    yellow [[[ 30 255 255]]]


- 색상을 알아내기 위해서 RGB 방식은 세 가지 채널의 값을 모두 알아야 하지만, HSV 방식은 오직 H값 하나만 알면 되므로 좀 더 편리하고 효과적

&nbsp;

### YUV, YCbCr 방식

- Y는 밝기, U는 밝기와 파란색과의 색상 차, V는 밝기와 빨간색과의 색상 차를 의미
- Y에는 많은 비트수를 할당하고 U와 V에는 적은 비트수를 할당하여 데이터를 압축하는 효과를 가짐
- 아래는 Y=0.5일 때, V와 U에 따른 YUV 방식의 색상 이미지 영역

![image.png](/images/2022-06-29-opencv1/image-20220629222916727.png)

&nbsp;

### BGR 값을 YUV 


```python
#BGR 컬러 스페이스로 3가지 밝기의 픽셀 생성
dark = np.array([[[0,0,0]]], dtype=np.uint8)        # 3 채널 모두 0인 가장 어두운 픽셀
middle = np.array([[[127,127,127]]], dtype=np.uint8) # 3 채널 모두 127인 중간 밝기 픽셀
bright = np.array([[[255,255,255]]], dtype=np.uint8) # 3 채널 모두 255인 가장 밝은 픽셀

#BGR 컬러 스페이스를 YUV 컬러 스페이스로 변환
dark_yuv = cv2.cvtColor(dark, cv2.COLOR_BGR2YUV)
middle_yuv = cv2.cvtColor(middle, cv2.COLOR_BGR2YUV)
bright_yuv = cv2.cvtColor(bright, cv2.COLOR_BGR2YUV)

#YUV로 변환한 픽셀 출력
print("dark:",dark_yuv)
print("middle:", middle_yuv)
print("bright", bright_yuv)
```

    dark: [[[  0 128 128]]]
    middle: [[[127 128 128]]]
    bright [[[255 128 128]]]


- BGR값은 (0, 0, 0), (127, 127, 127), (255, 255, 255)로 어두운 픽셀, 중간 밝기의 픽셀, 가장 밝은 픽셀
- YUV 방식으로 변환하면 각각 (0, 128, 128), (127, 128, 128), (255, 128, 128)
- 두 번째, 세 번째 값은 동일한데 Y값만 변화
- 밝기에 좀 더 신경을 써야 한다면 BGR 방식보다 YUV 방식을 사용하는 것이 더 현명한 방법

&nbsp;

## OpenCV chapter 1 후기

- OpenCV에서 색상을 표현하는 방식은 네 가지(BGR 방식, BGRA 방식, HSV 방식, YUV 방식)
- BGR 방식은 전통적인 RGB 방식과 유사하며 그 순서만 반대
- BGRA 방식은 BGR 방식에서 투명도를 나타내는 A(알파) 값이 추가된 방식
- HSV 방식은 색조, 채도, 명도를 이용해서 색상을 표현하는 방식으로 H만 알면 색조는 어느 정도 파악이 가능, 색조를 한눈에 알고자 한다면 HSV 방식을 사용
- YUV 방식은 밝기에 더 신경을 써야 하는 경우에 사용
- 기본적인 image 읽고 쓰기 쉽지만 출력이 RGB -> BGR 반대라는 점만 고려한다면 사용에 문제는 없음

&nbsp;