# 2023-01-02-9

# 9장 프로시저

프로시저는 독립적으로 실행되거나 다른 프로그램으로부터 실행될 수 있는 완전한 프로그램입니다 .반복 수행되어야 하는 프로그램의 경우 생성하여 재활용이 가능합니다.

프로시저 생성 구문 코드

```sql
CREATE OR REPLACE PROCEDURE <proc_name> (<param>)
IS 또는 AS
	<vairable declaration>
BEGIN
	<logic>
EXCEPTION
	<exception>
END <proc_name>;
/
```

### 입/출력 매개변수

프로시저 생성 시 입,출력 값을 설정할 수 있으며, IN 옵션을 사용하여 입력 매개변수를, OUT 옵션을 사용하여 출력 매개변수를, IN OUT 옵션을 사용하여 입, 출력 매개변수를 설정할 수 있습니다.

| 매개변수 타입 | 설명 |
| --- | --- |
| IN | 프로시저 안으로 호출 프로그램의 상수 값을 전달하는 매개변수를 선언하며 전달되는 값이 NULL 일 경우 기본값(default)을 설정 할 수도 있음 |
| OUT | 호출 프로그램으로 프로시저의 결과 값을 전달하는 매개 변수를 선언 |
| IN OUT | 프로시저 안으로 호출 프로그램의 상수 값을 전달하고 결과 값을 다시 호출 프로그램으로 전달 하는 매개변수를 선언 |

아래 프로시저는 부서 번호를 입력 받아 부서 인원 수를 반환하는 프로시저 입니다. 부서 번호를 변수로 입력받아 o_emp_count 출력 변수에 부서별 인원 수를 출력하는 간단한 예입니다.

p_deptno는 입력 매개변수 이므로 IN과 함께 NUMBER 데이터 타입으로 선언하였으며, 이 값이 NULL이면 기본값인 20으로 설정하도록 하였습니다. 출력 매개변수인 o_emp_count는 NUMBER 데이터 타입으로 선언한 예입니다.

```sql
--프로시저 선언
CREATE OR REPLACE PROCEDURE emp_count
	(p_deptno IN NUMBER default 20, -- 입력
	o_emp_count OUT NUMBER) --출력
IS

--커서 선언
CURSOR get_emp_data IS
	SELECT COUNT(*)
	FROM emp
	WHERE deptno = p_deptno;

I_count NUMBER;

BEGIN
	-- 커서 오픈
	 OPEN get_emp_data;
	
	-- 커서 FETCH
	FETCH get_emp_data INTO I_count;
	
	--출력 변수에 값 입력
	o_emp_count := I_count;

	--커서 CLOSE
	CLOSE get_emp_data;
END emp_count;
/
```

IN OUT 예제

전화번호를 입력 받아 ‘-’문자를 제외하고 숫자만 리턴 되도록 하는 예

```sql
CREATE OR REPLACE PROCEDURE replace_phone (p_phone IN OUT VARCHAR2)
IS
BEGIN
	p_phone := REPLACE(p_phone, '-');
END replace_phone;
/
```

프로시저 실행 방법

```sql
--PL/SQL 블록 이용
BEGIN
	<proc_name>
END;

-- SQL PLUS
EXEC <proc_name>
```

우선 OUT 변수를 통해 최종 저장할 o_cnt 변수 선언 emp-count 프로시저에서 정의된 매개변수 위치에 맞추어 부서 번호와 출력 변수를 차례대로 입력하면 됩니다.

```sql
DECLARE
	--프로시저 OUT 값을 저장할 출력 변수 선언
	o_cnt NUMBER;
BEGIN

	--순차적으로 해당 위치에 값 전달
	emp_count(10,o_cnt);
	DBMS_OUTPUT.PUT_LINE('EMP COUNT :'|| o_cnt);

	--매개변수 생략 시 매개변수 이름을 이용하여 값 전달
	emp_count(o_emp_count => o_cnt);
	DBMS_OUTPUT.PUT_LINE('EMP COUNT :' || o_cnt);

	--위치와 변수의 이름을 이용하는 방법을 조합하여 전달
	emp_count(30, o_emp_count => o_cnt);
	DBMS_OUTPUT.PUTLINE('EMP COUNT:'|| o_cnt);

END;
/

```

위와 같이 실행하면 첫 번째와 세 번째의 경우는 IN 매개변수를 통해 선언된 P_DEPTNO 변수에 10 또는 30이 전달되고 , 값이 없는 두 번째의 경우에는 기본값인 20이 입력 값으로 사용 됩니다. 그리고 프로시저의 결과 값은 OUT 매개변수를 통해 o_cnt라는 변수에 저장됩니다.

SQLPLUS를 이용하여 프로시저를 수행할 경우에는 변수 값을 전달하기 위해 우선 VAR 명령어로 변수를 선언하고 매개변수 입력 시 해당 변수 이름에 콜론(:)을 추가하여 사용하면 됩니다.

```sql
DECLARE
	o_phone VARCHAR2(15) := '010-2222-9999'
BEGIN
	replace_phone(o_phone); -- procedure
	DBMS_OUTPUT.PUT_LINE('Phone Number:' || o_phone);
END;
/

```

서브 프로그램 선언

프로시저나 함수 안에서 해당 프로그램에서만 반복해서 사용되는 루틴이 있을 경우, 서브 프로그램을 생성할 수 있습니다.

DECLARE 절과 IS 절에서 프로시저나 함수를 선언한 후 사용하면 됩니다.

다음은 PL/SQL 블록 내에서만 사용되는 서브 프로그램을 생성한 예입니다. 익명 블록 절이므로 DECLARE문 다음에 프로시저를 선언하였습니다.

```sql
DECLARE
	I_empno NUMBER(6) := 120;
	I_bonus NUMBER(6) := 50;
	
	PROCEDURE raise_salary_proc (p_empno NUMBER, p_amount NUMBER)-- 프로시저 선언
	IS
	BEGIN
		UPDATE emp SET sal = sal + p_amount
		WHERE empno = p_empno;
	END;

BEGIN
	raise_salary_proc(I_EMPNO, I_bonus);
END;
/
```

### 컴파일 도중 에러 발생 시 확인 방법

프로시저나 함수, 패키지 등을 생성할 경우 오타가 있거나 문법에 오류가 있으면 에러가 발생합니다.

발생한 오류가 무엇이고 몇 번째 라인 등에서 발생했는지 확인하려면 SHOW ERRORS 명령어를 수행 합니다. PL/SQL Developer, TOAD 등과 같은 GUI 툴을 사용할 경우에는 메시지 박스 또는 하단의 메시지 창에서 에러 로그를 확인할 수 있습니다.

프로시저 Invalid 시 재컴파일 방법

프로시저에서 참조하고 있는 테이블의 구조가 변경되었거나, 프로시저가 변경 되었을 경우 변경된 사항을 반영하기 위해 프로시저의 상태(Status)가 INVALID로 변경 됩니다. 이러한 경우 INVALID 상태가 되었더라도 대부분의 경우 다음 번 실행 시에 오라클이 자동으로 컴파일을 시도하기 때문에 문제가 되지는 않습니다.

그러나 오브젝트 변경 후 관련된 패키지, 프로시저, 함수에 대해 일괄적 컴파일 수행하거나, 어떤 이유에서 자동 컴파일이 완료 되지 못했을 경우에는 아래 명령어를 이용하여 컴파일을 메뉴얼하게 수행할 수 있습니다

ALTER PROCEDURE Proc_name COMPILE;