---
layout : single
title : Spring 게시판 만들기(23)
categories: SPRING
tags: [SPRING, JQUERY, AJAX]
toc:  true
toc_icon: "bars"
toc_sticky: true
author_profile: true
sidebar:
  nav: "docs"
---

> ### 댓글기능 목록 요청작업

handlebars 기능 추가

~~~xml
<!-- https://mvnrepository.com/artifact/com.github.jknack/handlebars -->
<dependency>
    <groupId>com.github.jknack</groupId>
    <artifactId>handlebars</artifactId>
    <version>4.3.0</version>
</dependency>

<!-- 자바스크립트 handlebas 최신 -->
<script src="https://cdn.jsdelivr.net/npm/handlebars@latest/dist/handlebars.js"></script>
~~~

> ##### handlebars 연습

동작은 안됨

https://jsfiddle.net/eu81273/Lqg0yrve/ 참조

~~~html
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/handlebars@latest/dist/handlebars.js"></script>

<script id="demo-template" type="text/x-handlebars-template">
<table>
	<thead>
		<th>이름</th>
		<th>아이디</th>
		<th>메일주소</th>
	</thead>
	<tbody>
		{{#users}}
		<tr>
			<td>{{name}}</td>
			<td>{{id}}</td>
			<td>{{email}}</td>
		</tr>
		{{/users}}
	</tbody>
</table>
</script>

<script>
// 핸들바 템플릿 가져오기
let source = $("#demo-template").html();

// 핸들바 템플릿 컴파일
let template = Handlebars.compile(source); 

//핸들바 템플릿에 바인딩할 데이터
// 데이터. 실제작업은 스프링에서 JSON형식으로 받을 것
let data = {
		users: [
			{name:"홍길동1", id:"user01", email:"user01@abc.com"},
			{name:"홍길동2", id:"user02", email:"user02@abc.com"},
			{name:"홍길동3", id:"user03", email:"user03@abc.com"},
			{name:"홍길동4", id:"user04", email:"user04@abc.com"},
			{name:"홍길동5", id:"user05", email:"user05@abc.com"}
		]
};

// 핸들바 템플릿에 데이터를 바인딩해서 HTML 생성
let html = template(data);

// 생성된 HTML을 DOM에 주입
$("body").append(html);
</script>

</head>
<body>

</body>
</html>
~~~

> ##### ReplyController RestAPI 활용 주소 넣기

~~~java
// 1) 댓글목록데이터, 2) 페이징정보를 JSON포맷으로 클라이언트에게 리턴해주는 작업
// 주소 : /pages/{bno}/{page}. 주소의 일부분을 파라미터값으로 사용하고자 할 경우
// 예> /page/1/1
@GetMapping(value = "/pages/{bno}/{page}", produces = {MediaType.APPLICATION_XML_VALUE, MediaType.APPLICATION_JSON_UTF8_VALUE})
public ResponseEntity<Map<String, Object>> getList(@PathVariable("page") int page,@PathVariable("bno") Long bno){
    ResponseEntity<Map<String, Object>> entity = null;
    Map<String, Object> map = new HashMap<String, Object>();

    // 1) 댓글목록 작업

    // 2) 페이징정보 작업


    return entity;
}
~~~

---

> ##### ReplyMapper.xml에 SQL 구문 작업

~~~xml
<select id="getListWithPaging" result="com.demo.domain.ReplyVO">
	<![CDATA[
	SELECT RN, RNO, BNO, REPLY, REPLYER, REPLYDATE, UPDATEDATE
	FROM ( SELECT /*+ INDEX_DESC(TBL_BOARD PK_REPLY) */ ROWNUM RN, RNO, BNO, REPLY, REPLYER, REPLYDATE, UPDATEDATE
	       FROM TBL_REPLY
	       WHERE BNO = #{bno} AND ROWNUM <= #{cri.pageNum} * #{cri.amount})
	WHERE RN > (#{cri.pageNum}-1) * #{cri.amount}
	]]>
</select>

<select id="getCountByBno" resultType="int">
    select count(*) from tbl_reply where bno = #{bno}
</select>
~~~

---



> ##### ReplyMapper 인터페이스

~~~java
// Criteria cri : 페이징파라미터, Long bno : 게시판 글번호(본문글)
// Mapper interface의 메ㅓ드 파라미터가 2개 이상일 경우 @Param 어노테이션 사용해야함
List<ReplyVO> getListWithPaging(@Param("cri") Criteria cri,@Param("bno") Long bno);

// 본문글을 참조하는 댓글 데이터 개수
int getCountByBno(Long bno);
~~~

이후 2개의 메서드를 하나씩 서비스로 보내도 되지만 같은 속성을 묶어서 진행한다

> ##### ReplyPageDTO domain 생성

~~~java
package com.demo.domain;

import java.util.List;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor // 모든 필드를 파라미터로 하는 생성자메서드
public class ReplyPageDTO {

	private int replyCnt;
	private List<ReplyVO> list;
	
	// @AllArgsConstructor 으로 인해 아래것이 만들어짐
//	public ReplyPageDTO(int replyCnt, List<ReplyVO> list) {
//	
//		this.replyCnt = replyCnt;
//		this.list = list;
//	}
}
~~~

이후 Service에 하나로 메서드를 가져온다

~~~java
ReplyPageDTO getListPage(Criteria cri, Long bno);
~~~

이후 ReplyServiceImpl에 하나로 등록

~~~java
@Override
public ReplyPageDTO getListPage(Criteria cri, Long bno) {

    return new ReplyPageDTO(mapper.getCountByBno(bno), mapper.getListWithPaging(cri, bno));
}
~~~

다시 컨트롤러에서 받아와서 jsp로 전달해준다

~~~java
// 1) 댓글목록데이터, 2) 페이징정보를 JSON포맷으로 클라이언트에게 리턴해주는 작업
// 주소 : /pages/{bno}/{page}. 주소의 일부분을 파라미터값으로 사용하고자 할 경우
// 예> /pages/1/1
// 테스트 주소 : http://localhost:9090/replies/pages/2163/1.json
@GetMapping(value = "/pages/{bno}/{page}", produces = {MediaType.APPLICATION_XML_VALUE, MediaType.APPLICATION_JSON_UTF8_VALUE})
public ResponseEntity<Map<String, Object>> getList(@PathVariable("page") int page,@PathVariable("bno") Long bno){
    ResponseEntity<Map<String, Object>> entity = null;
    Map<String, Object> map = new HashMap<String, Object>();

    // 1) 댓글목록 작업. 클릭된번호 page, 보여줄개수(amount)
    Criteria cri = new Criteria(page, 5);
    ReplyPageDTO replyObj = service.getListPage(cri, bno);

    map.put("list", replyObj.getList());

    // 2) 페이징정보 작업
    PageDTO pageDTO = new PageDTO(cri, replyObj.getReplyCnt());
    map.put("pageMaker", pageDTO);

    entity = new ResponseEntity<Map<String,Object>>(map, HttpStatus.OK);

    return entity;
}
~~~

더미데이터 넣고 확인하기 bno는 자기가 넣을 댓글 글번호

~~~sql
-- 댓글 더미데이터 삽입
INSERT INTO TBL_REPLY(rno, BNO, REPLY, REPLYER)
SELECT SEQ_REPLY.NEXTVAL, BNO, REPLY, REPLYER FROM TBL_REPLY WHERE BNO = 2163;

-- 더미데이터 확인
SELECT RNO, BNO, REPLY, REPLYER FROM TBL_REPLY WHERE BNO = 2163;
~~~

이후 postman에서 확인해보기

오류 검토 - dependency 버전확인

get.jsp 동작 작업

get.jsp 받아오는 폼 및 자바스크립트 작업