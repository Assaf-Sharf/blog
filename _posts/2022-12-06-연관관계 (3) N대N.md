# 1. N대N 관계

- 실무 현업에서 잘 쓰이지는 않음
- author <-> book 관계 설명 가능 (한 저자가 여러 책 or 여러 공동 저자가 한 책)
- manyToMany 에서는 둘다 Many 이기 때문에 fk 를 가지기 힘듦
- 따라서 중간테이블을 생성하고 author_id 와 book_id 를 맵핑하게 됨

# 2. Author 와 Book 

### Author entity

- AuthorRepository 도 함께 생성

- ```java
  package com.fastcampus.jpa.bookmanger.domain;
  
  import ...;
  
  @Entity
  @NoArgsConstructor
  @Data
  @ToString(callSuper = true)
  @EqualsAndHashCode(callSuper = true)
  public class Author extends BaseEntity {
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long id;
  
      private String name;
  
      private String country;
  
      //순환참조가 일어나기 때문에 Book, Author 양쪽에 Tostring.Exclude 를 붙여야 함
      //안붙이면 StackOverflowError 가 발생
      @ManyToMany
      @ToString.Exclude
      private List<Book> books = new ArrayList<>();
  
      //안만들어도 되나, 깔끔하게 만들기 위해 생성
      //params 로 Book... book 을 받으면 book 배열로 받음
      public void addBook(Book... book){
          //addAll 은 배열을 add
          Collections.addAll(this.books, book);
      }
  }
  ```

### Book entity

- Author entity 와 동일

- ```java
  ...
   @ManyToMany
   @ToString.Exclude
   private List<Author> authors = new ArrayList<>();
  
  public void addAuthor(Author... author){
  Collections.addAll(this.authors, author);
  }
  ```

### AuthorRepositoryTest

- ```java
  @Test
  @Transactional
  void manyToManyTest(){
      Book book1 = givenBook("book1");
      Book book2 = givenBook("book2");
      Book book3 = givenBook("devBook1");
      Book book4 = givenBook("devBook2");
  
      Author author1 = givenAuthor("martin");
      Author author2 = givenAuthor("steve");
  
      //연관관계 넣어주기
      //manyToMany 이기 때문에 무조건 리스트 형식
      //addAuthor, addBook 메소드 활용
      /*book1.setAuthors(Lists.newArrayList(author1));
          book2.setAuthors(Lists.newArrayList(author2));
          book3.setAuthors(Lists.newArrayList(author1, author2));
          book4.setAuthors(Lists.newArrayList(author1, author2));
  
          author1.setBooks(Lists.newArrayList(book1, book3, book4));
          author2.setBooks(Lists.newArrayList(book2, book3, book4));*/
      book1.addAuthor(author1);
      book2.addAuthor(author2);
      book3.addAuthor(author1, author2);
      book4.addAuthor(author1, author2);
  
      author1.addBook(book1, book3, book4);
      author2.addBook(book2, book3, book4);
      bookRepository.saveAll(Lists.newArrayList(book1, book2, book3, book4));
      authorRepository.saveAll(Lists.newArrayList(author1, author2));
  
      //book 을 통해서 author 확인
      System.out.println("authors through book : " + bookRepository.findAll().get(2).getAuthors());
      //author 를 통해서 book 확인
      System.out.println("books through author : " + authorRepository.findAll().get(0).getBooks());
  }
  
  //코드를 깔끔하기 위해서 따로 생성
  private Book givenBook(String name){
      Book book = new Book();
      book.setName(name);
  
      return bookRepository.save(book);
  }
  
  private Author givenAuthor(String name){
      Author author = new Author();
      author.setName(name);
  
      return authorRepository.save(author);
  }
  ```

# 3. 중간테이블 생성

- 주문같은 경우 User, Product, User<->Product 가 ManyToMany 로 연결되어야 함
- 그렇다면 user_products 라는 중간 테이블이 생성될거임
- 하지만 이런 중간테이블은 order 라는 또 다른 entity 생성으로 만들어줄 수 있음
- Order 테이블을 통해 일대다, 다대일 관계로 설정가능
- 임의로 'BookAndAuthor' entity 로 생성

### BookAndAuthor

- Book, Author 와 다대일로 연결

- ```java
  package com.fastcampus.jpa.bookmanger.domain;
  
  import ...;
  
  @Entity
  @NoArgsConstructor
  @Data
  @ToString(callSuper = true)
  @EqualsAndHashCode(callSuper = true)
  public class BookAndAuthor extends BaseEntity{
      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private Long Id;
  
      @ManyToOne
      private Book book;
  
      @ManyToOne
      private Author author;
  
  }
  ```

### Author

- ```java
  //author 와 BookAndAuthor 는 일대다로 연결 + @JoinColumn 사용
  @OneToMany
  @JoinColumn(name = "author_id")
  @ToString.Exclude
  private List<BookAndAuthor> bookAndAuthors = new ArrayList<>();
  
  public void addBookAndAuthor(BookAndAuthor... bookAndAuthor){
      Collections.addAll(this.bookAndAuthors, bookAndAuthor);
  }
  ```

### Book

- 상동

- ```java
  @OneToMany
  @JoinColumn(name = "book_id")
  @ToString.Exclude
  private List<BookAndAuthor> bookAndAuthors = new ArrayList<>();
  
  public void addBookAndAuthor(BookAndAuthor... bookAndAuthor){
  Collections.addAll(this.bookAndAuthors, bookAndAuthor);
  }
  ```

### Test

- ```java
  @Test
  @Transactional
  void manyToManyTest(){
      Book book1 = givenBook("book1");
      Book book2 = givenBook("book2");
      Book book3 = givenBook("devBook1");
      Book book4 = givenBook("devBook2");
  
      Author author1 = givenAuthor("martin");
      Author author2 = givenAuthor("steve");
  
      //bookAndAuthor 를 다대일 관계로 만들어주고,
      BookAndAuthor bookAndAuthor1 = givenBookAndAuthor(book1, author1);
      BookAndAuthor bookAndAuthor2 = givenBookAndAuthor(book2, author2);
      BookAndAuthor bookAndAuthor3 = givenBookAndAuthor(book3, author1);
      BookAndAuthor bookAndAuthor4 = givenBookAndAuthor(book3, author2);
      BookAndAuthor bookAndAuthor5 = givenBookAndAuthor(book4, author1);
      BookAndAuthor bookAndAuthor6 = givenBookAndAuthor(book4, author2);
  	//book1~4, author1~2 에 bookAndAuthor 를 넣어준다 (일대다 관계)
      book1.addBookAndAuthor(bookAndAuthor1);
      book2.addBookAndAuthor(bookAndAuthor2);
      book3.addBookAndAuthor(bookAndAuthor3, bookAndAuthor4);
      book4.addBookAndAuthor(bookAndAuthor5, bookAndAuthor6);
  
      author1.addBookAndAuthor(bookAndAuthor1, bookAndAuthor3, bookAndAuthor5);
      author2.addBookAndAuthor(bookAndAuthor2, bookAndAuthor4, bookAndAuthor6);
  
      //save 필수
      bookRepository.saveAll(Lists.newArrayList(book1, book2, book3, book4));
      authorRepository.saveAll(Lists.newArrayList(author1, author2));
  
      //리스트이므로 forEach 로 출력
      bookRepository.findAll().get(2).getBookAndAuthors().forEach(o -> System.out.println(o.getAuthor()));
      authorRepository.findAll().get(0).getBookAndAuthors().forEach(o -> System.out.println(o.getBook()));
  
  }
  //bookAndAuthor 에 author 와 book 을 넣어줌
  private BookAndAuthor givenBookAndAuthor(Book book, Author author){
      BookAndAuthor bookAndAuthor = new BookAndAuthor();
      bookAndAuthor.setAuthor(author);
      bookAndAuthor.setBook(book);
  
      return bookAndAuthorRepository.save(bookAndAuthor);
  }
  ```

  