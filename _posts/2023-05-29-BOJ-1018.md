---
layout: single
title: BOJ-1018-python 체스판 다시 칠하기
tags: BOJ
---

## 문제  
1018  
  
M x N 보드가 주어질때 8x8로 잘라서 체스판으로 만들려고 한다.  
칠해야 하는 정사각형의 최소 개수를 구하는 프로그램 작성.  

## solution  
![IMG_0596](https://github.com/noir1458/noir1458/assets/50611218/361665ec-6a37-4d71-b77e-8efc23e8ce0e)

문제 예시로 여러가지 경우를 체크해야한다는것은 알았는데, 모퉁이 4개를 기준으로 다 체크해야 한다는것은 놓쳤다.  
어느 모퉁이를 기준으로 잡느냐에 따라서 색칠해야되는 값이 달라지고, 이걸 체크하지 않는다면 최소값이 나오지 않을수도 있다.

## CODE  

```python
import sys
# 입력
lines = sys.stdin.readlines()
tmp_list = []
for idx in range(1,len(lines)):
    lines[idx] = lines[idx].replace('\n','').replace('\x1a','')
    tmp_list += [lines[idx]]

# 체크할 8*8 바둑판의 시작점을 잡는다
start_point = []
for start_idx in range(len(tmp_list)-7):
    for start_idx2 in range(len(tmp_list[start_idx])-7):
        start_point += [(start_idx,start_idx2)]

# 한 줄 단위로 시작점부터 비교한다
cmp1 = 'WBWBWBWB'
cmp2 = 'BWBWBWBW'
cnt_list = []
for a,b in start_point:
    cnt = 0
    for add_a in range(8):
        # 처음 나오는 문자 기준으로 바둑판의 형태 잡고 비교
        if tmp_list[a][b] == 'W':
            if add_a % 2 == 0:
                cmp = cmp1
            else:
                cmp = cmp2
        else :
            if add_a % 2 == 0:
                cmp = cmp2
            else:
                cmp = cmp1
        for add_b in range(8):
            if tmp_list[a+add_a][b+add_b] != cmp[add_b]:
                cnt += 1
    cnt_list += [cnt]

    cnt = 0
    # 맨 끝의 문자를 기준으로 하면 처음을 기준으로 할때와 결과가 달라질수 있다.
    for add_a in range(8):
        if tmp_list[a+7][b+7] == 'W':
            if add_a % 2 == 0:
                cmp = cmp1
            else:
                cmp = cmp2
        else :
            if add_a % 2 == 0:
                cmp = cmp2
            else:
                cmp = cmp1
        for add_b in range(8):
            if tmp_list[a+add_a][b+add_b] != cmp[add_b]:
                cnt += 1
    cnt_list += [cnt]

    cnt = 0
    # 첫줄 맨 끝의 문자
    for add_a in range(8):
        if tmp_list[a][b+7] == 'W':
            if add_a % 2 == 0:
                cmp = cmp2
            else:
                cmp = cmp1
        else :
            if add_a % 2 == 0:
                cmp = cmp1
            else:
                cmp = cmp2
        for add_b in range(8):
            if tmp_list[a+add_a][b+add_b] != cmp[add_b]:
                cnt += 1
    cnt_list += [cnt]

    cnt = 0
    # 마지막줄 처음 문자
    for add_a in range(8):
        if tmp_list[a+7][b] == 'W':
            if add_a % 2 == 0:
                cmp = cmp2
            else:
                cmp = cmp1
        else :
            if add_a % 2 == 0:
                cmp = cmp1
            else:
                cmp = cmp2
        for add_b in range(8):
            if tmp_list[a+add_a][b+add_b] != cmp[add_b]:
                cnt += 1
    cnt_list += [cnt]
print(min(cnt_list))
```
input받을때와 모퉁이 4개를 체크하는 경우에서 코드를 줄일수 있을것으로 보이는데. 문제푸는데 너무 오래걸렸다...  


```python
f=open(0).read().split('\n')
r,c=f[0].split(' ')
f=f[1:]
w="WBWBWBWB"
b="BWBWBWBW"
sett=(w+b)*4
temp=""
result=0
minx=64
def comp(a,b):
	r=0
	for x,y in zip(a,b):
		if x!=y:
			r+=1
	return r
for i in range(int(r)-7):
	for j in range(int(c)-7):
		for k in range(8):
			temp+=f[i+k][j:j+8]
		result=comp(temp,sett)
		temp=''
		minx=min([result,64-result,minx])
print(minx)
```
알아들을만한 정답 코드중 짧은것  
스스로 연습이 좀 필요하다고 느낀다. 백준 문제중 순서대로 풀기 문제는 어느정도 다 풀어서 자료구조 문제를 시도해보는게 좋을수도 있겠다. 몇 문제 더 풀면 실버 2로 올라갈듯 싶다.