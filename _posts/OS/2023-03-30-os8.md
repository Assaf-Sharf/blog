---
layout: single
title: "[OS] 운영체제(3장) 프로세스 - 2"
categories: os
tag: [cs, os]
toc: true
---

# 프로세스

## 프로세스 연산

### 프로세스 생성

- 프로세스는 create-process 시스템 호출을 사용하여 new 프로세스를 생성
- 생성된 프로세스들의 계속적인 프로세스 생성의 결과로 프로세스 트리(process tree)를 형성
- 프로세스들은 프로세스 식별자(process identifier, pid)로 구분

### 부모프로세스와 자식프로세스 간의 여러 가지 자원 공유 방법

- 자식 프로세스가 OS에서 자원을 직접 얻음
  - 부모와 자식 프로세스간에 자원을 공유하지 않음
- 자식 프로세스가 부모 프로세스 자원의 부분집합을 사용
  - 자식 프로세스는 부모 프로세스의 모든 자원 또는 일부 자원 공유
  - 부모 프로세스는 자식 프로세스들에게 자신의 자원을 분할 제공

#### Linux 시스템의 프로세스 트리

![image](https://user-images.githubusercontent.com/100071667/228885471-638f3335-20c5-4ee4-82a6-c72ccebe6011.png)

#### 실행(Execution)

- 부모와 자식이 병행(concurrent) 수행
- 부모가 모든 또는 일부 자식이 끝나기를 기다림(wait)

#### 주소 공간(Address space)

- 자식은 부모의 복사본(duplicate)
- 자식은 새로 적재되는 프로그램을 가짐

#### Examples

- UNIX: fork 와 exec system call 사용
  - fork() : new process 생성. 
부모 프로세스의 주소공간의 복제본으로 구성됨
  - exec() : 프로세스 메모리 공간을 새 프로그램으로 대치하여
새로운 프로그램을 실행
- Win32 API:
  - CreateProcess() : 프로그램을 적재하여 자식프로세스를
생성하여 실행. 인수가 복잡함(10개 이상)

### UNIX에서의 프로세스 생성

![image](https://user-images.githubusercontent.com/100071667/228887563-9656a649-1b80-4597-8355-ffbaa748769c.png)

### UNIX에서의 fork/exec/wait 동작

![image](https://user-images.githubusercontent.com/100071667/228887725-fe37ba72-d9c7-4d17-abcd-b6a669b6d411.png)

### 프로세스 종료 (정상적)

#### 프로세스의 정상 종료
- 프로세스가 마지막 문장의 실행이 끝나면 exit() 시스템 호출을 하여
운영체제에게 자신을 삭제를 요청함
- 자식 프로세스는 부모에게 상태 값(대개 정수)을 반환할 수 있다. 
  - 부모는 wait() 시스템 호출을 하여 이 값을 기다림
- 운영체제는 프로세스가 사용한 자원을 반납(deallocate)함

#### 좀비(Zombie) 프로세스

- 종료되었지만 부모가 wait()를 아직 호출하지 않아서 남아있는 프로세스
- terminated/zombie 상태로 짧은 시간 동안 이 상태에 머무름

### 프로세스의 종료 (비정상적)

#### 프로세스의 비정상 종료

다음 경우에 부모가 자식을 종료할 수 있음
- child가 자신에게 할당된 자원을 초과하여 사용할 때
- child에게 할당된 태스크(작업)가 더 이상 필요 없을 때
- 부모 종료 시, 운영체제가 자식이 계속하여 실행하는 것을 허용하지 않을 때 → 연쇄적 종료(cascading termination)

#### 부모 프로세스 종료 후에 자식의 계속적인 실행을 허용하는 경우

- 모든 프로세스는 종료 후 처리를 위하여 부모 프로세스가 있어야 함
- 부모가 먼저 종료된 자식 프로세스는 고아(orphan) 프로세스가 되며 init 프로세스(Linux는 systemd 프로세스)를 새로운 부모 프로세스로 지정함

## 프로세스간 통신(Interprocess Comminication)

### 병행(concurrent) 프로세스의 종류

- 독립(Independent) 프로세스: 
  - 다른 프로세스의 실행에 영향을 주거나 받지 않음
- 협력(Cooperating) 프로세스:
  - 다른 프로세스의 실행에 영향을 주거나 받음

### 프로세스 협력을 허용하는 이유

- 정보 공유 (예) 공유 파일
- 계산 가속화(Computation Speedup)
  - 작업을 서브 작업으로 나누어, 병렬 실행
- 모듈성(Modularity) – 기능 모듈화
- 편의성(Convenience)
  - 개별 사용자가 한 번에 여러 작업을 수행함

### 프로세스간 통신(IPC) 모델

두 가지 IPC 모델 : 메시지 전달, 공유 메모리

![image](https://user-images.githubusercontent.com/100071667/228889852-a84e8714-6ed1-4640-8a1a-3139502ac7ca.png)

### 공유 메모리 시스템 IPC

#### Shared Memory Systems – 공유 영역에 있는 버퍼 사용

시스템 호출을 사용하여 공유 메모리 영역 지정
공유 메모리가 지정되면 보통의 메모리와 같이 접근됨

#### 생산자-소비자 문제(Producer-Consumer)

- 협력 프로세서들의 간단하고 전형적인 예
- producer 프로세스는 정보를 생산하고, consumer 프로세스는 정보를 소비함

#### 생산자-소비자 문제의 공유 메모리 구현 방법 – 두 유형의 버퍼

- 무한(unbounded) 버퍼 : 버퍼 크기의 제한이 없음(이상적)
- 유한(bounded) 버퍼 : 고정된 버퍼 크기
버퍼가 full이면 producer는 기다려야 함

![image](https://user-images.githubusercontent.com/100071667/228890583-f316d964-3a19-45f4-8f18-02a3b029d5d7.png)

### 메시지 전달 시스템 IPC

같은 주소 공간을 공유하지 않고, 통신으로 동작을 동기화하는 기능을 제공함(네트워크로 연결된 분산환경에 특히 유용)

#### 메시지 전달 IPC 함수 – 최소 두 가지 제공

◼ send(message) 
◼ receive(message)

#### 메시지 크기와 IPC 구현

|메시지 크기|OS구현|응용프로그래밍|
|------|---|---|
|Fixed size|간단함|더 복잡함|
|Variable size|더 복잡함|간단함|

한 번에 전송/수신할 수 있는 메시지 길이는 제한됨. 길이가 길면 제한된 길이로
분할하여 여러 번 전송하거나, 여러 번 수신하여 합해야 함

- fixed size IPC : 프로그래머가 이 작업을 수행
- variable size IPC : IPC 함수에서 이 작업을 수행

#### IPC의 통신 연결(Communication Link)

통신 프로세스 P와 Q가 서로 통신을 하려면 그들 간에 통신 연결이 설정되어야 함

##### communication link의 구현

- 물리적 구현 : 공유 메모리, 하드웨어 버스, 네트워크
- 논리적 구현 : 운영체제의 관심 사항