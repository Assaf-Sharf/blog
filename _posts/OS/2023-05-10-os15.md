---
layout: single
title: "[OS] 운영체제(7장) CPU 스케줄링"
categories: os
tag: [cs, os]
toc: true
---

# <span style="color:blue">1. 기본 개념</span>

## multiprogramming의 목적

- CPU 이용률 최대화

## CPU-I/O Burst Cycle 

- 프로세스 실행은 CPU 실행과 I/O 대기의 사이클로 구성됨

## CPU burst 분포

- (see next page)

## <span style="color:purple">CPU-burst 시간의 분포도</span>

![image](https://github.com/mgskko/Algorithm/assets/100071667/6e13c889-7c74-422c-9972-a9ff9460ae85){: width="80%" height="70%" .align-center}

## <span style="color:purple">CPU Scheduler</span>

ready queue에 있는 프로세스들 중 하나를 선택하여 이 프로세스에게 CPU를 할당함

![image](https://github.com/mgskko/Algorithm/assets/100071667/07db760f-46e1-468d-a466-711f9220b7d3){: width="80%" height="70%" .align-center}

## <span style="color:purple">CPU Scheduling 시점</span>

### CPU scheduling 결정은 process가 다음 상황일 때 발생 가능함

1. running 상태에서 waiting 상태로 전환
(예. I/O wait, child termination wait)
2. running 상태에서 ready 상태로 전환. (e.g. time-out)
3. waiting 상태에서 ready 상태로 전환. (e.g. I/O completion, event occur)
4. Terminate.

### <span style="color:red">비선점(non-preemptive) 스케줄링 – cooperative 스케줄링</span>

- 1번, 4번 경우는 선택의 여지가 없으며, 이 경우에만 스케줄링
   - 반드시 스케줄링하여 새 프로세스를 선택해야 함
   - 프로세스는 종료하거나 block될 때까지 CPU를 계속 점유
- (예) windows 3.x, 예전 Mac OS

### <span style="color:red">선점(preemptive) 스케줄링</span>

- 모든 경우에 스케줄링이 가능(2, 3번 경우 포함)
- CPU 독점을 방지하거나(timer 사용), 프로세스 우선순위를 반영하고자 할 때 2, 3번의 경우(ready queue가 변화)에 스케줄링 할 수 있음
- (예) 대부분의 현대 OS

## <span style="color:purple">Preemptive 스케줄링의 문제점과 해결책</span>

- 공유 데이터의 일관성(consistence) 유지 문제
   - 선점 스케줄링 방식에서, process는 프로세스는 <u>데이터를 변경하는 도중에</u> 다
른 프로세스에게 선점되어 변경된 데이터를 저장하기 전에 CPU를 내어놓을 수
있다.
   - 다수의 프로세스가 데이터를 공유할 때에 <u>경쟁적으로 데이터를 변경하면</u> 데이터
일관성이 유지되지 않을 수가 있다. → 경쟁조건
   - 해결책 : 공유 데이터 접근에 대한 조정이 필요 → 동기화 방식 (5장)

### <span style="color:red">user mode에서의 preemption</span>

   - 선점형스케줄링 을 하는 운영체제에서, 한 프로세스가 데이터를 변경하는 동안 선점되어 다른 프로세스가 같은 데이터를 읽거나 수정한다면 데이터 일관성이 유지되지 않을 수 있음

   - 사용자 프로그램은 운영체제가 제공하는 **동기화 방식**을 사용하여 데이터 일관성 문제가 발생하지 않도록 작성해야 한다

### <span style="color:red">Kernel mode에서의 preemption</span>

**Kernel mode에서의 공유 데이터 접근 문제**

- 모든 커널 루틴은 커널 데이터를 공유함
- 커널은 system call을 통하여 요청된 프로세스의 작업을 처리할 수 있으며, 공유 데이터를 접근하는 커널 루틴이 실행되는 동안에, 인터럽트로 인해서 다른 커널 루틴에게 선점되면 공유 데이터 일관성 유지가 되지 않을 수 있다.
- 커널에서의 이러한 문제 발생은 시스템 전체에 영향을 주므로 위험함

**운영체제 커널에서의 preemption 처리 방법**

- 비선점형 커널 - 커널 내에서의 preemption을 허용하지 않음
(1) system call이 완료되거나 (2) I/O block 이 발생할 때까지 기다린 후에 context switching 을 수행

   - 실시간 컴퓨팅을 지원하는 데 부적합

- 선점형 커널 - 커널 내에서 preemption 을 허용

   - 커널 내에서 공유 데이터 접근에 대한 동기화 를 사용하여 커널을 작성해야 함

   - 실시간 컴퓨팅 지원에 적합

## <span style="color:purple">디스패처</span>

- CPU의 제어권을 CPU 스케줄러가 선택한 프로세스에게 주는 모듈

- 다음작업 수행

   - context 스위칭
   - CPU
   - 동작 모드를 user mode 로 전환

- 선택한 프로세스가 다시 시작하도록 , user program 의 적절한 위치로 이동(jump)

### <span style="color:red">Dispatch 지연(latency)</span>


- 한프로세스를 정지하고 , 다른 프로세스의 수행을 시작할 때까지 소요되는 시간

- dispatch latency은 가능한 한 작아야 함( 빠르게 동작)

# <span style="color:blue">2. Scheduling기준(Criteria)</span>

CPU 이용률(s