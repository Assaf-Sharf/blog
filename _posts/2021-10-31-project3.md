# KREAM Clone Project Code Review 1

**기간 : 2021-10-10 ~ 2021-10-29**

![](https://user-images.githubusercontent.com/61782539/139529652-5d04aa32-b615-478e-87fe-b17693fc3b9c.png)

필수로 구현하기로 한 기능들을 중심으로 모델링하였다. kream은 이용자들이 한정판 상품들을 서로 사고 팔고 할 수 있도록 매개해주는 사이트이다. 그 과정에서 이용자들이 원하는 가격에 물건을 사고 팔 수 있도록 구매가나 판매가를 제시하는 경매 시스템이 있다. 그리고 그 경매 시스템에 따라서 물건을 즉시 구매하고 즉시 판매할 수 있는 실제적인 가격이 결정된다.

상품의 사이즈별로 (실제 kream에는 여러 종류의 상품이 있기 때문에 옵션도 여러가지지만 프로젝트에서는 신발만 다루기로 기획했다.) 입찰이 생성된다.

kream에서 구매, 판매 계약(주문)은 거래하려는 상품에 입찰이 하나라도 걸려있을 때만 가능하다. 상품을 구매하려할 때는 해당 상품의 판매 입찰들중에 가장 낮은 가격으로 제시된 입찰가가 즉시 구매가로 결정되고 그 가격이 마음에 든다면 바로 거래할 수 있다. 반대로 상품을 판매할 때는 해당 상품의 구매 입찰들중에 가장 높은 가격으로 제시된 입찰가가 즉시 판매가로 결정된다. 따라서 주문은 즉시거래하는 유저와 해당 즉시거래가를 형성한 하나의 입찰이 만나서 이루어진다. 만약 주문 요청된 입찰의 포지션이 구매라면 판매자는 즉시판매가로 거래하는 유저가 될 것이고 구매자는 해당 입찰을 제시한 유저가 될 것이다. 

이번 프로젝트에서는 경매 프로세스를 구현해보는 것에 중점을 두었기 때문에 결제는 유저의 포인트를 서로 주고 받는 것으로 간략하게 기획했다.

## End Point

나는 이번 프로젝트에서 입찰, 주문 관련 API를 만드는 역할을 담당했다.

- **POST /orders/bidding/{int:productsize_id}/{int:position_id} (입찰 생성)**
- **GET /orders/bidding/{int:productsize_id}/{int:position_id} (입찰 조회 - 주문 페이지에서 즉시 거래가 조회)**
- **POST /orders/{int:bidding_id} (주문 생성)**
- **GET /orders/size-price/{int:product_id}/{int:position_id} (상품의 사이즈별 즉시 거래가 조회)**
- **GET /orders/price/{int:product_id} (상품의 시세 조회)**
- **GET /orders (주문, 입찰중인 내역 조회)**



```python
class BiddingStatusId(Enum):
    ON_BIDDING = 1
    CONTRACTED = 2

class BiddingPositionId(Enum):
    BUY  = 1
    SELL = 2

class OrderStatusId(Enum):
    INSPECTION = 1
    IN_TRANSIT = 2
    DELIVERED  = 3

class InsufficientPointError(Exception):
    pass

class InvalidBiddingStatusError(Exception):
    pass

class CheckId():
    def check_product_id(product_id):
        if not Product.objects.filter(id = product_id).exists():
            raise Product.DoesNotExist

    def check_product_size_id(productsize_id):
        if not ProductSize.objects.filter(id = productsize_id).exists():
            raise ProductSize.DoesNotExist
        
    def check_bidding_id(bidding_id):
        if not Bidding.objects.filter(id = bidding_id).exists():
            raise Bidding.DoesNotExist
    
    def check_bidding_position_id(position_id):
        if not BiddingPosition.objects.filter(id = position_id).exists():
            raise BiddingPosition.DoesNotExist
    
    def check_bidding_status_id(bidding_status_id):
        if bidding_status_id == BiddingStatusId.CONTRACTED.value:
            raise InvalidBiddingStatusError

def user_point_check(user, position, bidding):
    if (position == BiddingPositionId.SELL.name and bidding.price > user.point) or (position == 				 BiddingPositionId.BUY.name and bidding.price > bidding.user.point):
        raise InsufficientPointError
```

position 테이블과 status 테이블의 id값을 사용하는데 있어서, db상에 어떤 데이터가 어떤 id를 갖고 있는지 헷갈릴 수 있는 것을 방지하고, 다른 사람이 코드를 봤을 때도 논리적으로 이해할 수 있도록 Enum class들을 따로 만들어서 api를 작성할 때 사용했다.

요청에서 들어온 id의 데이터가 존재하지 않거나 잘못된 id값일 경우의 예외를 발생시키는 class를 따로 만들어 api 안에서 코드의 가독성을 좀 더 높일 수 있었다. 

user_point_check 함수의 경우 주문 생성 api에서 사용되는데, 로그인 유저가 제품을 판매하려는 경우에는 구매 입찰을 걸었던 유저의 포인트가 가격보다 적으면 예외를 발생시키고, 구매하려는 경우에는 로그인 유저의 포인트가 가격보다 적으면 예외를 발생시켰다.  

### POST /orders/bidding/{int:productsize_id}/{int:position_id} (입찰 생성)

```python
class BiddingView(View):
    @login_decorator
    def post(self, request, productsize_id, position_id):
        try:
            CheckId.check_product_size_id(productsize_id)
            CheckId.check_bidding_position_id(position_id)
        
            data  = json.loads(request.body)
            user  = request.user
            price = data['price']
            
            Bidding.objects.create(
                user                 = user,
                bidding_status_id    = BiddingStatusId.ON_BIDDING.value,
                bidding_position_id  = position_id,
                product_size_id      = productsize_id, 
                price                = price
            )

            return JsonResponse({'message' : 'SUCCESS'}, status = 201)

        except KeyError:
            return JsonResponse({'message' : 'KEY_ERROR'}, status = 400)
        
        except JSONDecodeError:
            return JsonResponse({'message' : 'JSON_DECODE_ERROR'}, status = 400)

        except ProductSize.DoesNotExist:
            return JsonResponse({'message' : 'PRODUCT_SIZE_DOES_NOT_EXIST'}, status = 404)

        except BiddingPosition.DoesNotExist:
            return JsonResponse({'message' : 'INVALID_BIDDING_POSITION'}, status = 400)

```

입찰 생성은 요청에서 path 변수로 productize_id와 position_id를 받고 요청의 body에서 유저가 입력한 price 값을 받아서 생성한다. 새로 생성되는 입찰의 상태는 ON_BIDDING의 id값을 넣어준다.



### **GET /orders/bidding/{int:productsize_id}/{int:position_id} (입찰 조회 - 주문 페이지에서 즉시 거래가 조회)**

```python
		@login_decorator
    def get(self, request, productsize_id, position_id):
        try:
            CheckId.check_product_size_id(productsize_id)
            CheckId.check_bidding_position_id(position_id)
            
            user              = request.user
            sell_price_filter = (Q(bidding__bidding_position_id = BiddingPositionId.BUY.value) & 
            Q(bidding__bidding_status_id = BiddingStatusId.ON_BIDDING.value))
            buy_price_filter  = (Q(bidding__bidding_position_id = BiddingPositionId.SELL.value) & 
            Q(bidding__bidding_status_id = BiddingStatusId.ON_BIDDING.value))
            biddings          = Bidding.objects.filter(bidding_position_id = position_id, bidding_status_id = 
            BiddingStatusId.ON_BIDDING.value).order_by('price' if position_id == BiddingPositionId.SELL.value 
            else '-price')
            product_size      = ProductSize.objects.annotate(sell_price = Max('bidding__price', filter = 
            sell_price_filter), buy_price = Min('bidding__price', filter = buy_price_filter)).\
                                select_related('size', 'product').prefetch_related(Prefetch('bidding_set', 
                                queryset = biddings)).get(id = productsize_id)

            data = {
                'product_image_url'    : product_size.product.productimage_set.first().image_url if 	
              	product.productimage_set.first() else None
                'product_name'         : product_size.product.name,
                'product_brand'        : product_size.product.brand.name,
                'product_model_number' : product_size.product.model_number,
                'size'                 : product_size.size.size,
                'sell_price'           : product_size.sell_price,
                'buy_price'            : product_size.buy_price,
                'user_point'           : user.point,
                'bidding_id'           : product_size.bidding_set.first().id if product_size.bidding_set.first() 
                else None,
                'bidding_price'        : product_size.bidding_set.first().price if 
                product_size.bidding_set.first() else None
            }

            return JsonResponse({'data' : data}, status = 200)

        except ProductSize.DoesNotExist:    
            return JsonResponse({'message' : 'PRODUCT_SIZE_DOES_NOT_EXIST'}, status = 404)

        except ProductSize.MultipleObjectsReturned:
            return JsonResponse({'message' : 'MULTIPLE_RETURN_ERROR'}, status = 400)
        
        except BiddingPosition.DoesNotExist:
            return JsonResponse({'message' : 'INVALID_BIDDING_POSITION'}, status = 400)
```

주문 페이지에서 구매/판매와 상관없이 즉시구매가와 즉시판매가의 정보를 모두 보여준다. path 변수로 productsize_id를 받아와서 해당 상품의 정보와 해당 사이즈에 생성돼있는 입찰들에 접근한다. 구매가와 판매가 별로 annotate()에서 사용할 filter 조건들을 미리 만들어주었다. 구매가를 구할 때 해당되는 조건은 아직 계왁완료되지 않은 입찰중에 position이 SELL인 경우이고 판매가는 position이 BUY인 경우이다. 구매가는 filter 조건들의 입찰들중에서 가장 낮은 가격의 입찰가를 Min()을 통해 가져왔고 판매가는 가장 높은 가격의 입찰가를 Max()를 통해 가져왔다. 

Prefetch()의 쿼리셋으로 사용할 biddings 쿼리셋을 조건에 맞게 미리 지정해주었다. 입찰상태가 아직 입찰중이고, 요청에서 얻은 position에 해당하는 입찰들중에 position에 따라 낮은 가격순, 높은 가격순으로 정렬되게 했다. 해당 상품 사이즈에 position에 맞는 입찰이 존재하지 않을 수도 있기 때문에 bidding_set.first()를 사용할 때 first()가 None이면 None이 반환되게 했다. None에 대한 처리를 해주지 않으면 first()가 None일때 bidding_set.first().id 나 .price 처럼 필드에 접근하면 AttributeError가 발생한다. 

만약 거래하려는 상품의 position에 맞는 입찰이 존재하지 않으면 즉시거래할 수 없으므로 즉시구매/판매 자체가 불가능하고 입찰 생성만 가능하다. 

이번에 api를 만들고 프론트 분들과 소통하는 과정에서 서로 자주 헷갈렸던 지점이 유저가 구매/판매하기 위해 거기에 맞는 입찰을 조회할 때는 position_id를 반대의 경우로 요청해야한다는 점이었다. 만약 구매자가 즉시구매할 수 있는 입찰이 있는지 조회할 때는 판매입찰들중에서 조회해야하기 때문에 요청해야할 입찰의 position은 SELL이 된다. 하지만 구매자가 즉시구매할 수 있는 입찰이 존재하지 않거나 현재 형성된 즉시구매가가 마음에 들지 않아서 다른 가격으로 입찰을 한다고 하면 (입찰 생성할 때의) position은 그대로 BUY가 된다. 

![](https://user-images.githubusercontent.com/61782539/139566913-5a12ad97-9108-4e3c-adaa-e0e6b9ac47df.png)