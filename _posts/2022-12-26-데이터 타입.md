# 2022-12-26-데이터 타입

# 데이터 타입

PL/SQL에서는 스칼라(scalara), 복합(composite),참조(reference),LOB 타입 등과 같이 여러 종류의 데이터 타입을 지원합니다. 일반적으로 사용되는 데이터 타입은 스칼라 타입(숫자, 문자, 날짜, 불린(Boolean), Raw, Rowid 등) 이며, 레코드(records) 및 컬렉션(colections)와 같은 복합 타입 REF 커서 타입의 참조 타입, CLOB 및 BLOB같은 LOB 타입도 지원합니다

### 스칼라 타입

변수에 사용될 데이터 타입은 SQL에서 사용되는 타입과 유사 하지만 실제 크기는 다를 수 있으며,

PL/SQL에서만 사용할 수 있는 BOOLEAN타입, PLS_INTEGER같은 타입도 지원합니다.

| 타입 | 최대크기 | 설명 |
| --- | --- | --- |
| NUMBER[(precision, scale)] | 21바이트 | precision은 정밀도 이고 scale는 스케일 입니다. 정밀도는 값에 나타난 자리수고 스케일은 소수점 오른쪽에 위치한숫자의 개수입니다. 정밀도는 38, 스케일범위는 -84 ~ 127입니다. 사이즈를 최소한으로 지정해야 저장 공간이 절약됩니다. |
| BINARY_INTEGER | -2147483648 ~ 2147483647 | integer 타입의 서브 타입으로 오라클 버전 9iR2까지는 index-by table의 인덱싱 용으로만 사용 가능하였습니다 10g 부터는 독립된 데이터 타입으로 지원합니다. 하지만 이 타입보다는 밑의 PLS_INTEGER타입의 사용을 권장합니다 |
| PLS_INTEGER | -2147483648 ~ 2147483647 | 기계적 연산을 수행함에 따라 BINARY_INTEGER와 Number타입 보다 빠른 연산이 가능하며 저장공간도 적게 사용됩니다 단, 허용 가능한 크기를 넘어가면 오버플로우 에러가 발생합니다 |
| SIMPLE_INTEGER | -2147483648 ~ 2147483647 | 오라클 11g부터 제공되며, PLS_INTEGER 타입의 서브타입으로 컴파일 모드가 PLSQL_CODE_TYPE=’NATIVE’ 일때보다 빠른 성능을 제공합니다. 이 타입도 허용 가능한 크기를 넘어가면 오버플로우 에러가 발생하며 NULL 값을 허용하지 않습니다. |
| RAW(max_length) | 32767바이트 | 고정된 길이의 바이너리 데이터를 저장합니다. RAW 데이터는 두 개의 다른 데이터베이스에 전송될 때 다른 문자 집합으로 변환되지 않습니다. 데이터베이스에서는 최대 길이가 2,000바이트 이나 PL/SQL은 32,76입니다. |
| LONGRAW | 32760바이트 | 문자 집합에서 변환이 이뤄지지 않는 것을 제외하면 LONG 데이터 타입과 동일합니다. 데이터 베이스에서는 최대 길이가 2기가바이트이나 PL/SQL에서는 32,760 |
| DATE | 7바이트 | 세기, 년, 월, 일, 시, 분, 초까지 포함하는 날짜와 시간을 지정합니다. |
| TIMESTAMP | 11바이트 | 가능한 경우 Date형을 사용하고, 초 이하의 정밀한 시간을 포함해야 하는 경우에 사용합니다 |
| ROWID/UROWID |  | ROW ID는 테이블 행의 고유 주소를 나타내고 UROWID는 인덱스 구성 테이블 행의 논리적인 위치를 나타냅니다. CHARTOROWID와 ROWIDTOCHAR함수를 통해 문자열과 서로 변환할 수 있습니다. |
| BOOLEAN |  | TRUE, FALSE, NULL 값만 저장합니다. |

이외 오라클에서 이미 사용중인 데이터타입들은 생략함

SQL에서 지원하는 길이와 데이터타입이 서로 다를 수 있기 때문에 주의해야합니다.

EX) CHAR, VARCHAR2 사이즈 32,767 그 이상의 문자를 저장 시 CLOB타입으로 선언

SIMPLE_INTEGER는 NOT NULL 제약 조건이 걸려있어 NULL 이 사용되지 않거나 오버플로우 체크가 필요 없는 곳에만 사용하여야함.

예시 코드

```sql
DECLARE
	p1 PLS_INTEGER := 2147483647;
	p2 PLS_INTEGER := 1;
	n NUBMER;
BEGIN
	n := p1 + p2;
END;
/

--numeric overflow 에러

/*위와같은 에러를 피하기 위해서는 PLS_INTEGER타입이 아닌 다른 정수값을 지원하는 타입을 
사용해야 합니다.*/

DECLARE
	p1 PLS_INTEGER := 2147483647;
	p2 INTEGER := 1;
	n NUBMER;
BEGIN
	n := p1 + p2;
	DBMS_OUTPUT.PUT_LINE(n); 
END;
/

--SIMPLE_INTEGER의 경우 NULL값을 허용하지 않는다.
DECLARE
	s SIMPLE_INTEGER := 1;
	p PLS_INTEGER := NULL;
BEGIN
	s:=p
END;
/

--numeric or value error
```

### #PLSQ_CODE_TYPE

**1.  PL/SQL 컴파일 방식 변경**

- 기본적으로 PL/SQL을 컴파일 하게 되면 INTERPRETED 방식으로 한다.

즉 PL/SQL 수행시 구문 하나씩 실시간으로 번역하면서 수행되는 방식.

또 다른 방식은 NATIVE 방식이다.

자바스크립트는 INTERPRETED, 일반 윈도우 프로그램은 NATIVE 인 것처럼 비교하면 쉽게

이해가 될 것이다.

보편적으로 개발시에는 INTERPRETED 방식으로, 배포시에는 NATIVE 로 하면 성능 향상을

이룰 수 있다.

- NATIVE VS INTERPRETED 모드 설정하기

. ALTER SESSION SET PLSQL_CODE_TYPE = NATIVE;  // INTERPRETED

. PL/SQL 컴파일

OR 또는 먼저  PL/SQL를 컴파일하고 모드를 변경할 수도 있다.

-> ALTER PACKAGE 패키지명 COMPILE PLSQL_CODE_TYPE=NATIVE;

// PACKAGE OR FUNCTION OR PROCEDURE

- PL/SQL별 컴파일 모드 조회하기

: SELECT NAME, PLSQL_CODE_TYPE

FROM USER_PLSQL_OBJECT_SETTINGS;

### 조합 타입

PL/SQL에서 지원되는 조합 타입은 레코드(Record)와 컬렉션(Colection) 타입입니다. 컬렉션은 20장에서 자세히 설명

레코드(RECORD) 타입은 C의 구조체와 비슷하며, 논리적으로 연관되어 있는 컬럼을 하나로 묶어 사용하는 타입입니다.

아래는 empno 칼럼과 ename 칼럼을 조합하여 emp_record라는 레코드 타입을 선언한 예입니다.

레코드 타입 변수에 empno 칼럼과 ename 칼럼의 값을 한번에 입력 할 수 있으며, 각 컬럼 값이 필요하면 ‘레코드변수.칼럼명’으로 기술하여 사용 할 수 있습니다.

```sql
DECLARE
	--새로운 레코드 타입 생성
	TYPE emp_record IS RECORD (empno number, ename varchar(20));
	emp_rec emp_record

BEGIN
	SELECT empno, ename
	INTO emp_rec
	FROM emp
	WHERE rownum = 1;

--레코드 내 각 컬럼의 값을 개별적으로 출력

	DBMS_OUTPUT.PUT_LINE('empno :' || emp_rec.empno);
	DBMS_OUTPUT.PUT_LINE('ename :' || emp_rec.empno);

END;
/
```

 

### % 타입

테이블의 칼럼을 저장하기 위해 PL/SQL의 변수를 선언할 때 데이터 타입이 정확히 맞지 않으면 실행시 에러가 발생합니다. 많은 경우 테이블에 저장되어 있는 데이터를 가공, 처리 해야하는데 많은 변수에 대해 일일이 데이터 타입을 확인해가며 설정하는 것은 쉬운 일이 아닙니다.

이에 대처하기 위해 오라클은 %TYPE 과 %ROWTYPE과 같은 특수한 데이터 타입을 제공합니다 %TYPE은 테이블 칼럼 또는 사용자 정의 칼럼과 동일한 타입을 설정할 때 사용되며 %ROWTYPE은 테이블의 행 단위 칼럼 또는 커서에서 추출된 행 단위 칼럼과 동일한 레코드 타입으로 설정하는데 사용됩니다.

따라서, SELECT 절에는 반환되는 결과를 저장하기 위해 VARCHAR2와 NUMBER 같은 데이터 타입 형식을 사용하는 대신 %TYPE이나 %ROWTYPE 타입을 사용하면 손쉽게 변수 타입을 지정 할 수 있습니다.

또한 테이블의 칼럼 타입 또는 사이즈를 변경해야 하는 경우, 데이터 타입을 개별적으로 설정하였으면 관련된 모든 프로그램에서 해당 변수의 설정을 바꿔줘야 하지만 %TYPE %ROWTYPE 타입이 사용 되었으면 그럴 필요가 없기 때문에 유연하게 대처할 수 있습니다.

| %TYPE 예 | 설명 |
| --- | --- |
| salary NUMBER(10,2); | number(10,2) 형식을 가지는 salary라는 사용자 데이터 타입을 생성합니다. |
| I_salary salary%TYPE := 10.01 | 위에는 생성한 salary 타입으로 변수를 선언합니다. |
| I_dname dept.dname%TYPE; | dept 테이블의 dname 칼럼과 동일한 데이터를 설정합니다. 테이블 칼럼과 동일한 데이터 타입으로 선언하고 싶을 때 사용합니다. |
| %ROWTYPE 예 | 설명 |
| dept_recl dept%ROWTYPE; | dept 테이블의 행과 동일한 타입으로 변수를 선언합니다. |
| CURSOR c1 IS SELECT deptno, dname, loc FROM dept; dept_rec2 c1%rowtype; | 커서 c1에서 리턴되는 행과 동일한 타입으로 변수를 선언합니다. |

```sql
DECLARE

  --DEPT 테이블의 DNAME과 같은 타입의 변수 선언

  l_dname dept.dname%TYPE;

  

  --DEPT 테이블의 행과 같은 레코드 변수 선언

  dept_rec1 dept%ROWTYPE;

  

  --DEPT테이블에서 일부 칼럼들만 추출하는 커서 선언

  CURSOR c1 IS

    SELECT deptno, dname, loc

     FROM dept;

     

     --C1 커서의 칼럼과 같은 레코드 변수 선언

     dept_rec2 c1%ROWTYPE;

BEGIN

  --DEPT테이블의 한 행의 칼럼을 %ROWTYPE의 레코드 변수에 한번에 저장

  SELECT *

    INTO dept_rec1

    FROM dept

   WHERE rownum=1;

   

   --레코드 내 각 칼럼의 값을 개별적으로 출력함

   DBMS_OUTPUT.PUT_LINE('deptno:' || dept_rec1.deptno || ' dname:' || dept_rec1.dname);

   

   --DEPT테이블의 dname 칼럼의 값을 %TYPE의 변수에 저장

   l_dname := dept_rec1.dname;

   

   --변수에 저장된 값을 출력함

   DBMS_OUTPUT.PUT_LINE('dname:' || l_dname);

   

   --커서에서 추출된 모든 칼럼을 %ROWTYPE의 레코드 변수에 한번에 저장

   OPEN c1;

   FETCH c1 INTO dept_rec2;

   

   --레코드 내 각 칼럼의 값을 개별적으로 출력함

   DBMS_OUTPUT.PUT_LINE('deptno:' || dept_rec2.deptno || ', dname:' || dept_rec2.dname || ', loc:' || dept_rec2.loc);

   

   CLOSE c1;  

END;

/
```

### 데이터 타입 간의 형변환

일부 데이터 타입의 경우 상호 데이터 타입 변환이 가능합니다. 숫자에서 문자 문자에서 날짜 날짜에서 문자 타입 등 변환이 가능합니다. 형 변환 함수를 사용 해 명시적으로 가능 할 수 있으며, 변경이 가능한 경우에 한해서 오라클에 의해 묵시적으로 자동 변환 될 수 있습니다. 그러나 가급적 올바른 데이터 타입을 선정하여 사용 하도록 하고, 변환이 필요한 경우 명시적으로 선언하여, 개발자가 모르는 사이에 형 변환에 따른 문제가 생기지 않도록 하는 것이 중요합니다.

예를 보면 emp 테이블의 empno 칼럼의 경우 NUMBER 형이지만, VARCHAR2형 변수인 I_var_empno에 정상적으로 입력 된 것을 볼 수 있습니다. 이는 오라클의 숫자형을 문자형으로 암시적으로 형변환 했기 때문입니다.

다음으로, I_var_empno 변수 타입은 문자형이나 1을 더하는 연산을 수행하여 I_NUM_empno 변수에 정상적으로 처리 되었습니다. 이는 역시 오라클이 문자형을 숮사형으로 변환했음을 보여줍니다.

```sql
DECLARE
	I_num_empno NUMBER;
	I_var_empno VARCHAR2(100);

BEGIN

	--number형의 값을 VARCHAR2 형 변수에 입력
	SELECT empno
	INTO I_var_empno
	FROM emp
	WHERE rownum = 1;

DBMS_OUTPUT.PUT_LINE('empno(number to varchar2) :' || I_var_empno);

I_num_empno := I_var_empno + 1;

BMS_OUTPUT.PUT_LINE('empno(varchar2 to number) :' || I_num_empno);

END;
```