---
layout: single
title:  "코딩테스트 문제 풀이 3"
categories: codingtest  
tag: [코딩테스트] 
toc: true 
author_profile: false
# sidebar: 
#   nav: "docs"
search: true
---


> ### 문제 설명 

[신고 결과 받기](https://school.programmers.co.kr/learn/courses/30/lessons/92334)

*** 

> ### 엉망진창 나의 풀이 과정

map()을 문제의 논리와 어떻게 연결해야 할지 모르겠다...

```js

```


***

> ### 다른 사람들의 코드를 통한 개선 및 회고

* key - value 관계가 약간만 복잡해져도 제대로 연결을 짓지 못한다. 
* 1개 이상의 중복이 안 된다는 점에서 map()을 써야 한다는 생각을 했다면.. 

* 앞으로 회고는 단순 고찰보다는 "어떻게 구현해야 했고 나는 어떻게 구현하려고 했기에 이 구현 방식에 도달하지 못했는지"를 중심으로 서술해야겠다. 단순 피드백으로는 성장하지 않는 느낌이 매우 강하게 든다. 

```js
function solution(id_list, report, k) {

  const answer = new Array(id_list.length);
  answer.fill(0) 
  // console.log(answer); --> output : [0, 0, 0, 0]
  const report_list = {} // 
  

  id_list.map((user)=>{
      report_list[user] = [] //key로 userid를 value로 빈 배열을 가지는 객체
  })
  // console.log(report_list); --> output : { muzi: [], frodo: [], apeach: [], neo: [] }

  
  
  report.map((user)=>{
      const [user_id, report_id] = user.split(' ') // report를 구분하는 방법. 
      if(!report_list[report_id].includes(user_id)){
          report_list[report_id].push(user_id) // 값이 없으면, 신고 당한 애를 key로 하고, value에 신고한 애의 id를 각각 넣어줘. 
      }        
  })
  //console.log(report_list);
  /* output : 

  {
  muzi: [ 'apeach' ],
  frodo: [ 'muzi', 'apeach' ],
  apeach: [],
  neo: [ 'frodo', 'muzi' ]
  }
  
  */
  
  for(const key in report_list){
      if(report_list[key].length >= k){ //이용정지 유저 
          report_list[key].map((user)=>{
              answer[id_list.indexOf(user)] += 1
          })
      }
  }


  return answer;
}

let input = [["muzi", "frodo", "apeach", "neo"], ["muzi frodo", "apeach frodo", "frodo neo", "muzi neo", "apeach muzi"], 2]

console.log(solution(input[0], input[1], input[2])); 
```
[풀이 출처](https://velog.io/@dnjsdud2257/코딩테스트-신고-결과-받기-JavaScript)

***

> ### 추가 공부 : 


