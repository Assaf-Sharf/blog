---
title: "Kafka Streams 101"
date: 2021-09-15
header:
  image: "/images/blog cover.jpg"
tags: []
excerpt: ""
---

Apache Kafka nowadays is clearly the leading technology concerning message brokers. It's scalable, resilient, and easy to use. Moreover, it leverages a bunch of interesting client libraries that offer a vast set of additional feature. One of this libraries is _kafka-streams_. 

Kafka streams brings a completely full stateful streaming system based directly on top of Kafka. Moreover, it introduces many interesting concepts, like the duality between topics and database tables. Implementing such concepts, kafka streams provide us many useful operation on topics, such as joining messages, grouping capabilities, and so on.

Because the kafka-streams library is very large and quite complex, this article will introduce only its main features, such use the architecture, the types `KStream`, `KTable`, and `GlobalKTable`, and some information about the _state store_.

## 1. Set up

As we said, the Kafka streams are implemented using a set of client libraries. In addition, we will use the Circe library to deal with JSON messages. Using Scala as the language to make some experiments, we have to declare the following dependencies in the `build.sbt` file:

```sbt
libraryDependencies ++= Seq(
  "org.apache.kafka" %  "kafka-clients"        % "2.8.0",
  "org.apache.kafka" %  "kafka-streams"        % "2.8.0",
  "org.apache.kafka" %% "kafka-streams-scala"  % "2.8.0",
  "io.circe"         %% "circe-core"           % "0.14.1",
  "io.circe"         %% "circe-generic"        % "0.14.1",
  "io.circe"         %% "circe-parser"         % "0.14.1"
)
```

Among the dependencies, we find the `kafka-streams-scala` libraries, which is a Scala wrapper built around the Java `kafka-streams` library. In fact, using implicit resolution, the tailored Scala library avoid some boilerplate code.

We will use version 2.8.0, of Kafka, the latest stable version at the moment. As we've done in the article [ZIO Kafka: A Practical Streaming Tutorial](https://blog.rockthejvm.com/zio-kafka/), we will start the Kafka broker using a Docker container. So, the `docker-compose.yml` file describing the container is the following:

```yaml
version: '2'
services:
  zookeeper:
    image: confluentinc/cp-zookeeper:6.2.0
    hostname: zookeeper
    container_name: zookeeper
    ports:
      - "2181:2181"
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000

  kafka:
    image: confluentinc/cp-kafka:6.2.0
    hostname: broker
    container_name: broker
    depends_on:
      - zookeeper
    ports:
      - "29092:29092"
      - "9092:9092"
      - "9101:9101"
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: 'zookeeper:2181'
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:29092,PLAINTEXT_HOST://localhost:9092
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
      KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: 1
      KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 1
      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0
      KAFKA_JMX_PORT: 9101
      KAFKA_JMX_HOSTNAME: localhost
```

Please, refer to the above article for further details on starting the Kafka broker inside Docker.

As usual, we need a use case to work with. Imagine we have an e-commerce site and want to use Kafka to implement some part of the orders' workflow:

```scala
type UserId = String
type Product = String
type OrderId = String

case class Order(orderId: OrderId, user: UserId, products: List[Product], amount: Double)
```

Since this information will use Kafka messages and topics, we need to set up our application, creating the topic in the Kafka broker storing orders. We call the topic `orders-by-user`. As we did for the article "ZIO Kafka: A Practical Streaming Tutorial", we use the clients libraries contained in the Docker image:

```shell
kafka-topics \
  --bootstrap-server localhost:9092 \
  --topic orders-by-user \
  --create
```

To improve the readability of the code we will write, we define also a constant containing the name of the topic:

```scala
final val OrdersByUserTopic = "orders-by-user"
```

As the name of the topic suggests, its messages will have the `UserId` as keys. 

## 2. Basics

As we said, the kafka streams library is a client library, and it allows handling workflows that read from a topic and write to another topic as a stream.

As we should know, we build streaming applications around three concepts: sources, flows (or pipes), and sinks. Often, we represent streams as a series of token, generated by a source, transformed by flows and consumed by sinks:

TODO: Insert a graphic representation of a stream

A source is where the execution starts, and information is created. Sources generate token, and in kafka streams they are represented by a topic receiving messages. 

A flow is nothing more than a transformation applied to every token. In functional programming, we represent flows using function such as `map`, `filter`, `flatMap`, and so on.

Last but not least, a sink is where the token are consumed. After a sink, the token doesn't exist anymore. In kafka streams, sinks can consume token to a Kafka topics, or use anything other technology to consume them (i.e., the standard output, a database, etc.)

In kafka streams jargon, both sources, flows, and sinks are called _stream processors_. A streaming application is nothing more than a graph where each node is a processor, and edges are called _streams_. We can call such graph a _topology_.

TODO: Image of a topology

So, with these bullets in our Kafka gun, let's proceed dive a little deeper in how we can implement our use case using the kafka-streams library.

## 3. Messages Serialization and Deserialization

If we want to create any structure on top of Kafka topics, such as stream, we need a standard way to serialize objects into a topic, and to deserialize messages from topic to objects. While the Kafka library defines serializers and deserializers as different types, the Kafka stream  library uses the so call `Serde` type.

what's a `Serde`? The `Serde` word stands for `Serializer` and `Deserializer` and an instance of a `Serde` provides the logic to read and write a message from and to a Kafka topic.

So, if we have a `Serde[R]` instance, we can deserialize and serialize messages of the type `R`. In this article we will use JSON format for the payload of Kafka messages. In Scala, one of the most used libraries to marshall and unmarshall JSON into objects is Circe. We already talk about Circe in the post [Unleashing the Power of HTTP Apis: The Http4s Library](https://blog.rockthejvm.com/http4s-tutorial/), when we used it together with the Http4s library.

This time, we use Circe to create a `Serde` instance. The Scala kafka streams library comes with a lot of `Serde` instances for all the primitive types:

```scala
// Scala kafka-stream library
object Serdes {
  implicit def stringSerde: Serde[String]
  implicit def longSerde: Serde[Long]
  implicit def javaLongSerde: Serde[java.lang.Long]
  implicit def byteArraySerde: Serde[Array[Byte]]
  implicit def bytesSerde: Serde[org.apache.kafka.common.utils.Bytes]
  implicit def byteBufferSerde: Serde[ByteBuffer]
  implicit def shortSerde: Serde[Short]
  implicit def javaShortSerde: Serde[java.lang.Short]
  implicit def floatSerde: Serde[Float]
  implicit def javaFloatSerde: Serde[java.lang.Float]
  implicit def doubleSerde: Serde[Double]
  implicit def javaDoubleSerde: Serde[java.lang.Double]
  implicit def intSerde: Serde[Int]
  implicit def javaIntegerSerde: Serde[java.lang.Integer]
  implicit def uuidSerde: Serde[UUID] = JSerdes.UUID()
  // ...
}
```

In addition, the `Serdes` object defines the function `fromFn`, which we can use to build our custom instance of `Serde`:

```scala
// Scala kafka-stream library
def fromFn[T >: Null](serializer: T => Array[Byte], deserializer: Array[Byte] => Option[T]): Serde[T]
```

Wiring all the information together, we can use the above function to create a `Serde` using Circe:

```scala
def serde[A >: Null : Decoder : Encoder]: Serde[A] = {
  val serializer = (a: A) => a.asJson.noSpaces.getBytes
  val deserializer = (aAsBytes: Array[Byte]) => {
    val aAsString = new String(aAsBytes)
    val aOrError = decode[A](aAsString)
    aOrError match {
      case Right(a) => Option(a)
      case Left(error) =>
        println(s"There was an error converting the message $aOrError, $error")
        Option.empty
    }
  }
  Serdes.fromFn[A](serializer, deserializer)
}
```

The `serde` function constraints the type `A` to have Circe `Decoder` and `Encoder` implicitly defined in the scope. Then, it uses the type class `Encoder[A]` to create a JSON string:

```scala
a.asJson
``` 

Moreover, the function uses the type class `Decoder[A]` to parse a JSON string into an object:

```scala
decode[A](aAsString)
```

Fortunately, we can autogenerate Circe `Encoder` and `Decoder` type classes importing `io.circe.generic.auto._`.

Now that we understand the types the library uses to write and read from a Kafka topic, and that we create some utility functions to deal with such types, we can go on and understand how to build our first stream topology.

## 4. Creating the Topology

First thing, we need to define the topology of our streaming application. We will use the _Stream DSL` to define it. This DSL, built on top of the low level [Processor API](https://docs.confluent.io/platform/current/streams/developer-guide/processor-api.html#streams-developer-guide-processor-api), is easier to use and master, having a declarative approach. Using the Stream DSL we don't have to deal with stream processor nodes directly. The Kafka stream library will create the best processors' topology reflecting the operation with need. 

So, first, we need an instance of the builder type provided by the library:

```scala
val builder = new StreamsBuilder
```

The builder lets us creating the basic type of the Stream DSL, which are the`KStream`, `Ktable`, and `GlobalKTable` types. Let's see how.

### 4.1. Building a `KStream`

First, we need to define our source. The source, will read incoming messages from the Kafka topic `orders-by-user`, we've just defined. Differently from other streaming libraries, such as Akka Streams, the kafka-streams library doesn't define specific types for sources, pipes, and sinks:

```scala
val usersOrdersStreams: KStream[UserId, Order] = builder.stream[UserId, Order](OrdersByUserTopic)
```

There are a lot of things going on the above code. First, we introduced the first notable citizen of the kafka stream library: the `KStream[K, V]` type. We can imagine a `KStream` as a regular stream of Kafka messages. Each message as a key of type `K` and a value of type `V`. 

Moreover, the API to build a new stream seems to be very straightforward because there are a lot of "implicit magic" under the hood. In fact, the complete signature of the methods is

```scala
// Scala kafka-stream library
def stream[K, V](topic: String)(implicit consumed: Consumed[K, V]): KStream[K, V]
```

You may wonder what the heck is a `Consumed[K, V]` is. Well, it's the Java way to provide to the stream a `Serde` for the key and for the value of the Kafka message. Having previously defined the `serde` function, we can build a `Serde` for our `Order` class in a straightforward way. We usually put such classes in the companion object:

```scala
object Order {
  implicit val orderSerde: Serde[Order] = serde[Order]
}
```

We can go even further on the implicit generation of the `Serde` class. In fact, if we define the previous `serde` function as `implicit`, the Scala compiler will generate automatically the `orderSerde`, since the `Order` class fulfills all the needed context bounds.

So, just as a recap, the following implicit resolution takes place:

```
Order => Decoder[Order] / Encoder[Order] => Serde[Order] => Consume[Order]
```

Why do we need `Serde` types to be implicit? The main reason is that the Scala kafka stream provides the object `ImplicitConversions`. Inside this `object`, we find a lot of useful conversion functions that, given `Serde` objects for the key and the values of a Kafka message, let us define a lot of other types, such as the above `Consumed`. Again, all these conversions save us writing a lot of boilerplate code, which we should have written in Java, for example.

After the definition of the needed `Serde` types we can return to the definition of our streams. As we said, a `KStream[K, V]` represents a stream of Kafka messages. This type defines many useful functions on it, which can grouped into two different families: stateless transformations, and stateful transformation. While the former use only in memory data structures, the latter require to save some information inside the so called _state store_.

### 4.2. Building `KTable` and `GlobalKTable`

The Kafka stream libraries offers two more kind of processors: `KTable`, and `GlobalKTable`. We build both processors on top of a _compacted topic_. We can think of a compacted topic as a table, indexed by the messages' key. Messages are not deleted by the broker using a time to live policy. Every time a new message arrives, a "row" it's added to the "table" if the key were not present, or the value associated with the key is updated otherwise. To delete a "row" from the "table", we just send to the topic a `null` value associated with the selected key.

To make a topic compacted, we need to specify it during its creation:

```shell
kafka-topics \
  --bootstrap-server localhost:9092 \
  --topic discount-profiles-by-user \
  --create \
  --config "cleanup.policy=compact"
```

The above topic will be the starting point to extend our Kafka stream application. In fact, the messages in it has a `UserId` as key, and a discount profile as value. A discount profile tells for each user which is the discount the e-commerce site could apply to the orders of a user. For sake of simplicity, we represent profiles as simple `String`:

```scala
type Profile = String
```

Which is the difference between the two? Well, the difference is that a `KTable` is partitioned between the nodes of the Kafka cluster. However, every node of the cluster receive a full copy of the messages of a `GlobalKTable`. So, be careful with `GlobalKTable`.

Creating a `KTable` or a `GlobalKTable` it's easy. As an example, let's create a `KTable` on top of the `discount-profiles-by-user` topic. Returning to our example, as the users' number of our e-commerce might be high, we need to partition the information among the nodes of the Kafka cluster. So, let's create the `KTable`:

```scala
final val DiscountProfilesByUserTopic = "discount-profiles-by-user"

val userProfilesTable: KTable[UserId, Profile] =
  builder.table[UserId, Profile](DiscountProfilesByUserTopic)
```

As you can imagine, there is more behind the scene than what we can see. Again, using the chain of implicit conversions, the Scala Kafka stream library is creating for us an instance of the `Consumed` class, which is mainly used to pass `Serde` instances around. In this particular case, we are using the `Serdes.stringSerde` implicit object, both for the key and for the value of the topic.

The methods defined on the `KTable` type are more or less the same as those defined on a `KStream`. In addition, a `KTable` can be easily converted into a `KStream` using the following method (or one of its variants):

```scala
// Scala kafka-stream library
def toStream: KStream[K, V]
```

As we can imagine, creating a `GlobalKTable` is easy as well, we only need a compacted topic containing a number of keys that is affordable for each the cluster node:

```shell
kafka-topics \
  --bootstrap-server localhost:9092 \
  --topic discounts \
  --create \
  --config "cleanup.policy=compact"
```

We can think the  number of different instances of discount `Profile` is very low. So. let's create a `GlobalKTable` on top of a topic mapping each discount profile to an effective discount. First, we define the type modelling a discount:

```scala
final val DiscountsTopic = "discounts"

case class Discount(profile: Profile, amount: Double)
```

Then, we can create an instance of the needed `GlobalKTable`:

```scala
val discountProfilesGTable: GlobalKTable[Profile, Discount] = 
  builder.globalTable[Profile, Discount](DiscountsTopic)
```

Again, under the hood, an instance of a `Consumed` object is created by the library.

The `GlobalKTable` type doesn't define any interesting method. So, why should we ever create an instance of a `GlobalKTable`? The answer is in the word "joins". But first, we need to introduce streams transformations.

## 5. Streams Transformations

Once obtained a `KStream` or a `KTable`, we can transform the information they contain using _transformations_. The Kafka stream library offers two kind of transformations: stateless, and stateful. While the former executes only in memory, the latter requires managing a state to perform. 

#### 5.1. Stateless Transformations

In the group of stateless transformation we find the classic function defined on streams, such as `filter`, `map`, `flatMap`, etc. Say, for example, that we want to filter all the orders with an amount greater than 1,000.00 euro. We can use the `filter` function (the library also provides a useful function `filterNot`):

```scala
val expensiveOrders: KStream[UserId, Order] = usersOrdersStreams.filter { (userId, order) =>
  order.amount >= 1000
}
```

Let's say, instead, that we want to extract a stream of all the ordered products, maintaining the
`UserId` a the message key. Since we want to map only the values of the Kafka messages, we can use the `mapValue` function:

```scala
val purchasedListOfProductsStream: KStream[UserId, List[Product]] = usersOrdersStreams.mapValues { order => 
  order.products
}
```

Going further, we can obtain a `KStream[UserId, Product]` instead, just using the `flatMapValues` function:

```scala
val purchasedProductsStream: KStream[UserId, Product] = usersOrdersStreams.flatMapValues { order =>
  order.products
}
```

Moreover, we also considered stateless transformations terminal operations or sinks. They represent a terminal node of our stream topology. We can apply no other function to the stream after a sink is reached. Two examples of sink processors are the `foreach` and `to` methods.

The `foreach` method applies to a stream a given function:

```scala
// Scala kafka-stream library
def foreach(action: (K, V) => Unit): Unit
```

As an example, imagine we want to print all the product purchased by a user. We can call the ` foreach` method directly on the `purchasedProductsStream` stream:

```scala
purchasedProductsStream.foreach { (userId, product) => 
  println(s"The user $userId purchased the product $product")
}
```

Another interesting sink processor is the `to` method, which persist the messages of the stream into a new topic:

```scala
expensiveOrders.to("suspicious-orders")
```

In the above example, we are writing all the order with an amount greater than 1,000 Euro in a dedicated topic, probably to perform some kind of fraud analysis on them. Also, this time the Scala kafka stream library saves us to type a lot of code. In fact, the complete signature of the `to` method is the following:

```scala
// Scala kafka-stream library
def to(topic: String)(implicit produced: Produced[K, V]): Unit
```

Again, the implicit instance of the `Produced` type, which is a wrapper around key and value `Serde` is produced automatically by the functions in the `ImplicitConversions` object, plus our `serde` implicit function.

Last but not least, we have grouping, which groups different values under the same key or a different key. We group values maintaining the original key using the `groupByKey` transformation:

```scala
// Scala kafka-stream library
def groupByKey(implicit grouped: Grouped[K, V]): KGroupedStream[K, V]
```

As usual, the `Grouped` object carries the `Serde` types for keys and values, and it's automatically derived by the compiler is we use the Scala Kafka stream library. 

As an example, imagine we want to group the `purchasedProductsStream` so that we can perform some aggregated operation later. In detail, we want to group each user with the products she purchased:

```scala
val productsPurchasedByUsers: KGroupedStream[UserId, Product] = purchasedProductsStream.groupByKey
```

As we may notice, we introduced a new type of stream, the `KGroupedStream`. This type defines only stateful transformation on it. So, for this reason we say that grouping is the precondition to stateless transformations.

However, if we want to change the key of the grouped information, we can use the `groupBy` transformation:

```scala
val purchasedByFirstLetter: KGroupedStream[String, Product] =
  purchasedProductsStream.groupBy[String] { (userId, products) =>
    userId.charAt(0).toLower.toString
  }
```

In the above example, we are grouping products by the first letter of the `userId` of the user who purchased them. From the code, it seems a harmless operation, as we are only changing the key of the stream. However, since Kafka partitioned topics by key, we are marking the stream for re-partitioning. 

So, if the marked stream will be materialized in a topic or in a state store (more to come on state stores) by a next transformation, the contained messages will be potentially moved to another node of the Kafka cluster, which owns the partition containing the messages with the new key. Re-partitioning is an operation that should be done with caution, because it could generate a heavy network load.

#### 5.2. Stateful Transformations

As the name of this type of transformations suggested, the Kafka stream library needs to maintain some kind of state to manage them, and it's called _state store_. The state store, which is automatically managed by the library if we use the Stream DSL, can be an in memory hashmap or an instance of [RocksDB](http://rocksdb.org/), or any other convenient data structure.

Each state store is local to the node containing the instance of the stream application, and refers to the messages concerning the partitions owned by the node. So, the global state of a stream application is the sum of all the state of the single nodes. Kafka Streams offers fault-tolerance and automatic recovery for local state stores.

Now that we know about the existence of state stores, we can start talking of stateful transformations. There many types of them, such as:

 - Aggregations
 - Aggregations using windowing
 - Joins

We will treat joins in a dedicated section. However, we can make some examples of aggregations. Aggregations are key-based operations, which means that they always operate over records of the same key. 

As we saw, we previously obtained a `KGroupedStream` containing the products purchased by each user:

```scala
val productsPurchasedByUsers: KGroupedStream[UserId, Product] = purchasedProductsStream.groupByKey
```

Now we can count how many products purchased each user, by calling the `count` transformation:

```scala
val numberOfProductsByUser: KTable[UserId, Long] = productsPurchasedByUsers.count()
```

Since the number of products purchased by users updates every time a new messages is available, the result of the `count` transformation is a `KTable`, which will update during time accordingly.

The `count` transformation uses the implicit parameters' resolution we just saw. In fact, it's signature is the following:

```scala
// Scala kafka-stream library
def count()(implicit materialized: Materialized[K, Long, ByteArrayKeyValueStore]): KTable[K, Long]
```

As for the `Consumed` implicit objects, the implicit `Materialized[K, V, S]` instance is derived by the compiler directly from the available implicit instances of key and value `Serde`.

The `count` transformation is not the only type of aggregation in the Kafka stream library, which also offers generic aggregations. Since simple aggregations are very similar to the example we associated with the `count` transformation, we introduce instead _windowed aggregations_.

In detail, the Kafka stream library lets us aggregating messages using a time window. All the messages arrived inside the window are eligible for being aggregated. Clearly, we are talking about a sliding window through time. The library allows us to aggregate using different types of windows, each one with its own features. Since [windowing](https://docs.confluent.io/platform/current/streams/developer-guide/dsl-api.html#streams-developer-guide-dsl-windowing) is a complex issue, we will not go deeper into it in this article.

For our example we will use _Tumbling time windows_. They model fixed-size, non-overlapping, gap-less windows. In detail, we want to know how many products our users purchased every ten seconds. First, we need to create the window representation:

```scala
val everyTenSeconds: TimeWindows = TimeWindows.of(10.second.toJava)
```

Then, we use it to define our windowed aggregation:

```scala
val numberOfProductsByUserEveryTenSeconds: KTable[Windowed[UserId], Long] =
  productsPurchasedByUsers.windowedBy(everyTenSeconds)
    .aggregate[Long](0L) { (userId, product, counter) => 
      counter + 1
    }
```

As for the `count` transformation, the final result is a `Ktable`. However, this time we have a `Windowed[UserId]` as key type, which is a convenient type containing both the key and the lower and upper bound of the window.

The Scala Kafka stream library defines the `aggregate` transformation as the Scala language defines the `foldLeft` method on sequences. The first parameter is the starting accumulation point, and the second is the folding function. Finally, an implicit instance of a `Materialized[K, V, S]` object is automatically derived by the compiler:

```scala
// Scala kafka-stream library
def aggregate[VR](initializer: => VR)(aggregator: (K, V, VR) => VR)(
    implicit materialized: Materialized[K, VR, ByteArrayWindowStore]
  ): KTable[Windowed[K], VR]
```

## 6. Joining Streams

In my opinion, the most important feature of the Kafka stream library is joining streams. The Kafka team strongly supports the [duality between streams and database tables](https://docs.confluent.io/platform/current/streams/concepts.html#duality-of-streams-and-tables). To keep it simple, we can view a stream as the changelog of a database table, which primary keys are equal to the keys of the Kafka messages.

Following this duality, we can think about records in a `KStream` as they are INSERT operations on a table. For the nature of a `KStream`, every message is different from any previous message. Instead, a `KTable` is an abstraction of a changelog stream, where each record represents an UPSERT: if the key is not present in the table, the record is equal to an INSERT, and UPDATE otherwise.

With these concepts in mind, it's easier for us to accept the existence of a join operation between Kafka streams.

Joins are stateful operation, which means they require a state store to execute.

The easiest kind of join is between a `KStream` and a `KTable`. The join operation is on the keys of the messages. Returning to our main example, imagine we want to join the orders stream, which is indexed by `UserId`, with the table containing the discount profile of each user:

```scala
val ordersWithUserProfileStream: KStream[UserId, (Order, Profile)] =
  usersOrdersStreams.join[Profile, (Order, Profile)](userProfilesTable) { (order, profile) =>
    (order, profile)
  }
```

As we have seen in many cases, the Scala Kafka stream library saves us to digit a lot of boilerplate code, implicitly deriving the type that carries the `Serde` information:

```scala
// Scala kafka-stream library
def join[VT, VR](table: KTable[K, VT])(joiner: (V, VT) => VR)(implicit joined: Joined[K, V, VT]): KStream[K, VR]
```

As we notice, we associate the type parameters of the join function with the type of the values inside the `KTable` and the type of the values in the resulting stream. The first method parameter is clearly the `KTable`, whereas the second is a function that given the pair of the joined values, returns a new value of any type.

In our use case, the join produces a stream containing all the orders of each user, added with the discount profile information.


